diff -Naur gdb-6.5.orig/bfd/sysdep.h gdb-6.5/bfd/sysdep.h
--- gdb-6.5.orig/bfd/sysdep.h	2005-05-05 20:51:14.000000000 +0200
+++ gdb-6.5/bfd/sysdep.h	2009-01-22 08:19:21.000000000 +0100
@@ -135,7 +135,7 @@
 #endif
 
 #if !HAVE_DECL_STRSTR
-extern char *strstr ();
+/* extern char *strstr (); */
 #endif
 
 #ifdef HAVE_FTELLO
diff -Naur gdb-6.5.orig/configure gdb-6.5/configure
--- gdb-6.5.orig/configure	2006-05-02 02:16:50.000000000 +0200
+++ gdb-6.5/configure	2009-01-22 08:19:21.000000000 +0100
@@ -3648,7 +3648,7 @@
     # For an installed makeinfo, we require it to be from texinfo 4.4 or
     # higher, else we use the "missing" dummy.
     if ${MAKEINFO} --version \
-       | egrep 'texinfo[^0-9]*([1-3][0-9]|4\.[4-9]|[5-9])' >/dev/null 2>&1; then
+       | egrep 'texinfo[^0-9]*(4\.([4-9]|[1-9][0-9])|[5-9]|[1-9][0-9])' >/dev/null 2>&1; then
       :
     else
       MAKEINFO="$MISSING makeinfo"
diff -Naur gdb-6.5.orig/configure.in gdb-6.5/configure.in
--- gdb-6.5.orig/configure.in	2006-06-21 07:16:16.000000000 +0200
+++ gdb-6.5/configure.in	2009-01-22 08:19:21.000000000 +0100
@@ -2217,7 +2217,7 @@
     # For an installed makeinfo, we require it to be from texinfo 4.4 or
     # higher, else we use the "missing" dummy.
     if ${MAKEINFO} --version \
-       | egrep 'texinfo[^0-9]*([1-3][0-9]|4\.[4-9]|[5-9])' >/dev/null 2>&1; then
+       | egrep 'texinfo[^0-9]*(4\.([4-9]|[1-9][0-9])|[5-9]|[1-9][0-9])' >/dev/null 2>&1; then
       :
     else
       MAKEINFO="$MISSING makeinfo"
diff -Naur gdb-6.5.orig/gdb/bfin-tdep.c gdb-6.5/gdb/bfin-tdep.c
--- gdb-6.5.orig/gdb/bfin-tdep.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/gdb/bfin-tdep.c	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,1341 @@
+/* Target-dependent code for Analog Devices Blackfin processer, for GDB.
+
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Analog Devices.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include "defs.h"
+#include "frame.h"
+#include "frame-base.h"
+#include "frame-unwind.h"
+#include "dwarf2-frame.h"
+#include "trad-frame.h"
+#include "inferior.h"
+#include "gdbcore.h"
+#include "dis-asm.h"
+#include "regcache.h"
+#include "arch-utils.h"
+#include "gdb_assert.h"
+#include "sim-regno.h"
+#include "bfin-tdep.h"
+#include "gdb/sim-bfin.h"
+#include "elf-bfd.h"
+#include "elf/bfin.h"
+#include "infcall.h"
+
+/* Macros used by prologue functions.  */
+#define P_LINKAGE			0xE800
+#define P_MINUS_SP1			0x0140
+#define P_MINUS_SP2			0x05C0
+#define P_MINUS_SP3			0x0540
+#define P_MINUS_SP4			0x04C0
+#define P_SP_PLUS			0x6C06
+#define P_P2_LOW			0xE10A
+#define P_P2_HIGH			0XE14A
+#define P_SP_EQ_SP_PLUS_P2		0X5BB2
+#define P_SP_EQ_P2_PLUS_SP		0x5B96
+#define P_MINUS_MINUS_SP_EQ_RETS	0x0167
+
+/* Macros used for program flow control.  */
+/* 16 bit instruction, max  */
+#define P_16_BIT_INSR_MAX		0xBFFF
+/* 32 bit instruction, min  */
+#define P_32_BIT_INSR_MIN		0xC000
+/* 32 bit instruction, max  */
+#define P_32_BIT_INSR_MAX		0xE801
+/* jump (preg), 16-bit, min  */
+#define P_JUMP_PREG_MIN			0x0050
+/* jump (preg), 16-bit, max  */
+#define P_JUMP_PREG_MAX			0x0057
+/* jump (pc+preg), 16-bit, min  */
+#define P_JUMP_PC_PLUS_PREG_MIN		0x0080
+/* jump (pc+preg), 16-bit, max  */
+#define P_JUMP_PC_PLUS_PREG_MAX		0x0087
+/* jump.s pcrel13m2, 16-bit, min  */
+#define P_JUMP_S_MIN			0x2000
+/* jump.s pcrel13m2, 16-bit, max  */
+#define P_JUMP_S_MAX			0x2FFF
+/* jump.l pcrel25m2, 32-bit, min  */
+#define P_JUMP_L_MIN			0xE200
+/* jump.l pcrel25m2, 32-bit, max  */
+#define P_JUMP_L_MAX			0xE2FF
+/* conditional jump pcrel11m2, 16-bit, min  */
+#define P_IF_CC_JUMP_MIN		0x1800
+/* conditional jump pcrel11m2, 16-bit, max  */
+#define P_IF_CC_JUMP_MAX		0x1BFF
+/* conditional jump(bp) pcrel11m2, 16-bit, min  */
+#define P_IF_CC_JUMP_BP_MIN		0x1C00
+/* conditional jump(bp) pcrel11m2, 16-bit, max  */
+#define P_IF_CC_JUMP_BP_MAX		0x1FFF
+/* conditional !jump pcrel11m2, 16-bit, min  */
+#define P_IF_NOT_CC_JUMP_MIN		0x1000
+/* conditional !jump pcrel11m2, 16-bit, max  */
+#define P_IF_NOT_CC_JUMP_MAX		0x13FF
+/* conditional jump(bp) pcrel11m2, 16-bit, min  */
+#define P_IF_NOT_CC_JUMP_BP_MIN		0x1400
+/* conditional jump(bp) pcrel11m2, 16-bit, max  */
+#define P_IF_NOT_CC_JUMP_BP_MAX		0x17FF
+/* call (preg), 16-bit, min  */
+#define P_CALL_PREG_MIN			0x0060
+/* call (preg), 16-bit, max  */
+#define P_CALL_PREG_MAX			0x0067
+/* call (pc+preg), 16-bit, min  */
+#define P_CALL_PC_PLUS_PREG_MIN		0x0070
+/* call (pc+preg), 16-bit, max  */
+#define P_CALL_PC_PLUS_PREG_MAX		0x0077
+/* call pcrel25m2, 32-bit, min  */
+#define P_CALL_MIN			0xE300
+/* call pcrel25m2, 32-bit, max  */
+#define P_CALL_MAX			0xE3FF
+/* RTS  */
+#define P_RTS				0x0010
+/* MNOP  */
+#define P_MNOP				0xC803
+/* EXCPT, 16-bit, min  */
+#define P_EXCPT_MIN			0x00A0
+/* EXCPT, 16-bit, max  */
+#define P_EXCPT_MAX			0x00AF
+/* multi instruction mask 1, 16-bit  */
+#define P_BIT_MULTI_INS_1		0xC000
+/* multi instruction mask 2, 16-bit  */
+#define P_BIT_MULTI_INS_2		0x0800
+
+/* Macros used for signal handling  */
+/* Instruction 1 for signal  */
+#define P_SIGNAL_INS_1			0x0077E128
+/* Instruction 1 for rt_signal  */
+#define P_RT_SIGNAL_INS_1		0x00ADE128
+/* Instruction 2 is common for both signal and rt_signal  */
+#define P_SIGNAL_INS_2			0x000000A0
+
+/* The maximum bytes we search to skip the prologue.  */
+#define UPPER_LIMIT			40
+
+#define RETS_OFFSET			4
+
+/* Initial value: Register names used in BFIN's ISA documentation.  */
+
+static char *bfin_register_name_strings[] =
+{
+  "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
+  "p0", "p1", "p2", "p3", "p4", "p5", "sp", "fp",
+  "i0", "i1", "i2", "i3", "m0", "m1", "m2", "m3",
+  "b0", "b1", "b2", "b3", "l0", "l1", "l2", "l3",
+  "a0x", "a0w", "a1x", "a1w", "astat", "rets",
+  "lc0", "lt0", "lb0", "lc1", "lt1", "lb1", "cycles", "cycles2",
+  "usp", "seqstat", "syscfg", "reti", "retx", "retn", "rete",
+  "pc", "cc", "extra1", "extra2", "extra3", "fdpic_exec", "fdpic_interp",
+  "ipend"
+};
+
+
+#define NUM_BFIN_REGNAMES \
+  (sizeof (bfin_register_name_strings) / sizeof (char *))
+
+
+/* In this diagram successive memory locations increase downwards or the
+   stack grows upwards with negative indices. (PUSH analogy for stack.)
+
+   The top frame is the "frame" of the current function being executed.
+
+     +--------------+ SP    -
+     |  local vars  |       ^
+     +--------------+       |
+     |  save regs   |       |
+     +--------------+ FP    |
+     |   old FP    -|--    top
+     +--------------+  |  frame
+     |    RETS      |  |    |
+     +--------------+  |    |
+     |   param 1    |  |    |
+     |   param 2    |  |    |
+     |    ...       |  |    V
+     +--------------+  |    -
+     |  local vars  |  |    ^
+     +--------------+  |    |
+     |  save regs   |  |    |
+     +--------------+<-     |
+     |   old FP    -|--   next
+     +--------------+  |  frame
+     |    RETS      |  |    |
+     +--------------+  |    |
+     |   param 1    |  |    |
+     |   param 2    |  |    |
+     |    ...       |  |    V
+     +--------------+  |    -
+     |  local vars  |  |    ^
+     +--------------+  |    |
+     |  save regs   |  |    |
+     +--------------+<-  next frame
+     |   old FP     |       |
+     +--------------+       |
+     |    RETS      |       V
+     +--------------+       -
+
+   The frame chain is formed as following:
+
+     FP has the topmost frame.
+     FP + 4 has the previous FP and so on.  */
+
+
+/* Map from DWARF2 register number to GDB register number.  */
+
+int map_gcc_gdb[] =
+{
+  BFIN_R0_REGNUM,
+  BFIN_R1_REGNUM,
+  BFIN_R2_REGNUM,
+  BFIN_R3_REGNUM,
+  BFIN_R4_REGNUM,
+  BFIN_R5_REGNUM,
+  BFIN_R6_REGNUM,
+  BFIN_R7_REGNUM,
+  BFIN_P0_REGNUM,
+  BFIN_P1_REGNUM,
+  BFIN_P2_REGNUM,
+  BFIN_P3_REGNUM,
+  BFIN_P4_REGNUM,
+  BFIN_P5_REGNUM,
+  BFIN_SP_REGNUM,
+  BFIN_FP_REGNUM,
+  BFIN_I0_REGNUM,
+  BFIN_I1_REGNUM,
+  BFIN_I2_REGNUM,
+  BFIN_I3_REGNUM,
+  BFIN_B0_REGNUM,
+  BFIN_B1_REGNUM,
+  BFIN_B2_REGNUM,
+  BFIN_B3_REGNUM,
+  BFIN_L0_REGNUM,
+  BFIN_L1_REGNUM,
+  BFIN_L2_REGNUM,
+  BFIN_L3_REGNUM,
+  BFIN_M0_REGNUM,
+  BFIN_M1_REGNUM,
+  BFIN_M2_REGNUM,
+  BFIN_M3_REGNUM,
+  BFIN_A0_DOT_X_REGNUM,
+  BFIN_A1_DOT_X_REGNUM,
+  BFIN_CC_REGNUM,
+  BFIN_RETS_REGNUM,
+  BFIN_RETI_REGNUM,
+  BFIN_RETX_REGNUM,
+  BFIN_RETN_REGNUM,
+  BFIN_RETE_REGNUM,
+  BFIN_ASTAT_REGNUM,
+  BFIN_SEQSTAT_REGNUM,
+  BFIN_USP_REGNUM,
+  BFIN_LT0_REGNUM,
+  BFIN_LT1_REGNUM,
+  BFIN_LC0_REGNUM,
+  BFIN_LC1_REGNUM,
+  BFIN_LB0_REGNUM,
+  BFIN_LB1_REGNUM
+};
+
+
+/* Check whether insn1 and insn2 are parts of a signal trampoline.  */
+
+#define IS_SIGTRAMP(insn1, insn2)	\
+ /* P0=0x77 (X); EXCPT 0x0 */		\
+ ((insn1 == P_SIGNAL_INS_1) && ((insn2 & P_SIGNAL_INS_2) == P_SIGNAL_INS_2))
+
+#define IS_RT_SIGTRAMP(insn1, insn2)	\
+ /* P0=0xad (X); EXCPT 0x0 */		\
+ ((insn1 == P_RT_SIGNAL_INS_1) && ((insn2 & P_SIGNAL_INS_2) == P_SIGNAL_INS_2))
+
+#define SIGCONTEXT_OFFSET	28
+#define UCONTEXT_OFFSET		172
+
+
+/* From <asm/sigcontext.h>.  */
+
+static int bfin_linux_sigcontext_reg_offset[BFIN_NUM_REGS] =
+{
+  2 * 4,	/* %r0 */
+  3 * 4,	/* %r1 */
+  4 * 4,	/* %r2 */
+  5 * 4,	/* %r3 */
+  6 * 4,	/* %r4 */
+  -1,		/* %r5 */
+  -1,		/* %r6 */
+  -1,		/* %r7 */
+  7 * 4,	/* %p0 */
+  8 * 4,	/* %p1 */
+  9 * 4,	/* %p2 */
+  10 * 4,	/* %p3 */
+  -1,		/* %p4 */
+  -1,		/* %p5 */
+  1 * 4,	/* %sp */
+  -1,		/* %fp */
+  11 * 4,	/* %i0 */
+  12 * 4,	/* %i1 */
+  13 * 4,	/* %i2 */
+  14 * 4,	/* %i3 */
+  15 * 4,	/* %m0 */
+  16 * 4,	/* %m1 */
+  17 * 4,	/* %m2 */
+  18 * 4,	/* %m3 */
+  23 * 4,	/* %b0 */
+  24 * 4,	/* %b1 */
+  25 * 4,	/* %b2 */
+  26 * 4,	/* %b3 */
+  19 * 4,	/* %l0 */
+  20 * 4,	/* %l1 */
+  21 * 4,	/* %l2 */
+  22 * 4,	/* %l3 */
+  27 * 4,	/* %a0x */
+  28 * 4,	/* %a0w */
+  29 * 4,	/* %a1x */
+  30 * 4,	/* %a1w */
+  31 * 4,	/* %astat */
+  32 * 4,	/* %rets */
+  33 * 4,	/* %lc0 */
+  35 * 4,	/* %lt0 */
+  37 * 4,	/* %lb0 */
+  34 * 4,	/* %lc1 */
+  36 * 4,	/* %lt1 */
+  38 * 4,	/* %lb1 */
+  -1,		/* %cycles */
+  -1,		/* %cycles2 */
+  -1,		/* %usp */
+  39 * 4,	/* %seqstat */
+  -1,		/* syscfg */
+  40 * 4,	/* %reti */
+  41 * 4,	/* %retx */
+  -1,		/* %retn */
+  -1,		/* %rete */
+  40 * 4,	/* %pc */
+  -1,		/* %cc */
+  -1,		/* %extra1 */
+  -1,		/* %extra2 */
+  -1,		/* %extra3 */
+  -1		/* %ipend */
+};
+
+
+/* From <asm/ucontext.h>.  */
+
+static int bfin_linux_ucontext_reg_offset[BFIN_NUM_REGS] =
+{
+  1 * 4,	/* %r0 */
+  2 * 4,	/* %r1 */
+  3 * 4,	/* %r2 */
+  4 * 4,	/* %r3 */
+  5 * 4,	/* %r4 */
+  6 * 4,	/* %r5 */
+  7 * 4,	/* %r6 */
+  8 * 4,	/* %r7 */
+  9 * 4,	/* %p0 */
+  10 * 4,	/* %p1 */
+  11 * 4,	/* %p2 */
+  12 * 4,	/* %p3 */
+  13 * 4,	/* %p4 */
+  14 * 4,	/* %p5 */
+  15 * 4,	/* %sp */
+  24 * 4,	/* %fp */
+  25 * 4,	/* %i0 */
+  26 * 4,	/* %i1 */
+  27 * 4,	/* %i2 */
+  28 * 4,	/* %i3 */
+  29 * 4,	/* %m0 */
+  30 * 4,	/* %m1 */
+  31 * 4,	/* %m2 */
+  32 * 4,	/* %m3 */
+  37 * 4,	/* %b0 */
+  38 * 4,	/* %b1 */
+  39 * 4,	/* %b2 */
+  40 * 4,	/* %b3 */
+  33 * 4,	/* %l0 */
+  34 * 4,	/* %l1 */
+  35 * 4,	/* %l2 */
+  36 * 4,	/* %l3 */
+  18 * 4,	/* %a0x */
+  16 * 4,	/* %a0w */
+  19 * 4,	/* %a1x */
+  17 * 4,	/* %a1w */
+  20 * 4,	/* %astat */
+  21 * 4,	/* %rets */
+  41 * 4,	/* %lc0 */
+  43 * 4,	/* %lt0 */
+  45 * 4,	/* %lb0 */
+  42 * 4,	/* %lc1 */
+  44 * 4,	/* %lt1 */
+  46 * 4,	/* %lb1 */
+  -1,		/* %cycles */
+  -1,		/* %cycles2 */
+  -1,		/* %usp */
+  47 * 4,	/* %seqstat */
+  -1,		/* syscfg */
+  22 * 4,	/* %reti */
+  23 * 4,	/* %retx */
+  -1,		/* %retn */
+  -1,		/* %rete */
+  22 * 4,	/* %pc */
+  -1,		/* %cc */
+  -1,		/* %extra1 */
+  -1,		/* %extra2 */
+  -1,		/* %extra3 */
+  -1		/* %ipend */
+};
+
+/* Get info about saved registers in sigtramp.  */
+
+struct bfin_linux_sigtramp_info
+{
+  /* Address of context.  */
+  CORE_ADDR context_addr;
+
+  /* Offset of registers in `struct sigcontext'.  */
+  int *sc_reg_offset;
+};
+
+static enum bfin_abi
+bfin_abi (struct gdbarch *gdbarch)
+{
+  return gdbarch_tdep (gdbarch)->bfin_abi;
+}
+
+/* Return non-zero if PC points into the signal trampoline.  For the
+   sake of bfin_linux_get_sigtramp_info.  */
+
+static int
+bfin_linux_pc_in_sigtramp (struct frame_info *next_frame, CORE_ADDR pc)
+{
+  gdb_byte buf[12];
+  unsigned long insn0, insn1, insn2;
+
+  if (pc < 4
+      || pc >= (CORE_ADDR) 0x7ffffff8
+      || !safe_frame_unwind_memory (next_frame, pc - 4, buf, sizeof (buf)))
+    return 0;
+
+  insn1 = extract_unsigned_integer (buf + 4, 4);
+  insn2 = extract_unsigned_integer (buf + 8, 4);
+
+  if (IS_SIGTRAMP (insn1, insn2))
+    return 1;
+
+  if (IS_RT_SIGTRAMP (insn1, insn2))
+    return 2;
+
+  insn0 = extract_unsigned_integer (buf, 4);
+  if (IS_SIGTRAMP (insn0, insn1))
+    return 1;
+
+  if (IS_RT_SIGTRAMP (insn0, insn1))
+    return 2;
+
+  insn0 = ((insn0 << 16) & 0xffffffff) | (insn1 >> 16);
+  insn1 = ((insn1 << 16) & 0xffffffff) | (insn2 >> 16);
+
+  if (IS_SIGTRAMP (insn0, insn1))
+    return 1;
+
+  if (IS_RT_SIGTRAMP (insn0, insn1))
+    return 2;
+
+  return 0;
+}
+
+static struct bfin_linux_sigtramp_info
+bfin_linux_get_sigtramp_info (struct frame_info *next_frame)
+{
+  CORE_ADDR sp;
+  int ret;
+  struct bfin_linux_sigtramp_info info;
+
+  sp = frame_unwind_register_unsigned (next_frame, BFIN_SP_REGNUM);
+  ret = bfin_linux_pc_in_sigtramp (next_frame, frame_pc_unwind (next_frame));
+
+  if (ret == 1)
+    {
+      /* Get sigcontext address.  */
+      info.context_addr = sp + SIGCONTEXT_OFFSET;
+      info.sc_reg_offset = bfin_linux_sigcontext_reg_offset;
+    }
+  else if (ret == 2)
+    {
+      /* Get ucontext address.  */
+      info.context_addr = sp + UCONTEXT_OFFSET;
+      info.sc_reg_offset = bfin_linux_ucontext_reg_offset;
+    }
+  else
+    internal_error (__FILE__, __LINE__, _("not a sigtramp\n"));
+
+  return info;
+}
+
+/* Signal trampolines.  */
+
+static struct trad_frame_cache *
+bfin_linux_sigtramp_frame_cache (struct frame_info *next_frame,
+				 void **this_cache)
+{
+  struct frame_id this_id;
+  struct trad_frame_cache *cache;
+  struct bfin_linux_sigtramp_info info;
+  CORE_ADDR sp;
+  int i;
+
+  if (*this_cache)
+    return *this_cache;
+
+  cache = trad_frame_cache_zalloc (next_frame);
+
+  /* The frame ID's code address should be the start-address of the
+     signal trampoline and not the current PC within that trampoline.  */
+  sp = frame_unwind_register_unsigned (next_frame, BFIN_SP_REGNUM);
+
+  /* This would come after the LINK instruction in the ret_from_signal ()
+     function, hence the frame id would be SP + 8.  */
+  this_id = frame_id_build (sp + 8, frame_pc_unwind (next_frame));
+  trad_frame_set_id (cache, this_id);
+
+  info = bfin_linux_get_sigtramp_info (next_frame);
+
+  for (i = 0; i < BFIN_NUM_REGS; i++)
+    if (info.sc_reg_offset[i] != -1)
+      trad_frame_set_reg_addr (cache, i,
+			       info.context_addr + info.sc_reg_offset[i]);
+
+  *this_cache = cache;
+  return cache;
+}
+
+static void
+bfin_linux_sigtramp_frame_this_id (struct frame_info *next_frame,
+				   void **this_cache,
+				   struct frame_id *this_id)
+{
+  struct trad_frame_cache *cache;
+
+  cache = bfin_linux_sigtramp_frame_cache (next_frame, this_cache);
+  trad_frame_get_id (cache, this_id);
+}
+
+static void
+bfin_linux_sigtramp_frame_prev_register (struct frame_info *next_frame,
+					 void **this_cache,
+					 int regnum,
+					 int *optimizedp,
+					 enum lval_type *lvalp,
+					 CORE_ADDR *addrp,
+					 int *realnump,
+					 gdb_byte *valuep)
+{
+  struct trad_frame_cache *cache;
+
+  cache = bfin_linux_sigtramp_frame_cache (next_frame, this_cache);
+  trad_frame_get_register (cache, next_frame, regnum, optimizedp, lvalp,
+			   addrp, realnump, valuep);
+}
+
+static const struct frame_unwind bfin_linux_sigtramp_frame_unwind =
+{
+  SIGTRAMP_FRAME,
+  bfin_linux_sigtramp_frame_this_id,
+  bfin_linux_sigtramp_frame_prev_register
+};
+
+static const struct frame_unwind *
+bfin_linux_sigtramp_frame_sniffer (struct frame_info *next_frame)
+{
+  CORE_ADDR pc = frame_pc_unwind (next_frame);
+
+  if (bfin_linux_pc_in_sigtramp (next_frame, pc))
+    return &bfin_linux_sigtramp_frame_unwind;
+
+  return NULL;
+}
+
+struct bfin_frame_cache
+{
+  /* Base address.  */
+  CORE_ADDR base;
+  CORE_ADDR sp_offset;
+  CORE_ADDR pc;
+  int frameless_pc_value;
+
+  /* Saved registers.  */
+  CORE_ADDR saved_regs[BFIN_NUM_REGS];
+  CORE_ADDR saved_sp;
+
+  /* Stack space reserved for local variables.  */
+  long locals;
+};
+
+/* Allocate and initialize a frame cache.  */
+
+static struct bfin_frame_cache *
+bfin_alloc_frame_cache (void)
+{
+  struct bfin_frame_cache *cache;
+  int i;
+
+  cache = FRAME_OBSTACK_ZALLOC (struct bfin_frame_cache);
+
+  /* Base address.  */
+  cache->base = 0;
+  cache->sp_offset = -4;
+  cache->pc = 0;
+  cache->frameless_pc_value = 0;
+
+  /* Saved registers.  We initialize these to -1 since zero is a valid
+     offset (that's where fp is supposed to be stored).  */
+  for (i = 0; i < BFIN_NUM_REGS; i++)
+    cache->saved_regs[i] = -1;
+
+  /* Frameless until proven otherwise.  */
+  cache->locals = -1;
+
+  return cache;
+}
+
+static struct bfin_frame_cache *
+bfin_frame_cache (struct frame_info *next_frame, void **this_cache)
+{
+  struct bfin_frame_cache *cache;
+  int i;
+
+  if (*this_cache)
+    return *this_cache;
+
+  cache = bfin_alloc_frame_cache ();
+  *this_cache = cache;
+
+  cache->base = frame_unwind_register_unsigned (next_frame, BFIN_FP_REGNUM);
+  if (cache->base == 0)
+    return cache;
+
+  /* For normal frames, PC is stored at [FP + 4].  */
+  cache->saved_regs[BFIN_PC_REGNUM] = 4;
+  cache->saved_regs[BFIN_FP_REGNUM] = 0;
+
+  /* Adjust all the saved registers such that they contain addresses
+     instead of offsets.  */
+  for (i = 0; i < BFIN_NUM_REGS; i++)
+    if (cache->saved_regs[i] != -1)
+      cache->saved_regs[i] += cache->base;
+
+  cache->pc = frame_func_unwind (next_frame) ;
+  if (cache->pc == 0 || cache->pc == frame_pc_unwind (next_frame))
+    {
+      /* Either there is no prologue (frameless function) or we are at
+	 the start of a function. In short we do not have a frame.
+	 PC is stored in rets register. FP points to previous frame.  */
+
+      cache->saved_regs[BFIN_PC_REGNUM] = read_register (BFIN_RETS_REGNUM);
+      cache->frameless_pc_value = 1;
+      cache->base = frame_unwind_register_unsigned (next_frame, BFIN_FP_REGNUM);
+#ifdef _DEBUG
+      fprintf (stderr, "frameless pc case base %x\n", cache->base);
+#endif
+      cache->saved_regs[BFIN_FP_REGNUM] = cache->base;
+      cache->saved_sp = cache->base;
+    }
+  else
+    {
+      cache->frameless_pc_value = 0;
+
+      /* Now that we have the base address for the stack frame we can
+	 calculate the value of SP in the calling frame.  */
+      cache->saved_sp = cache->base + 8;
+    }
+
+  return cache;
+}
+
+static void
+bfin_frame_this_id (struct frame_info *next_frame,
+		    void **this_cache,
+		    struct frame_id *this_id)
+{
+  struct bfin_frame_cache *cache = bfin_frame_cache (next_frame, this_cache);
+
+  /* This marks the outermost frame.  */
+  if (cache->base == 0)
+    return;
+
+  /* See the end of bfin_push_dummy_call.  */
+  *this_id = frame_id_build (cache->base + 8, cache->pc);
+}
+
+static void
+bfin_frame_prev_register (struct frame_info *next_frame,
+			  void **this_cache,
+			  int regnum,
+			  int *optimizedp,
+			  enum lval_type *lvalp,
+			  CORE_ADDR *addrp,
+			  int *realnump,
+			  gdb_byte *valuep)
+{
+  struct bfin_frame_cache *cache = bfin_frame_cache (next_frame, this_cache);
+
+  gdb_assert (regnum >= 0);
+
+  if (regnum == BFIN_SP_REGNUM && cache->saved_sp)
+    {
+      *optimizedp = 0;
+      *lvalp = not_lval;
+      *addrp = 0;
+      *realnump = -1;
+
+      if (valuep)
+	{
+	  /* Store the value.  */
+	  store_unsigned_integer (valuep, 4, cache->saved_sp);
+	}
+
+      return;
+    }
+
+  if (regnum < BFIN_NUM_REGS && cache->saved_regs[regnum] != -1)
+    {
+      *optimizedp = 0;
+      *lvalp = lval_memory;
+      *addrp = cache->saved_regs[regnum];
+      *realnump = -1;
+
+      if (valuep)
+	{
+	  /* Read the value in from memory.  */
+
+	  if (regnum == BFIN_PC_REGNUM)
+	    {
+	      int *pi = (int *) valuep;
+
+	      if (cache->frameless_pc_value)
+		{
+		  /* Blackfin stores the value of the return pc on
+		     a register not a stack. A LINK command will
+		     save it on the stack.  */
+		  store_unsigned_integer (valuep, 4, *addrp);
+		}
+	      else
+		store_unsigned_integer (valuep, 4,
+				read_memory_unsigned_integer (*addrp, 4));
+	    }
+	  else if (regnum == BFIN_FP_REGNUM)
+	    {
+	      int *pi = (int *) valuep;
+
+	      if (cache->frameless_pc_value)
+		{
+		  /* Blackfin stores the value of the return pc on
+		     a register not a stack. A LINK command will
+		     save it on the stack.  */
+#ifdef _DEBUG
+		  fprintf (stderr, "returning frameless %x\n", *addrp);
+#endif
+		  store_unsigned_integer (valuep, 4, *addrp);
+		}
+	      else
+		store_unsigned_integer (valuep, 4,
+				read_memory_unsigned_integer (*addrp, 4));
+	    }
+	  else
+	    read_memory (*addrp, valuep,
+			 register_size (current_gdbarch, regnum));
+	}
+      return;
+    }
+
+  frame_register_unwind (next_frame, regnum,
+			 optimizedp, lvalp, addrp, realnump, valuep);
+}
+
+CORE_ADDR
+bfin_frame_chain (struct frame_info *frame_ptr)
+{
+  return read_memory_unsigned_integer (get_frame_base (frame_ptr), 4);
+}
+
+static const struct frame_unwind bfin_frame_unwind =
+{
+  NORMAL_FRAME,
+  bfin_frame_this_id,
+  bfin_frame_prev_register
+};
+
+static const struct frame_unwind *
+bfin_frame_sniffer (struct frame_info *next_frame)
+{
+  return &bfin_frame_unwind;
+}
+
+/* The following functions are for function prologue length calculations.  */
+
+static int
+is_minus_minus_sp (int op)
+{
+  op &= 0xFFC0;
+
+  if ((op == P_MINUS_SP1) || (op == P_MINUS_SP2)
+      || (op == P_MINUS_SP3) || (op == P_MINUS_SP4))
+    return 1;
+
+  return 0;
+}
+
+CORE_ADDR
+bfin_skip_prologue (CORE_ADDR pc)
+{
+  int op = read_memory_unsigned_integer (pc, 2);
+  CORE_ADDR orig_pc = pc;
+  int done = 0;
+
+  /* The new gcc prologue generates the register saves BEFORE the link
+     or RETS saving instruction.
+     So, our job is to stop either at those instructions or some upper
+     limit saying there is no frame!  */
+
+  while (!done)
+    {
+      if (is_minus_minus_sp (op))
+	{
+	  while (is_minus_minus_sp (op))
+	    {
+	      pc += 2;
+	      op = read_memory_unsigned_integer (pc, 2);
+	    }
+
+	  if (op == P_LINKAGE)
+	    pc += 4;
+
+	  done = 1;
+	}
+      else if (op == P_LINKAGE)
+	{
+	  pc += 4;
+	  done = 1;
+	}
+      else if (op == P_MINUS_MINUS_SP_EQ_RETS)
+	{
+	  pc += 2;
+	  done = 1;
+	}
+      else if (op == P_RTS)
+	{
+	  done = 1;
+	}
+      else if ((op >= P_JUMP_PREG_MIN && op <= P_JUMP_PREG_MAX)
+	       || (op >= P_JUMP_PC_PLUS_PREG_MIN
+		   && op <= P_JUMP_PC_PLUS_PREG_MAX)
+	       || (op == P_JUMP_S_MIN && op <= P_JUMP_S_MAX))
+	{
+	  done = 1;
+	}
+      else if (pc - orig_pc >= UPPER_LIMIT)
+	{
+	  fprintf (stderr, "Function Prologue not recognised. pc will point to ENTRY_POINT of the function\n");
+	  pc = orig_pc + 2;
+	  done = 1;
+	}
+      else
+	{
+	  pc += 2; /* Not a terminating instruction go on.  */
+	  op = read_memory_unsigned_integer (pc, 2);
+	}
+    }
+
+   /* TODO:
+      Dwarf2 uses entry point value AFTER some register initializations.
+      We should perhaps skip such asssignments as well (R6 = R1, ...).  */
+
+  return pc;
+}
+
+/* Return the GDB type object for the "standard" data type of data in
+   register N.  This should be void pointer for P0-P5, SP, FP;
+   void pointer to function for PC; int otherwise.  */
+
+static struct type *
+bfin_register_type (struct gdbarch *gdbarch, int regnum)
+{
+  if ((regnum >= BFIN_P0_REGNUM && regnum <= BFIN_FP_REGNUM)
+      || regnum == BFIN_USP_REGNUM)
+    return builtin_type_void_data_ptr;
+
+  if (regnum == BFIN_PC_REGNUM || regnum == BFIN_RETS_REGNUM)
+    return builtin_type_void_func_ptr;
+
+  return builtin_type_int32;
+}
+
+/* Return the saved PC from this frame.
+   Assumes LINK is used in every function.  */
+
+CORE_ADDR
+bfin_frame_saved_pc (struct frame_info *frame)
+{
+  return read_memory_unsigned_integer (get_frame_base (frame) + RETS_OFFSET, 4);
+}
+
+static CORE_ADDR
+find_func_descr (struct gdbarch *gdbarch, CORE_ADDR entry_point)
+{
+  CORE_ADDR descr;
+  char valbuf[4];
+
+  descr = bfin_fdpic_find_canonical_descriptor (entry_point);
+
+  if (descr != 0)
+    return descr;
+
+  /* Construct a non-canonical descriptor from space allocated on
+     the stack.  */
+
+  descr = value_as_long (value_allocate_space_in_inferior (8));
+  store_unsigned_integer (valbuf, 4, entry_point);
+  write_memory (descr, valbuf, 4);
+  store_unsigned_integer (valbuf, 4,
+                          bfin_fdpic_find_global_pointer (entry_point));
+  write_memory (descr + 4, valbuf, 4);
+  return descr;
+}
+
+static CORE_ADDR
+bfin_convert_from_func_ptr_addr (struct gdbarch *gdbarch, CORE_ADDR addr,
+				 struct target_ops *targ)
+{
+  CORE_ADDR entry_point;
+  CORE_ADDR got_address;
+
+  entry_point = get_target_memory_unsigned (targ, addr, 4);
+  got_address = get_target_memory_unsigned (targ, addr + 4, 4);
+
+  if (got_address == bfin_fdpic_find_global_pointer (entry_point))
+    return entry_point;
+  else
+    return addr;
+}
+
+/* We currently only support passing parameters in integer registers.  This
+   conforms with GCC's default model.  Several other variants exist and
+   we should probably support some of them based on the selected ABI.  */
+
+static CORE_ADDR
+bfin_push_dummy_call (struct gdbarch *gdbarch,
+		      struct value * function,
+		      struct regcache *regcache,
+		      CORE_ADDR bp_addr,
+		      int nargs,
+		      struct value **args,
+		      CORE_ADDR sp,
+		      int struct_return,
+		      CORE_ADDR struct_addr)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  char buf[4];
+  int i;
+  long reg_r0, reg_r1, reg_r2;
+  int total_len = 0;
+  enum bfin_abi abi = bfin_abi (gdbarch);
+  CORE_ADDR func_addr = find_function_addr (function, NULL);
+
+  for (i = nargs - 1; i >= 0; i--)
+    {
+      struct type *value_type = value_enclosing_type (args[i]);
+      int len = TYPE_LENGTH (value_type);
+      total_len += (len + 3) & ~3;
+    }
+
+  /* At least twelve bytes of stack space must be allocated for the function's
+     arguments, even for functions that have less than 12 bytes of argument
+     data.  */
+
+  if (total_len < 12)
+    sp -= 12 - total_len;
+
+  /* Push arguments in reverse order.  */
+
+  for (i = nargs - 1; i >= 0; i--)
+    {
+      struct type *value_type = value_enclosing_type (args[i]);
+      struct type *arg_type = check_typedef (value_type);
+      int len = TYPE_LENGTH (value_type);
+      int container_len = (len + 3) & ~3;
+      sp -= container_len;
+
+      if (abi == BFIN_ABI_FDPIC
+	  && len == 4
+	  && TYPE_CODE (arg_type) == TYPE_CODE_PTR
+	  && TYPE_CODE (TYPE_TARGET_TYPE (arg_type)) == TYPE_CODE_FUNC)
+	{
+	  CORE_ADDR descr;
+
+	  /* The FDPIC ABI requires function descriptors to be passed instead
+	     of entry points.  */
+	  descr = extract_unsigned_integer (value_contents (args[i]), 4);
+	  descr = find_func_descr (gdbarch, descr);
+	  write_memory_unsigned_integer (sp, 4, descr);
+	}
+      else
+	write_memory (sp, value_contents_writeable (args[i]), container_len);
+    }
+
+  /* initialize R0, R1 and R2 to the first 3 words of paramters */
+
+  reg_r0 = read_memory_integer (sp, 4);
+  regcache_cooked_write_unsigned (regcache, BFIN_R0_REGNUM, reg_r0);
+  reg_r1 = read_memory_integer (sp + 4, 4);
+  regcache_cooked_write_unsigned (regcache, BFIN_R1_REGNUM, reg_r1);
+  reg_r2 = read_memory_integer (sp + 8, 4);
+  regcache_cooked_write_unsigned (regcache, BFIN_R2_REGNUM, reg_r2);
+
+  /* Store struct value address.  */
+
+  if (struct_return)
+    regcache_cooked_write_unsigned (regcache, BFIN_P0_REGNUM, struct_addr);
+
+  /* Set the dummy return value to bp_addr.
+     A dummy breakpoint will be setup to execute the call.  */
+
+  regcache_cooked_write_unsigned (regcache, BFIN_RETS_REGNUM, bp_addr);
+
+  /* Finally, update the stack pointer.  */
+
+  regcache_cooked_write_unsigned (regcache, BFIN_SP_REGNUM, sp);
+
+  return sp;
+}
+
+/* Convert DWARF2 register number REG to the appropriate register number
+   used by GDB.  */
+
+static int
+bfin_reg_to_regnum (int reg)
+{
+  if (reg > sizeof (map_gcc_gdb) / sizeof (int))
+    return 0;
+
+  return map_gcc_gdb[reg];
+}
+
+static int
+gdb_print_insn_bfin (bfd_vma memaddr, disassemble_info *info)
+{
+  return print_insn_bfin (memaddr, info);
+}
+
+/* This function implements the BREAKPOINT_FROM_PC macro. It returns
+   a pointer to a string of bytes that encode a breakpoint instruction,
+   stores the length of the string to *lenptr, and adjusts the program
+   counter (if necessary) to point to the actual memory location where
+   the breakpoint should be inserted.  */
+
+const unsigned char *
+bfin_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
+{
+  static unsigned char bfin_breakpoint[] = {0xa1, 0x00};
+  *lenptr = sizeof (bfin_breakpoint);
+  return bfin_breakpoint;
+}
+
+static void
+bfin_extract_return_value (struct type *type,
+			   struct regcache *regs,
+			   gdb_byte *dst)
+{
+  bfd_byte *valbuf = dst;
+  int len = TYPE_LENGTH (type);
+  ULONGEST tmp;
+  int regno = BFIN_R0_REGNUM;
+
+  gdb_assert (len <= 8);
+
+  while (len > 0)
+    {
+      regcache_cooked_read_unsigned (regs, regno++, &tmp);
+      store_unsigned_integer (valbuf, (len > 4 ? 4 : len), tmp);
+      len -= 4;
+      valbuf += 4;
+    }
+}
+
+/* Write into appropriate registers a function return value of type
+   TYPE, given in virtual format.  */
+
+static void
+bfin_store_return_value (struct type *type,
+			 struct regcache *regs,
+			 const gdb_byte *src)
+{
+  const bfd_byte *valbuf = src;
+
+  /* Integral values greater than one word are stored in consecutive
+     registers starting with R0.  This will always be a multiple of
+     the register size.  */
+
+  int len = TYPE_LENGTH (type);
+  int regno = BFIN_R0_REGNUM;
+
+  gdb_assert (len <= 8);
+
+  while (len > 0)
+    {
+      regcache_cooked_write (regs, regno++, valbuf);
+      len -= 4;
+      valbuf += 4;
+    }
+}
+
+/* Determine, for architecture GDBARCH, how a return value of TYPE
+   should be returned.  If it is supposed to be returned in registers,
+   and READBUF is non-zero, read the appropriate value from REGCACHE,
+   and copy it into READBUF.  If WRITEBUF is non-zero, write the value
+   from WRITEBUF into REGCACHE.  */
+
+static enum return_value_convention
+bfin_return_value (struct gdbarch *gdbarch,
+		   struct type *type,
+		   struct regcache *regcache,
+		   gdb_byte *readbuf,
+		   const gdb_byte *writebuf)
+{
+  if (TYPE_LENGTH (type) > 8)
+    return RETURN_VALUE_STRUCT_CONVENTION;
+
+  if (readbuf)
+    bfin_extract_return_value (type, regcache, readbuf);
+
+  if (writebuf)
+    bfin_store_return_value (type, regcache, writebuf);
+
+  return RETURN_VALUE_REGISTER_CONVENTION;
+}
+
+/* Return the BFIN register name corresponding to register I.  */
+
+static const char *
+bfin_register_name (int i)
+{
+  return bfin_register_name_strings[i];
+}
+
+static CORE_ADDR
+bfin_frame_base_address (struct frame_info *next_frame, void **this_cache)
+{
+  struct bfin_frame_cache *cache = bfin_frame_cache (next_frame, this_cache);
+
+  return cache->base;
+}
+
+static CORE_ADDR
+bfin_frame_local_address (struct frame_info *next_frame, void **this_cache)
+{
+  struct bfin_frame_cache *cache = bfin_frame_cache (next_frame, this_cache);
+
+  return cache->base - 4;
+}
+
+static CORE_ADDR
+bfin_frame_args_address (struct frame_info *next_frame, void **this_cache)
+{
+  struct bfin_frame_cache *cache = bfin_frame_cache (next_frame, this_cache);
+
+  return cache->base + 8;
+}
+
+static const struct frame_base bfin_frame_base =
+{
+  &bfin_frame_unwind,
+  bfin_frame_base_address,
+  bfin_frame_local_address,
+  bfin_frame_args_address
+};
+
+static struct frame_id
+bfin_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+  CORE_ADDR sp;
+
+  sp = frame_unwind_register_unsigned (next_frame, BFIN_SP_REGNUM);
+
+  return frame_id_build (sp, frame_pc_unwind (next_frame));
+}
+
+static CORE_ADDR
+bfin_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+  return frame_unwind_register_unsigned (next_frame, PC_REGNUM);
+}
+
+static int
+bfin_sim_regno (int regno)
+{
+  switch (regno)
+    {
+    case SIM_BFIN_ASTAT_REGNUM:
+    case SIM_BFIN_CYCLES_REGNUM:
+    case SIM_BFIN_CYCLES2_REGNUM:
+    case SIM_BFIN_USP_REGNUM:
+    case SIM_BFIN_SEQSTAT_REGNUM:
+    case SIM_BFIN_SYSCFG_REGNUM:
+    case SIM_BFIN_RETI_REGNUM:
+    case SIM_BFIN_RETX_REGNUM:
+    case SIM_BFIN_RETN_REGNUM:
+    case SIM_BFIN_RETE_REGNUM:
+    case SIM_BFIN_EXTRA1:
+    case SIM_BFIN_EXTRA2:
+    case SIM_BFIN_EXTRA3:
+    case SIM_BFIN_IPEND_REGNUM:
+      return SIM_REGNO_DOES_NOT_EXIST;
+    default:
+      return regno;
+    }
+}
+
+CORE_ADDR
+bfin_frame_align (struct gdbarch *gdbarch, CORE_ADDR address)
+{
+  return (address & ~0x3);
+}
+
+/* Fetch the interpreter and executable loadmap addresses (for shared
+   library support) for the FDPIC ABI.  Return 0 if successful, -1 if
+   not.  (E.g, -1 will be returned if the ABI isn't the FDPIC ABI.)  */
+int
+bfin_fdpic_loadmap_addresses (struct gdbarch *gdbarch, CORE_ADDR *interp_addr,
+			      CORE_ADDR *exec_addr)
+{
+  if (bfin_abi (gdbarch) != BFIN_ABI_FDPIC)
+    return -1;
+  else
+    {
+      if (interp_addr != NULL)
+	{
+	  ULONGEST val;
+	  regcache_cooked_read_unsigned (current_regcache,
+					 BFIN_FDPIC_INTERP_REGNUM, &val);
+	  *interp_addr = val;
+	}
+      if (exec_addr != NULL)
+	{
+	  ULONGEST val;
+	  regcache_cooked_read_unsigned (current_regcache,
+					BFIN_FDPIC_EXEC_REGNUM, &val);
+	  *exec_addr = val;
+	}
+      return 0;
+    }
+}
+
+/* Initialize the current architecture based on INFO.  If possible,
+   re-use an architecture from ARCHES, which is a list of
+   architectures already created during this debugging session.
+
+   Called e.g. at program startup, when reading a core file, and when
+   reading a binary file.  */
+
+static struct gdbarch *
+bfin_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
+{
+  struct gdbarch_tdep *tdep;
+  struct gdbarch *gdbarch;
+  int elf_flags;
+  enum bfin_abi abi;
+
+  /* Extract the ELF flags, if available.  */
+  if (info.abfd && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)
+    elf_flags = elf_elfheader (info.abfd)->e_flags;
+  else
+    elf_flags = 0;
+
+  if (elf_flags & EF_BFIN_FDPIC)
+    abi = BFIN_ABI_FDPIC;
+  else
+    abi = BFIN_ABI_FLAT;
+
+  /* If there is already a candidate, use it.  */
+
+  for (arches = gdbarch_list_lookup_by_info (arches, &info);
+       arches != NULL;
+       arches = gdbarch_list_lookup_by_info (arches->next, &info))
+    {
+      if (gdbarch_tdep (arches->gdbarch)->bfin_abi != abi)
+	continue;
+      return arches->gdbarch;
+    }
+
+  tdep = XMALLOC (struct gdbarch_tdep);
+  gdbarch = gdbarch_alloc (&info, tdep);
+
+  tdep->bfin_abi = abi;
+
+  set_gdbarch_num_regs (gdbarch, BFIN_NUM_REGS);
+  set_gdbarch_num_pseudo_regs (gdbarch, 0);
+  set_gdbarch_sp_regnum (gdbarch, BFIN_SP_REGNUM);
+  set_gdbarch_pc_regnum (gdbarch, BFIN_PC_REGNUM);
+  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, bfin_reg_to_regnum);
+  set_gdbarch_register_name (gdbarch, bfin_register_name);
+  set_gdbarch_register_type (gdbarch, bfin_register_type);
+  set_gdbarch_unwind_dummy_id (gdbarch, bfin_unwind_dummy_id);
+  set_gdbarch_push_dummy_call (gdbarch, bfin_push_dummy_call);
+  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
+  set_gdbarch_register_sim_regno (gdbarch, bfin_sim_regno);
+  set_gdbarch_believe_pcc_promotion (gdbarch, 1);
+  set_gdbarch_return_value (gdbarch, bfin_return_value);
+  set_gdbarch_extract_return_value (gdbarch, bfin_extract_return_value);
+  set_gdbarch_store_return_value (gdbarch, bfin_store_return_value);
+  set_gdbarch_skip_prologue (gdbarch, bfin_skip_prologue);
+  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
+  set_gdbarch_breakpoint_from_pc (gdbarch, bfin_breakpoint_from_pc);
+  set_gdbarch_decr_pc_after_break (gdbarch, 0);
+  set_gdbarch_frame_args_skip (gdbarch, 8);
+  set_gdbarch_unwind_pc (gdbarch, bfin_unwind_pc);
+  set_gdbarch_frame_align (gdbarch, bfin_frame_align);
+  set_gdbarch_print_insn (gdbarch, gdb_print_insn_bfin);
+
+  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
+
+  frame_base_set_default (gdbarch, &bfin_frame_base);
+
+  frame_unwind_append_sniffer (gdbarch, bfin_linux_sigtramp_frame_sniffer);
+  frame_unwind_append_sniffer (gdbarch, bfin_frame_sniffer);
+
+
+  if (bfin_abi (gdbarch) == BFIN_ABI_FDPIC)
+    set_gdbarch_convert_from_func_ptr_addr (gdbarch,
+					    bfin_convert_from_func_ptr_addr);
+
+  if (bfin_abi (gdbarch) == BFIN_ABI_FDPIC)
+    set_gdbarch_use_get_offsets (gdbarch, 0);
+
+  return gdbarch;
+}
+
+static void
+bfin_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+
+  if (tdep == NULL)
+    return;
+}
+
+extern initialize_file_ftype _initialize_bfin_tdep; /* -Wmissing-prototypes */
+
+void
+_initialize_bfin_tdep (void)
+{
+  gdbarch_register (bfd_arch_bfin, bfin_gdbarch_init, bfin_dump_tdep);
+}
diff -Naur gdb-6.5.orig/gdb/bfin-tdep.h gdb-6.5/gdb/bfin-tdep.h
--- gdb-6.5.orig/gdb/bfin-tdep.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/gdb/bfin-tdep.h	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,180 @@
+/* Target-dependent code for Analog Devices Blackfin processer, for GDB.
+
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Analog Devices.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+enum gdb_regnum {
+  /* Core Registers */
+  BFIN_R0_REGNUM = 0,
+  BFIN_R1_REGNUM,
+  BFIN_R2_REGNUM,
+  BFIN_R3_REGNUM,
+  BFIN_R4_REGNUM,
+  BFIN_R5_REGNUM,
+  BFIN_R6_REGNUM,
+  BFIN_R7_REGNUM,
+  BFIN_P0_REGNUM,
+  BFIN_P1_REGNUM,
+  BFIN_P2_REGNUM,
+  BFIN_P3_REGNUM,
+  BFIN_P4_REGNUM,
+  BFIN_P5_REGNUM,
+  BFIN_SP_REGNUM,
+  BFIN_FP_REGNUM,
+  BFIN_I0_REGNUM,
+  BFIN_I1_REGNUM,
+  BFIN_I2_REGNUM,
+  BFIN_I3_REGNUM,
+  BFIN_M0_REGNUM,
+  BFIN_M1_REGNUM,
+  BFIN_M2_REGNUM,
+  BFIN_M3_REGNUM,
+  BFIN_B0_REGNUM,
+  BFIN_B1_REGNUM,
+  BFIN_B2_REGNUM,
+  BFIN_B3_REGNUM,
+  BFIN_L0_REGNUM,
+  BFIN_L1_REGNUM,
+  BFIN_L2_REGNUM,
+  BFIN_L3_REGNUM,
+  BFIN_A0_DOT_X_REGNUM,
+  BFIN_AO_DOT_W_REGNUM,
+  BFIN_A1_DOT_X_REGNUM,
+  BFIN_A1_DOT_W_REGNUM,
+  BFIN_ASTAT_REGNUM,
+  BFIN_RETS_REGNUM,
+  BFIN_LC0_REGNUM,
+  BFIN_LT0_REGNUM,
+  BFIN_LB0_REGNUM,
+  BFIN_LC1_REGNUM,
+  BFIN_LT1_REGNUM,
+  BFIN_LB1_REGNUM,
+  BFIN_CYCLES_REGNUM,
+  BFIN_CYCLES2_REGNUM,
+  BFIN_USP_REGNUM,
+  BFIN_SEQSTAT_REGNUM,
+  BFIN_SYSCFG_REGNUM,
+  BFIN_RETI_REGNUM,
+  BFIN_RETX_REGNUM,
+  BFIN_RETN_REGNUM,
+  BFIN_RETE_REGNUM,
+
+  /* Pseudo Registers */
+  BFIN_PC_REGNUM,
+  BFIN_CC_REGNUM,
+  BFIN_EXTRA1,		/* Address of .text section.  */
+  BFIN_EXTRA2,		/* Address of .data section.  */
+  BFIN_EXTRA3,		/* Address of .bss section.  */
+
+  BFIN_FDPIC_EXEC_REGNUM,
+  BFIN_FDPIC_INTERP_REGNUM,
+
+  /* MMRs */
+  BFIN_IPEND_REGNUM,
+
+  /* LAST ENTRY SHOULD NOT BE CHANGED.  */
+  BFIN_NUM_REGS		/* The number of all registers.  */
+};
+
+enum gcc_regnum {
+  BFIN_GCC_R0_REGNUM = 0,
+  BFIN_GCC_R1_REGNUM,
+  BFIN_GCC_R2_REGNUM,
+  BFIN_GCC_R3_REGNUM,
+  BFIN_GCC_R4_REGNUM,
+  BFIN_GCC_R5_REGNUM,
+  BFIN_GCC_R6_REGNUM,
+  BFIN_GCC_R7_REGNUM,
+  BFIN_GCC_P0_REGNUM,
+  BFIN_GCC_P1_REGNUM,
+  BFIN_GCC_P2_REGNUM,
+  BFIN_GCC_P3_REGNUM,
+  BFIN_GCC_P4_REGNUM,
+  BFIN_GCC_P5_REGNUM,
+  BFIN_GCC_SP_REGNUM,
+  BFIN_GCC_FP_REGNUM,
+  BFIN_GCC_I0_REGNUM,
+  BFIN_GCC_I1_REGNUM,
+  BFIN_GCC_I2_REGNUM,
+  BFIN_GCC_I3_REGNUM,
+  BFIN_GCC_B0_REGNUM,
+  BFIN_GCC_B1_REGNUM,
+  BFIN_GCC_B2_REGNUM,
+  BFIN_GCC_B3_REGNUM,
+  BFIN_GCC_L0_REGNUM,
+  BFIN_GCC_L1_REGNUM,
+  BFIN_GCC_L2_REGNUM,
+  BFIN_GCC_L3_REGNUM,
+  BFIN_GCC_M0_REGNUM,
+  BFIN_GCC_M1_REGNUM,
+  BFIN_GCC_M2_REGNUM,
+  BFIN_GCC_M3_REGNUM,
+  BFIN_GCC_A0_REGNUM,
+  BFIN_GCC_A1_REGNUM,
+  BFIN_GCC_CC_REGNUM,
+  BFIN_GCC_RETS_REGNUM,
+  BFIN_GCC_RETI_REGNUM,
+  BFIN_GCC_RETX_REGNUM,
+  BFIN_GCC_RETN_REGNUM,
+  BFIN_GCC_RETE_REGNUM,
+  BFIN_GCC_ASTAT_REGNUM,
+  BFIN_GCC_SEQSTAT_REGNUM,
+  BFIN_GCC_USP_REGNUM,
+  BFIN_GCC_ARGP_REGNUM,
+  BFIN_GCC_LT0_REGNUM,
+  BFIN_GCC_LT1_REGNUM,
+  BFIN_GCC_LC0_REGNUM,
+  BFIN_GCC_LC1_REGNUM,
+  BFIN_GCC_LB0_REGNUM,
+  BFIN_GCC_LB1_REGNUM
+};
+
+/* The ABIs for Blackfin.  */
+enum bfin_abi
+{
+  BFIN_ABI_FLAT,
+  BFIN_ABI_FDPIC
+};
+
+/* Target-dependent structure in gdbarch.  */
+struct gdbarch_tdep
+{
+  /* Which ABI is in use?  */
+  enum bfin_abi bfin_abi;
+};
+
+/* in opcodes/bfin-dis.c */
+extern int print_insn_bfin (bfd_vma pc, struct disassemble_info *outf);
+
+/* Fetch the interpreter and executable loadmap addresses (for shared
+   library support) for the FDPIC ABI.  Return 0 if successful, -1 if
+   not.  (E.g, -1 will be returned if the ABI isn't the FDPIC ABI.)  */
+extern int bfin_fdpic_loadmap_addresses (struct gdbarch *gdbarch,
+					 CORE_ADDR *interp_addr,
+					 CORE_ADDR *exec_addr);
+
+/* Given a function entry point, find and return the GOT address for the
+   containing load module.  */
+CORE_ADDR bfin_fdpic_find_global_pointer (CORE_ADDR addr);
+
+/* Given a function entry point, find and return the canonical descriptor
+   for that function, if one exists.  If no canonical descriptor could
+   be found, return 0.  */
+CORE_ADDR bfin_fdpic_find_canonical_descriptor (CORE_ADDR entry_point);
diff -Naur gdb-6.5.orig/gdb/config/bfin/bfin.mt gdb-6.5/gdb/config/bfin/bfin.mt
--- gdb-6.5.orig/gdb/config/bfin/bfin.mt	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/gdb/config/bfin/bfin.mt	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,4 @@
+TDEPFILES= bfin-tdep.o solib.o solib-bfin.o
+DEPRECATED_TM_FILE= solib.h
+SIM_OBS= remote-sim.o
+SIM= ../sim/bfin/libsim.a
diff -Naur gdb-6.5.orig/gdb/configure.tgt gdb-6.5/gdb/configure.tgt
--- gdb-6.5.orig/gdb/configure.tgt	2006-04-21 01:18:48.000000000 +0200
+++ gdb-6.5/gdb/configure.tgt	2009-01-22 08:19:21.000000000 +0100
@@ -14,6 +14,7 @@
 am33_2.0*)              gdb_target_cpu=mn10300 ;;
 arm*)			gdb_target_cpu=arm ;;
 avr*)			gdb_target_cpu=avr ;;
+bfin*)			gdb_target_cpu=bfin ;;
 hppa*)			gdb_target_cpu=pa ;;
 i[34567]86*)		gdb_target_cpu=i386 ;;
 m68hc11*|m6811*)	gdb_target_cpu=m68hc11 ;;
@@ -69,6 +70,9 @@
 
 avr-*-*)		gdb_target=avr ;;
 
+bfin-*-*)		gdb_target=bfin
+			build_gdbserver=yes
+			;;
 cris*)                  gdb_target=cris ;;
 
 # OBSOLETE d10v-*-*)		gdb_target=d10v ;;
diff -Naur gdb-6.5.orig/gdb/gdbarch.c gdb-6.5/gdb/gdbarch.c
--- gdb-6.5.orig/gdb/gdbarch.c	2006-04-18 21:20:06.000000000 +0200
+++ gdb-6.5/gdb/gdbarch.c	2009-01-22 08:19:21.000000000 +0100
@@ -235,6 +235,7 @@
   gdbarch_register_reggroup_p_ftype *register_reggroup_p;
   gdbarch_fetch_pointer_argument_ftype *fetch_pointer_argument;
   gdbarch_regset_from_core_section_ftype *regset_from_core_section;
+  int use_get_offsets;
 };
 
 
@@ -361,6 +362,7 @@
   default_register_reggroup_p,  /* register_reggroup_p */
   0,  /* fetch_pointer_argument */
   0,  /* regset_from_core_section */
+  1,  /* use_get_offsets */
   /* startup_gdbarch() */
 };
 
@@ -450,6 +452,7 @@
   current_gdbarch->coff_make_msymbol_special = default_coff_make_msymbol_special;
   current_gdbarch->name_of_malloc = "malloc";
   current_gdbarch->register_reggroup_p = default_register_reggroup_p;
+  current_gdbarch->use_get_offsets = 1;
   /* gdbarch_alloc() */
 
   return current_gdbarch;
@@ -615,6 +618,7 @@
   /* Skip verify of register_reggroup_p, invalid_p == 0 */
   /* Skip verify of fetch_pointer_argument, has predicate */
   /* Skip verify of regset_from_core_section, has predicate */
+  /* Skip verify of use_get_offsets, invalid_p == 0 */
   buf = ui_file_xstrdup (log, &dummy);
   make_cleanup (xfree, buf);
   if (strlen (buf) > 0)
@@ -1601,6 +1605,9 @@
   fprintf_unfiltered (file,
                       "gdbarch_dump: unwind_sp = <0x%lx>\n",
                       (long) current_gdbarch->unwind_sp);
+  fprintf_unfiltered (file,
+                      "gdbarch_dump: use_get_offsets = %s\n",
+                      paddr_d (current_gdbarch->use_get_offsets));
 #ifdef VALUE_TO_REGISTER
   fprintf_unfiltered (file,
                       "gdbarch_dump: %s # %s\n",
@@ -3683,6 +3690,23 @@
   gdbarch->regset_from_core_section = regset_from_core_section;
 }
 
+int
+gdbarch_use_get_offsets (struct gdbarch *gdbarch)
+{
+  gdb_assert (gdbarch != NULL);
+  /* Skip verify of use_get_offsets, invalid_p == 0 */
+  if (gdbarch_debug >= 2)
+    fprintf_unfiltered (gdb_stdlog, "gdbarch_use_get_offsets called\n");
+  return gdbarch->use_get_offsets;
+}
+
+void
+set_gdbarch_use_get_offsets (struct gdbarch *gdbarch,
+                             int use_get_offsets)
+{
+  gdbarch->use_get_offsets = use_get_offsets;
+}
+
 
 /* Keep a registry of per-architecture data-pointers required by GDB
    modules. */
diff -Naur gdb-6.5.orig/gdb/gdbarch.h gdb-6.5/gdb/gdbarch.h
--- gdb-6.5.orig/gdb/gdbarch.h	2006-04-18 21:20:06.000000000 +0200
+++ gdb-6.5/gdb/gdbarch.h	2009-01-22 08:19:21.000000000 +0100
@@ -1404,6 +1404,11 @@
 extern const struct regset * gdbarch_regset_from_core_section (struct gdbarch *gdbarch, const char *sect_name, size_t sect_size);
 extern void set_gdbarch_regset_from_core_section (struct gdbarch *gdbarch, gdbarch_regset_from_core_section_ftype *regset_from_core_section);
 
+/* Query the remote side for the text, data and bss offsets */
+
+extern int gdbarch_use_get_offsets (struct gdbarch *gdbarch);
+extern void set_gdbarch_use_get_offsets (struct gdbarch *gdbarch, int use_get_offsets);
+
 extern struct gdbarch_tdep *gdbarch_tdep (struct gdbarch *gdbarch);
 
 
diff -Naur gdb-6.5.orig/gdb/gdbarch.sh gdb-6.5/gdb/gdbarch.sh
--- gdb-6.5.orig/gdb/gdbarch.sh	2006-04-18 21:20:06.000000000 +0200
+++ gdb-6.5/gdb/gdbarch.sh	2009-01-22 08:19:21.000000000 +0100
@@ -662,6 +662,8 @@
 # Return the appropriate register set for a core file section with
 # name SECT_NAME and size SECT_SIZE.
 M::const struct regset *:regset_from_core_section:const char *sect_name, size_t sect_size:sect_name, sect_size
+# Query the remote side for the text, data and bss offsets
+v::int:use_get_offsets:::1:1::0
 EOF
 }
 
diff -Naur gdb-6.5.orig/gdb/gdbserver/configure.srv gdb-6.5/gdb/gdbserver/configure.srv
--- gdb-6.5.orig/gdb/gdbserver/configure.srv	2006-05-09 17:21:19.000000000 +0200
+++ gdb-6.5/gdb/gdbserver/configure.srv	2009-01-22 08:19:21.000000000 +0100
@@ -23,6 +23,11 @@
 			srv_linux_usrregs=yes
 			srv_linux_thread_db=yes
 			;;
+  bfin-*-*)		srv_regobj=reg-bfin.o
+			srv_tgtobj="linux-low.o linux-bfin-low.o"
+			srv_linux_usrregs=yes
+			srv_linux_thread_db=yes
+			;;
   crisv32-*-linux*)	srv_regobj=reg-crisv32.o
 			srv_tgtobj="linux-low.o linux-crisv32-low.o"
 			srv_linux_regsets=yes
diff -Naur gdb-6.5.orig/gdb/gdbserver/linux-bfin-low.c gdb-6.5/gdb/gdbserver/linux-bfin-low.c
--- gdb-6.5.orig/gdb/gdbserver/linux-bfin-low.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/gdb/gdbserver/linux-bfin-low.c	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,101 @@
+/* GNU/Linux/BFIN specific low level interface, for the remote server for GDB.
+
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Analog Devices.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include "server.h"
+#include "linux-low.h"
+#include <asm/asm-offsets.h>
+ 
+static int bfin_regmap[] =
+{
+  PT_R0, PT_R1, PT_R2, PT_R3, PT_R4, PT_R5, PT_R6, PT_R7,
+  PT_P0, PT_P1, PT_P2, PT_P3, PT_P4, PT_P5, PT_USP, PT_FP,
+  PT_I0, PT_I1, PT_I2, PT_I3, PT_M0, PT_M1, PT_M2, PT_M3,
+  PT_B0, PT_B1, PT_B2, PT_B3, PT_L0, PT_L1, PT_L2, PT_L3,
+  PT_A0X, PT_A0W, PT_A1X, PT_A1W, PT_ASTAT, PT_RETS,
+  PT_LC0, PT_LT0, PT_LB0, PT_LC1, PT_LT1, PT_LB1,
+  -1 /* PT_CYCLES */, -1 /* PT_CYCLES2 */,
+  -1 /* PT_USP */, PT_SEQSTAT, PT_SYSCFG, PT_PC, PT_RETX, PT_RETN, PT_RETE,
+  PT_PC, -1 /* PT_CC */, PT_EXTRA1, PT_EXTRA2, PT_EXTRA3,
+  PT_FDPIC_EXEC, PT_FDPIC_INTERP,
+  PT_IPEND
+};
+
+#define bfin_num_regs  (sizeof(bfin_regmap) / sizeof(bfin_regmap[0]))
+
+static int
+bfin_cannot_store_register (int regno)
+{
+  return (regno >= bfin_num_regs);
+}
+
+static int
+bfin_cannot_fetch_register (int regno)
+{
+  return (regno >= bfin_num_regs);
+}
+
+static CORE_ADDR
+bfin_get_pc ()
+{
+  unsigned long pc;
+  collect_register_by_name ("pc", &pc);
+  return pc;
+}
+
+static void
+bfin_set_pc (CORE_ADDR pc)
+{
+  unsigned long newpc = pc;
+  supply_register_by_name ("pc", &newpc);
+}
+
+#define bfin_breakpoint_len 2
+static const unsigned char bfin_breakpoint[bfin_breakpoint_len]={0xa1, 0x00};
+
+static int
+bfin_breakpoint_at (CORE_ADDR where)
+{
+  unsigned char insn[bfin_breakpoint_len];
+
+  read_inferior_memory(where, insn, bfin_breakpoint_len);
+  if (insn[0] == bfin_breakpoint[0]
+      && insn[1] == bfin_breakpoint[1])
+    return 1;
+
+  /* If necessary, recognize more trap instructions here.  GDB only uses the
+     one.  */
+  return 0;
+}
+
+struct linux_target_ops the_low_target = {
+  bfin_num_regs,
+  bfin_regmap,
+  bfin_cannot_fetch_register,
+  bfin_cannot_store_register,
+  bfin_get_pc,
+  bfin_set_pc,
+  bfin_breakpoint,
+  bfin_breakpoint_len,
+  0,
+  0,
+  bfin_breakpoint_at,
+};
diff -Naur gdb-6.5.orig/gdb/gdbserver/Makefile.in gdb-6.5/gdb/gdbserver/Makefile.in
--- gdb-6.5.orig/gdb/gdbserver/Makefile.in	2006-03-15 17:26:02.000000000 +0100
+++ gdb-6.5/gdb/gdbserver/Makefile.in	2009-01-22 08:19:21.000000000 +0100
@@ -119,9 +119,9 @@
 	$(srcdir)/mem-break.c $(srcdir)/proc-service.c $(srcdir)/regcache.c \
 	$(srcdir)/remote-utils.c $(srcdir)/server.c $(srcdir)/target.c \
 	$(srcdir)/thread-db.c $(srcdir)/utils.c \
-	$(srcdir)/linux-arm-low.c $(srcdir)/linux-cris-low.c \
-	$(srcdir)/linux-crisv32-low.c $(srcdir)/linux-i386-low.c \
-	$(srcdir)/i387-fp.c \
+	$(srcdir)/linux-arm-low.c $(srcdir)/linux-bfin-low.c \
+	$(srcdir)/linux-cris-low.c $(srcdir)/linux-crisv32-low.c \
+	$(srcdir)/linux-i386-low.c $(srcdir)/i387-fp.c \
 	$(srcdir)/linux-ia64-low.c $(srcdir)/linux-low.c \
 	$(srcdir)/linux-m32r-low.c \
 	$(srcdir)/linux-m68k-low.c $(srcdir)/linux-mips-low.c \
@@ -206,6 +206,7 @@
 	rm -f reg-arm.c reg-i386.c reg-ia64.c reg-m32r.c reg-m68k.c reg-mips.c
 	rm -f reg-ppc.c reg-sh.c reg-x86-64.c reg-i386-linux.c
 	rm -f reg-cris.c reg-crisv32.c
+	rm -f reg-bfin.c
 
 maintainer-clean realclean distclean: clean
 	rm -f nm.h tm.h xm.h config.status config.h stamp-h config.log
@@ -270,6 +271,7 @@
 	$(CC) -c $(CPPFLAGS) $(INTERNAL_CFLAGS) $< @USE_THREAD_DB@
 
 linux-arm-low.o: linux-arm-low.c $(linux_low_h) $(server_h)
+linux-bfin-low.o: linux-bfin-low.c $(linux_low_h) $(server_h)
 linux-cris-low.o: linux-cris-low.c $(linux_low_h) $(server_h)
 linux-crisv32-low.o: linux-crisv32-low.c $(linux_low_h) $(server_h)
 linux-i386-low.o: linux-i386-low.c $(linux_low_h) $(server_h) \
@@ -288,6 +290,9 @@
 reg-arm.o : reg-arm.c $(regdef_h)
 reg-arm.c : $(srcdir)/../regformats/reg-arm.dat $(regdat_sh)
 	sh $(regdat_sh) $(srcdir)/../regformats/reg-arm.dat reg-arm.c
+reg-bfin.o : reg-bfin.c $(regdef_h)
+reg-bfin.c : $(srcdir)/../regformats/reg-bfin.dat $(regdat_sh)
+	sh $(regdat_sh) $(srcdir)/../regformats/reg-bfin.dat reg-bfin.c
 reg-cris.o : reg-cris.c $(regdef_h)
 reg-cris.c : $(srcdir)/../regformats/reg-cris.dat $(regdat_sh)
 	sh $(regdat_sh) $(srcdir)/../regformats/reg-cris.dat reg-cris.c
diff -Naur gdb-6.5.orig/gdb/Makefile.in gdb-6.5/gdb/Makefile.in
--- gdb-6.5.orig/gdb/Makefile.in	2006-05-12 22:53:15.000000000 +0200
+++ gdb-6.5/gdb/Makefile.in	2009-01-22 08:19:21.000000000 +0100
@@ -581,6 +581,7 @@
 elf_sh_h =	$(INCLUDE_DIR)/elf/sh.h
 elf_arm_h =	$(INCLUDE_DIR)/elf/arm.h $(elf_reloc_macros_h)
 elf_bfd_h =	$(BFD_SRC)/elf-bfd.h
+elf_bfin_h =	$(INCLUDE_DIR)/elf/bfin.h $(elf_reloc_macros_h)
 elf_frv_h =	$(INCLUDE_DIR)/elf/frv.h $(elf_reloc_macros_h)
 elf_m32c_h =    $(INCLUDE_DIR)/elf/m32c.h $(elf_reloc_macros_h)
 libaout_h =	$(BFD_SRC)/libaout.h
@@ -597,6 +598,7 @@
 sh_opc_h = 	$(OPCODES_SRC)/sh-opc.h
 gdb_callback_h = $(INCLUDE_DIR)/gdb/callback.h
 gdb_sim_arm_h =	$(INCLUDE_DIR)/gdb/sim-arm.h
+gdb_sim_bfin_h = $(INCLUDE_DIR)/gdb/sim-bfin.h
 gdb_sim_d10v_h = $(INCLUDE_DIR)/gdb/sim-d10v.h
 gdb_sim_frv_h = $(INCLUDE_DIR)/gdb/sim-frv.h
 gdb_sim_m32c_h = $(INCLUDE_DIR)/gdb/sim-m32c.h
@@ -646,6 +648,7 @@
 ax_h = ax.h $(doublest_h)
 bcache_h = bcache.h
 bfd_target_h = bfd-target.h
+bfin_tdep_h = bfin-tdep.h
 block_h = block.h
 breakpoint_h = breakpoint.h $(frame_h) $(value_h) $(gdb_events_h)
 bsd_kvm_h = bsd-kvm.h
@@ -1401,6 +1404,7 @@
 	arm-linux-nat.c arm-linux-tdep.c arm-tdep.c \
 	armnbsd-nat.c armnbsd-tdep.c \
 	avr-tdep.c \
+	bfin-tdep.c \
 	bsd-uthread.c bsd-kvm.c \
 	coff-solib.c \
 	core-regset.c core-aout.c corelow.c \
@@ -1782,6 +1786,11 @@
 	$(gdb_assert_h)
 bfd-target.o: bfd-target.c $(defs_h) $(target_h) $(bfd_target_h) \
 	$(gdb_assert_h) $(gdb_string_h)
+bfin-tdep.o: bfin-tdep.c $(defs_h) $(frame_h) $(frame_base_h) \
+	$(frame_unwind_h) $(dwarf2_frame_h) $(trad_frame_h) $(inferior_h) \
+	$(gdbcore_h) $(dis_asm_h) $(regcache_h) $(arch_utils_h) \
+	$(gdb_assert_h) $(sim_regno_h) $(bfin_tdep_h) $(gdb_sim_bfin_h) \
+	$(elf_bfd_h) $(elf_bfin_h) $(infcall_h)
 block.o: block.c $(defs_h) $(block_h) $(symtab_h) $(symfile_h) \
 	$(gdb_obstack_h) $(cp_support_h)
 blockframe.o: blockframe.c $(defs_h) $(symtab_h) $(bfd_h) $(objfiles_h) \
@@ -2580,6 +2589,9 @@
 	$(frame_h) $(gdb_regex_h) $(inferior_h) $(environ_h) $(language_h) \
 	$(gdbcmd_h) $(completer_h) $(filenames_h) $(exec_h) $(solist_h) \
 	$(observer_h) $(readline_h)
+solib-bfin.o: solib-bfin.c $(defs_h) $(gdb_string_h) $(inferior_h) \
+	$(gdbcore_h) $(solist_h) $(bfin_tdep_h) $(objfiles_h) $(symtab_h) \
+	$(language_h) $(command_h) $(gdbcmd_h) $(elf_bfin_h)
 solib-frv.o: solib-frv.c $(defs_h) $(gdb_string_h) $(inferior_h) \
 	$(gdbcore_h) $(solist_h) $(frv_tdep_h) $(objfiles_h) $(symtab_h) \
 	$(language_h) $(command_h) $(gdbcmd_h) $(elf_frv_h)
diff -Naur gdb-6.5.orig/gdb/regformats/reg-bfin.dat gdb-6.5/gdb/regformats/reg-bfin.dat
--- gdb-6.5.orig/gdb/regformats/reg-bfin.dat	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/gdb/regformats/reg-bfin.dat	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,63 @@
+name:bfin
+expedite:pc,sp,fp
+32:r0
+32:r1
+32:r2
+32:r3
+32:r4
+32:r5
+32:r6
+32:r7
+32:p0
+32:p1
+32:p2
+32:p3
+32:p4
+32:p5
+32:sp
+32:fp
+32:i0
+32:i1
+32:i2
+32:i3
+32:m0
+32:m1
+32:m2
+32:m3
+32:b0
+32:b1
+32:b2
+32:b3
+32:l0
+32:l1
+32:l2
+32:l3
+32:a0x
+32:a0w
+32:a1x
+32:a1w
+32:astat
+32:rets 
+32:lc0
+32:lt0
+32:lb0
+32:lc1
+32:lt1
+32:lb1
+32:cycles
+32:cycles2
+32:usp
+32:seqstat
+32:syscfg
+32:reti
+32:retx
+32:retn
+32:rete
+32:pc
+32:cc
+32:extra1
+32:extra2
+32:extra3
+32:fdpic_exec
+32:fdpic_interp
+32:ipend
diff -Naur gdb-6.5.orig/gdb/remote.c gdb-6.5/gdb/remote.c
--- gdb-6.5.orig/gdb/remote.c	2006-05-05 22:08:45.000000000 +0200
+++ gdb-6.5/gdb/remote.c	2009-01-22 08:19:21.000000000 +0100
@@ -1912,7 +1912,9 @@
 
   inferior_ptid = remote_current_thread (inferior_ptid);
 
-  get_offsets ();		/* Get text, data & bss offsets.  */
+  /* Get text, data & bss offsets.  */
+  if (gdbarch_use_get_offsets (current_gdbarch))
+    get_offsets ();
 
   putpkt ("?");			/* Initiate a query from remote machine.  */
   immediate_quit--;
diff -Naur gdb-6.5.orig/gdb/solib-bfin.c gdb-6.5/gdb/solib-bfin.c
--- gdb-6.5.orig/gdb/solib-bfin.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/gdb/solib-bfin.c	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,1231 @@
+/* Handle Blackfin (FDPIC) shared libraries for GDB, the GNU Debugger.
+   Copyright 2006
+   Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+
+#include "defs.h"
+#include "gdb_string.h"
+#include "inferior.h"
+#include "gdbcore.h"
+#include "solist.h"
+#include "bfin-tdep.h"
+#include "objfiles.h"
+#include "symtab.h"
+#include "language.h"
+#include "command.h"
+#include "gdbcmd.h"
+#include "elf/bfin.h"
+
+/* Flag which indicates whether internal debug messages should be printed.  */
+static int solib_bfin_debug;
+
+/* BFIN pointers are four bytes wide.  */
+enum { BFIN_PTR_SIZE = 4 };
+
+/* Representation of loadmap and related structs for the BFIN FDPIC ABI.  */
+
+/* External versions; the size and alignment of the fields should be
+   the same as those on the target.  When loaded, the placement of
+   the bits in each field will be the same as on the target.  */
+typedef gdb_byte ext_Elf32_Half[2];
+typedef gdb_byte ext_Elf32_Addr[4];
+typedef gdb_byte ext_Elf32_Word[4];
+
+struct ext_elf32_fdpic_loadseg
+{
+  /* Core address to which the segment is mapped.  */
+  ext_Elf32_Addr addr;
+  /* VMA recorded in the program header.  */
+  ext_Elf32_Addr p_vaddr;
+  /* Size of this segment in memory.  */
+  ext_Elf32_Word p_memsz;
+};
+
+struct ext_elf32_fdpic_loadmap {
+  /* Protocol version number, must be zero.  */
+  ext_Elf32_Half version;
+  /* Number of segments in this map.  */
+  ext_Elf32_Half nsegs;
+  /* The actual memory map.  */
+  struct ext_elf32_fdpic_loadseg segs[1 /* nsegs, actually */];
+};
+
+/* Internal versions; the types are GDB types and the data in each
+   of the fields is (or will be) decoded from the external struct
+   for ease of consumption.  */
+struct int_elf32_fdpic_loadseg
+{
+  /* Core address to which the segment is mapped.  */
+  CORE_ADDR addr;
+  /* VMA recorded in the program header.  */
+  CORE_ADDR p_vaddr;
+  /* Size of this segment in memory.  */
+  long p_memsz;
+};
+
+struct int_elf32_fdpic_loadmap {
+  /* Protocol version number, must be zero.  */
+  int version;
+  /* Number of segments in this map.  */
+  int nsegs;
+  /* The actual memory map.  */
+  struct int_elf32_fdpic_loadseg segs[1 /* nsegs, actually */];
+};
+
+/* Given address LDMADDR, fetch and decode the loadmap at that address.
+   Return NULL if there is a problem reading the target memory or if
+   there doesn't appear to be a loadmap at the given address.  The
+   allocated space (representing the loadmap) returned by this
+   function may be freed via a single call to xfree().  */
+
+static struct int_elf32_fdpic_loadmap *
+fetch_loadmap (CORE_ADDR ldmaddr)
+{
+  struct ext_elf32_fdpic_loadmap ext_ldmbuf_partial;
+  struct ext_elf32_fdpic_loadmap *ext_ldmbuf;
+  struct int_elf32_fdpic_loadmap *int_ldmbuf;
+  int ext_ldmbuf_size, int_ldmbuf_size;
+  int version, seg, nsegs;
+
+  /* Fetch initial portion of the loadmap.  */
+  if (target_read_memory (ldmaddr, (gdb_byte *) &ext_ldmbuf_partial,
+                          sizeof ext_ldmbuf_partial))
+    {
+      /* Problem reading the target's memory.  */
+      return NULL;
+    }
+
+  /* Extract the version.  */
+  version = extract_unsigned_integer (ext_ldmbuf_partial.version,
+                                      sizeof ext_ldmbuf_partial.version);
+  if (version != 0)
+    {
+      /* We only handle version 0.  */
+      return NULL;
+    }
+
+  /* Extract the number of segments.  */
+  nsegs = extract_unsigned_integer (ext_ldmbuf_partial.nsegs,
+                                    sizeof ext_ldmbuf_partial.nsegs);
+
+  /* Allocate space for the complete (external) loadmap.  */
+  ext_ldmbuf_size = sizeof (struct ext_elf32_fdpic_loadmap)
+               + (nsegs - 1) * sizeof (struct ext_elf32_fdpic_loadseg);
+  ext_ldmbuf = xmalloc (ext_ldmbuf_size);
+
+  /* Copy over the portion of the loadmap that's already been read.  */
+  memcpy (ext_ldmbuf, &ext_ldmbuf_partial, sizeof ext_ldmbuf_partial);
+
+  /* Read the rest of the loadmap from the target.  */
+  if (target_read_memory (ldmaddr + sizeof ext_ldmbuf_partial,
+                          (gdb_byte *) ext_ldmbuf + sizeof ext_ldmbuf_partial,
+                          ext_ldmbuf_size - sizeof ext_ldmbuf_partial))
+    {
+      /* Couldn't read rest of the loadmap.  */
+      xfree (ext_ldmbuf);
+      return NULL;
+    }
+
+  /* Allocate space into which to put information extract from the
+     external loadsegs.  I.e, allocate the internal loadsegs.  */
+  int_ldmbuf_size = sizeof (struct int_elf32_fdpic_loadmap)
+               + (nsegs - 1) * sizeof (struct int_elf32_fdpic_loadseg);
+  int_ldmbuf = xmalloc (int_ldmbuf_size);
+
+  /* Place extracted information in internal structs.  */
+  int_ldmbuf->version = version;
+  int_ldmbuf->nsegs = nsegs;
+  for (seg = 0; seg < nsegs; seg++)
+    {
+      int_ldmbuf->segs[seg].addr
+	= extract_unsigned_integer (ext_ldmbuf->segs[seg].addr,
+	                            sizeof (ext_ldmbuf->segs[seg].addr));
+      int_ldmbuf->segs[seg].p_vaddr
+	= extract_unsigned_integer (ext_ldmbuf->segs[seg].p_vaddr,
+	                            sizeof (ext_ldmbuf->segs[seg].p_vaddr));
+      int_ldmbuf->segs[seg].p_memsz
+	= extract_unsigned_integer (ext_ldmbuf->segs[seg].p_memsz,
+	                            sizeof (ext_ldmbuf->segs[seg].p_memsz));
+    }
+
+  xfree (ext_ldmbuf);
+  return int_ldmbuf;
+}
+
+/* External link_map and elf32_fdpic_loadaddr struct definitions.  */
+
+typedef gdb_byte ext_ptr[4];
+
+struct ext_elf32_fdpic_loadaddr
+{
+  ext_ptr map;			/* struct elf32_fdpic_loadmap *map; */
+  ext_ptr got_value;		/* void *got_value; */
+};
+
+struct ext_link_map
+{
+  struct ext_elf32_fdpic_loadaddr l_addr;
+
+  /* Absolute file name object was found in.  */
+  ext_ptr l_name;		/* char *l_name; */
+
+  /* Dynamic section of the shared object.  */
+  ext_ptr l_ld;			/* ElfW(Dyn) *l_ld; */
+
+  /* Chain of loaded objects.  */
+  ext_ptr l_next, l_prev;	/* struct link_map *l_next, *l_prev; */
+};
+
+/* Link map info to include in an allocated so_list entry */
+
+struct lm_info
+  {
+    /* The loadmap, digested into an easier to use form.  */
+    struct int_elf32_fdpic_loadmap *map;
+    /* The GOT address for this link map entry.  */
+    CORE_ADDR got_value;
+
+    /* Cached dynamic symbol table and dynamic relocs initialized and
+       used only by find_canonical_descriptor_in_load_object().
+
+       Note: kevinb/2004-02-26: It appears that calls to
+       bfd_canonicalize_dynamic_reloc() will use the same symbols as
+       those supplied to the first call to this function.  Therefore,
+       it's important to NOT free the asymbol ** data structure
+       supplied to the first call.  Thus the caching of the dynamic
+       symbols (dyn_syms) is critical for correct operation.  The
+       caching of the dynamic relocations could be dispensed with.  */
+    asymbol **dyn_syms;
+    arelent **dyn_relocs;
+    int dyn_reloc_count;	/* number of dynamic relocs.  */
+
+  };
+
+/* The load map, got value, etc. are not available from the chain
+   of loaded shared objects.  ``main_executable_lm_info'' provides
+   a way to get at this information so that it doesn't need to be
+   frequently recomputed.  Initialized by bfin_relocate_main_executable().  */
+static struct lm_info *main_executable_lm_info;
+
+static void bfin_relocate_main_executable (void);
+static CORE_ADDR main_got (void);
+static int enable_break2 (void);
+
+/*
+
+   LOCAL FUNCTION
+
+   bfd_lookup_symbol -- lookup the value for a specific symbol
+
+   SYNOPSIS
+
+   CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname)
+
+   DESCRIPTION
+
+   An expensive way to lookup the value of a single symbol for
+   bfd's that are only temporary anyway.  This is used by the
+   shared library support to find the address of the debugger
+   interface structures in the shared library.
+
+   Note that 0 is specifically allowed as an error return (no
+   such symbol).
+ */
+
+static CORE_ADDR
+bfd_lookup_symbol (bfd *abfd, char *symname)
+{
+  long storage_needed;
+  asymbol *sym;
+  asymbol **symbol_table;
+  unsigned int number_of_symbols;
+  unsigned int i;
+  struct cleanup *back_to;
+  CORE_ADDR symaddr = 0;
+
+  storage_needed = bfd_get_symtab_upper_bound (abfd);
+
+  if (storage_needed > 0)
+    {
+      symbol_table = (asymbol **) xmalloc (storage_needed);
+      back_to = make_cleanup (xfree, symbol_table);
+      number_of_symbols = bfd_canonicalize_symtab (abfd, symbol_table);
+
+      for (i = 0; i < number_of_symbols; i++)
+	{
+	  sym = *symbol_table++;
+	  if (strcmp (sym->name, symname) == 0)
+	    {
+	      /* Bfd symbols are section relative. */
+	      symaddr = sym->value + sym->section->vma;
+	      break;
+	    }
+	}
+      do_cleanups (back_to);
+    }
+
+  if (symaddr)
+    return symaddr;
+
+  /* Look for the symbol in the dynamic string table too.  */
+
+  storage_needed = bfd_get_dynamic_symtab_upper_bound (abfd);
+
+  if (storage_needed > 0)
+    {
+      symbol_table = (asymbol **) xmalloc (storage_needed);
+      back_to = make_cleanup (xfree, symbol_table);
+      number_of_symbols = bfd_canonicalize_dynamic_symtab (abfd, symbol_table);
+
+      for (i = 0; i < number_of_symbols; i++)
+	{
+	  sym = *symbol_table++;
+	  if (strcmp (sym->name, symname) == 0)
+	    {
+	      /* Bfd symbols are section relative. */
+	      symaddr = sym->value + sym->section->vma;
+	      break;
+	    }
+	}
+      do_cleanups (back_to);
+    }
+
+  return symaddr;
+}
+
+
+/*
+
+  LOCAL FUNCTION
+
+  open_symbol_file_object
+
+  SYNOPSIS
+
+  void open_symbol_file_object (void *from_tty)
+
+  DESCRIPTION
+
+  If no open symbol file, attempt to locate and open the main symbol
+  file.
+
+  If FROM_TTYP dereferences to a non-zero integer, allow messages to
+  be printed.  This parameter is a pointer rather than an int because
+  open_symbol_file_object() is called via catch_errors() and
+  catch_errors() requires a pointer argument. */
+
+static int
+open_symbol_file_object (void *from_ttyp)
+{
+  /* Unimplemented.  */
+  return 0;
+}
+
+/* Cached value for lm_base(), below.  */
+static CORE_ADDR lm_base_cache = 0;
+
+/* Return the address from which the link map chain may be found.  On
+   the BFIN, this may be found in a number of ways.  Assuming that the
+   main executable has already been relocated, the easiest way to find
+   this value is to look up the address of _GLOBAL_OFFSET_TABLE_.  A
+   pointer to the start of the link map will be located at the word found
+   at _GLOBAL_OFFSET_TABLE_ + 8.  (This is part of the dynamic linker
+   reserve area mandated by the ABI.)  */
+
+static CORE_ADDR
+lm_base (void)
+{
+  struct minimal_symbol *got_sym;
+  CORE_ADDR addr;
+  gdb_byte buf[BFIN_PTR_SIZE];
+
+  /* If we already have a cached value, return it.  */
+  if (lm_base_cache)
+    return lm_base_cache;
+
+  got_sym = lookup_minimal_symbol ("_GLOBAL_OFFSET_TABLE_", NULL,
+                                   symfile_objfile);
+  if (got_sym == 0)
+    {
+      if (solib_bfin_debug)
+	fprintf_unfiltered (gdb_stdlog,
+	                    "lm_base: _GLOBAL_OFFSET_TABLE_ not found.\n");
+      return 0;
+    }
+
+  addr = SYMBOL_VALUE_ADDRESS (got_sym) + 8;
+
+  if (solib_bfin_debug)
+    fprintf_unfiltered (gdb_stdlog,
+			"lm_base: _GLOBAL_OFFSET_TABLE_ + 8 = %s\n",
+			hex_string_custom (addr, 8));
+
+  if (target_read_memory (addr, buf, sizeof buf) != 0)
+    return 0;
+  lm_base_cache = extract_unsigned_integer (buf, sizeof buf);
+
+  if (solib_bfin_debug)
+    fprintf_unfiltered (gdb_stdlog,
+			"lm_base: lm_base_cache = %s\n",
+			hex_string_custom (lm_base_cache, 8));
+
+  return lm_base_cache;
+}
+
+
+/* LOCAL FUNCTION
+
+   bfin_current_sos -- build a list of currently loaded shared objects
+
+   SYNOPSIS
+
+   struct so_list *bfin_current_sos ()
+
+   DESCRIPTION
+
+   Build a list of `struct so_list' objects describing the shared
+   objects currently loaded in the inferior.  This list does not
+   include an entry for the main executable file.
+
+   Note that we only gather information directly available from the
+   inferior --- we don't examine any of the shared library files
+   themselves.  The declaration of `struct so_list' says which fields
+   we provide values for.  */
+
+static struct so_list *
+bfin_current_sos (void)
+{
+  CORE_ADDR lm_addr, mgot;
+  struct so_list *sos_head = NULL;
+  struct so_list **sos_next_ptr = &sos_head;
+
+  mgot = main_got ();
+
+  /* Locate the address of the first link map struct.  */
+  lm_addr = lm_base ();
+
+  /* We have at least one link map entry.  Fetch the the lot of them,
+     building the solist chain.  */
+  while (lm_addr)
+    {
+      struct ext_link_map lm_buf;
+      CORE_ADDR got_addr;
+
+      if (solib_bfin_debug)
+	fprintf_unfiltered (gdb_stdlog,
+			    "bfin_current_sos: reading link_map entry at %s\n",
+			    hex_string_custom (lm_addr, 8));
+
+      if (target_read_memory (lm_addr, (gdb_byte *) &lm_buf, sizeof (lm_buf)) != 0)
+	{
+	  warning ("bfin_current_sos: Unable to read link map entry.  Shared object chain may be incomplete.");
+	  break;
+	}
+
+      got_addr
+	= extract_unsigned_integer (lm_buf.l_addr.got_value,
+				    sizeof (lm_buf.l_addr.got_value));
+      /* If the got_addr is the same as mgotr, then we're looking at the
+	 entry for the main executable.  By convention, we don't include
+	 this in the list of shared objects.  */
+      if (got_addr != mgot)
+	{
+	  int errcode;
+	  char *name_buf;
+	  struct int_elf32_fdpic_loadmap *loadmap;
+	  struct so_list *sop;
+	  CORE_ADDR addr;
+
+	  /* Fetch the load map address.  */
+	  addr = extract_unsigned_integer (lm_buf.l_addr.map,
+					   sizeof lm_buf.l_addr.map);
+	  loadmap = fetch_loadmap (addr);
+	  if (loadmap == NULL)
+	    {
+	      warning ("bfin_current_sos: Unable to fetch load map.  Shared object chain may be incomplete.");
+	      break;
+	    }
+
+	  sop = xcalloc (1, sizeof (struct so_list));
+	  sop->lm_info = xcalloc (1, sizeof (struct lm_info));
+	  sop->lm_info->map = loadmap;
+	  sop->lm_info->got_value = got_addr;
+	  /* Fetch the name.  */
+	  addr = extract_unsigned_integer (lm_buf.l_name,
+					   sizeof (lm_buf.l_name));
+	  target_read_string (addr, &name_buf, SO_NAME_MAX_PATH_SIZE - 1,
+			      &errcode);
+
+	  if (solib_bfin_debug)
+	    fprintf_unfiltered (gdb_stdlog, "bfin_current_sos: name = %s\n",
+	                        name_buf);
+	  
+	  if (errcode != 0)
+	    {
+	      warning ("bfin_current_sos: Can't read pathname for link map entry: %s\n",
+		       safe_strerror (errcode));
+	    }
+	  else
+	    {
+	      strncpy (sop->so_name, name_buf, SO_NAME_MAX_PATH_SIZE - 1);
+	      sop->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
+	      xfree (name_buf);
+	      strcpy (sop->so_original_name, sop->so_name);
+	    }
+
+	  *sos_next_ptr = sop;
+	  sos_next_ptr = &sop->next;
+	}
+
+      lm_addr = extract_unsigned_integer (lm_buf.l_next, sizeof (lm_buf.l_next));
+    }
+
+  enable_break2 ();
+
+  return sos_head;
+}
+
+
+/* Return 1 if PC lies in the dynamic symbol resolution code of the
+   run time loader.  */
+
+static CORE_ADDR interp_text_sect_low;
+static CORE_ADDR interp_text_sect_high;
+static CORE_ADDR interp_plt_sect_low;
+static CORE_ADDR interp_plt_sect_high;
+
+static int
+bfin_in_dynsym_resolve_code (CORE_ADDR pc)
+{
+  return ((pc >= interp_text_sect_low && pc < interp_text_sect_high)
+	  || (pc >= interp_plt_sect_low && pc < interp_plt_sect_high)
+	  || in_plt_section (pc, NULL));
+}
+
+/* Given a loadmap and an address, return the displacement needed
+   to relocate the address.  */
+
+CORE_ADDR
+displacement_from_map (struct int_elf32_fdpic_loadmap *map,
+                       CORE_ADDR addr)
+{
+  int seg;
+
+  for (seg = 0; seg < map->nsegs; seg++)
+    {
+      if (map->segs[seg].p_vaddr <= addr
+          && addr < map->segs[seg].p_vaddr + map->segs[seg].p_memsz)
+	{
+	  return map->segs[seg].addr - map->segs[seg].p_vaddr;
+	}
+    }
+
+  return 0;
+}
+
+/* Print a warning about being unable to set the dynamic linker
+   breakpoint.  */
+
+static void
+enable_break_failure_warning (void)
+{
+  warning ("Unable to find dynamic linker breakpoint function.\n"
+           "GDB will be unable to debug shared library initializers\n"
+	   "and track explicitly loaded dynamic code.");
+}
+
+/*
+
+   LOCAL FUNCTION
+
+   enable_break -- arrange for dynamic linker to hit breakpoint
+
+   SYNOPSIS
+
+   int enable_break (void)
+
+   DESCRIPTION
+
+   The dynamic linkers has, as part of its debugger interface, support
+   for arranging for the inferior to hit a breakpoint after mapping in
+   the shared libraries.  This function enables that breakpoint.
+
+   On the BFIN, using the shared library (FDPIC) ABI, the symbol
+   _dl_debug_addr points to the r_debug struct which contains
+   a field called r_brk.  r_brk is the address of the function
+   descriptor upon which a breakpoint must be placed.  Being a
+   function descriptor, we must extract the entry point in order
+   to set the breakpoint.
+
+   Our strategy will be to get the .interp section from the
+   executable.  This section will provide us with the name of the
+   interpreter.  We'll open the interpreter and then look up
+   the address of _dl_debug_addr.  We then relocate this address
+   using the interpreter's loadmap.  Once the relocated address
+   is known, we fetch the value (address) corresponding to r_brk
+   and then use that value to fetch the entry point of the function
+   we're interested in.
+
+ */
+
+static int enable_break1_done = 0;
+static int enable_break2_done = 0;
+
+static int
+enable_break2 (void)
+{
+  int success = 0;
+  char **bkpt_namep;
+  asection *interp_sect;
+
+  if (!enable_break1_done || enable_break2_done)
+    return 1;
+
+  enable_break2_done = 1;
+
+  /* First, remove all the solib event breakpoints.  Their addresses
+     may have changed since the last time we ran the program.  */
+  remove_solib_event_breakpoints ();
+
+  interp_text_sect_low = interp_text_sect_high = 0;
+  interp_plt_sect_low = interp_plt_sect_high = 0;
+
+  /* Find the .interp section; if not found, warn the user and drop
+     into the old breakpoint at symbol code.  */
+  interp_sect = bfd_get_section_by_name (exec_bfd, ".interp");
+  if (interp_sect)
+    {
+      unsigned int interp_sect_size;
+      gdb_byte *buf;
+      bfd *tmp_bfd = NULL;
+      int tmp_fd = -1;
+      char *tmp_pathname = NULL;
+      int status;
+      CORE_ADDR addr, interp_loadmap_addr;
+      gdb_byte addr_buf[BFIN_PTR_SIZE];
+      struct int_elf32_fdpic_loadmap *ldm;
+
+      /* Read the contents of the .interp section into a local buffer;
+         the contents specify the dynamic linker this program uses.  */
+      interp_sect_size = bfd_section_size (exec_bfd, interp_sect);
+      buf = alloca (interp_sect_size);
+      bfd_get_section_contents (exec_bfd, interp_sect,
+				buf, 0, interp_sect_size);
+
+      /* Now we need to figure out where the dynamic linker was
+         loaded so that we can load its symbols and place a breakpoint
+         in the dynamic linker itself.
+
+         This address is stored on the stack.  However, I've been unable
+         to find any magic formula to find it for Solaris (appears to
+         be trivial on GNU/Linux).  Therefore, we have to try an alternate
+         mechanism to find the dynamic linker's base address.  */
+
+      tmp_fd  = solib_open (buf, &tmp_pathname);
+      if (tmp_fd >= 0)
+	tmp_bfd = bfd_fdopenr (tmp_pathname, gnutarget, tmp_fd);
+
+      if (tmp_bfd == NULL)
+	{
+	  enable_break_failure_warning ();
+	  return 0;
+	}
+
+      /* Make sure the dynamic linker is really a useful object.  */
+      if (!bfd_check_format (tmp_bfd, bfd_object))
+	{
+	  warning ("Unable to grok dynamic linker %s as an object file", buf);
+	  enable_break_failure_warning ();
+	  bfd_close (tmp_bfd);
+	  return 0;
+	}
+
+      status = bfin_fdpic_loadmap_addresses (current_gdbarch,
+                                            &interp_loadmap_addr, 0);
+      if (status < 0)
+	{
+	  warning ("Unable to determine dynamic linker loadmap address\n");
+	  enable_break_failure_warning ();
+	  bfd_close (tmp_bfd);
+	  return 0;
+	}
+
+      if (solib_bfin_debug)
+	fprintf_unfiltered (gdb_stdlog,
+	                    "enable_break: interp_loadmap_addr = %s\n",
+			    hex_string_custom (interp_loadmap_addr, 8));
+
+      ldm = fetch_loadmap (interp_loadmap_addr);
+      if (ldm == NULL)
+	{
+	  warning ("Unable to load dynamic linker loadmap at address %s\n",
+	           hex_string_custom (interp_loadmap_addr, 8));
+	  enable_break_failure_warning ();
+	  bfd_close (tmp_bfd);
+	  return 0;
+	}
+
+      /* Record the relocated start and end address of the dynamic linker
+         text and plt section for svr4_in_dynsym_resolve_code.  */
+      interp_sect = bfd_get_section_by_name (tmp_bfd, ".text");
+      if (interp_sect)
+	{
+	  interp_text_sect_low
+	    = bfd_section_vma (tmp_bfd, interp_sect);
+	  interp_text_sect_low
+	    += displacement_from_map (ldm, interp_text_sect_low);
+	  interp_text_sect_high
+	    = interp_text_sect_low + bfd_section_size (tmp_bfd, interp_sect);
+	}
+      interp_sect = bfd_get_section_by_name (tmp_bfd, ".plt");
+      if (interp_sect)
+	{
+	  interp_plt_sect_low =
+	    bfd_section_vma (tmp_bfd, interp_sect);
+	  interp_plt_sect_low
+	    += displacement_from_map (ldm, interp_plt_sect_low);
+	  interp_plt_sect_high =
+	    interp_plt_sect_low + bfd_section_size (tmp_bfd, interp_sect);
+	}
+
+      addr = bfd_lookup_symbol (tmp_bfd, "__dl_debug_addr");
+      if (addr == 0)
+	{
+	  warning ("Could not find symbol _dl_debug_addr in dynamic linker");
+	  enable_break_failure_warning ();
+	  bfd_close (tmp_bfd);
+	  return 0;
+	}
+
+      if (solib_bfin_debug)
+	fprintf_unfiltered (gdb_stdlog,
+	                    "enable_break: _dl_debug_addr (prior to relocation) = %s\n",
+			    hex_string_custom (addr, 8));
+
+      addr += displacement_from_map (ldm, addr);
+
+      if (solib_bfin_debug)
+	fprintf_unfiltered (gdb_stdlog,
+	                    "enable_break: _dl_debug_addr (after relocation) = %s\n",
+			    hex_string_custom (addr, 8));
+
+      /* Fetch the address of the r_debug struct.  */
+      if (target_read_memory (addr, addr_buf, sizeof addr_buf) != 0)
+	{
+	  warning ("Unable to fetch contents of _dl_debug_addr (at address %s) from dynamic linker",
+	           hex_string_custom (addr, 8));
+	}
+      addr = extract_unsigned_integer (addr_buf, sizeof addr_buf);
+
+      /* Fetch the r_brk field.  It's 8 bytes from the start of
+         _dl_debug_addr.  */
+      if (target_read_memory (addr + 8, addr_buf, sizeof addr_buf) != 0)
+	{
+	  warning ("Unable to fetch _dl_debug_addr->r_brk (at address %s) from dynamic linker",
+	           hex_string_custom (addr + 8, 8));
+	  enable_break_failure_warning ();
+	  bfd_close (tmp_bfd);
+	  return 0;
+	}
+      addr = extract_unsigned_integer (addr_buf, sizeof addr_buf);
+
+      /* Now fetch the function entry point.  */
+      if (target_read_memory (addr, addr_buf, sizeof addr_buf) != 0)
+	{
+	  warning ("Unable to fetch _dl_debug_addr->.r_brk entry point (at address %s) from dynamic linker",
+	           hex_string_custom (addr, 8));
+	  enable_break_failure_warning ();
+	  bfd_close (tmp_bfd);
+	  return 0;
+	}
+      addr = extract_unsigned_integer (addr_buf, sizeof addr_buf);
+
+      /* We're done with the temporary bfd.  */
+      bfd_close (tmp_bfd);
+
+      /* We're also done with the loadmap.  */
+      xfree (ldm);
+
+      /* Now (finally!) create the solib breakpoint.  */
+      create_solib_event_breakpoint (addr);
+
+      return 1;
+    }
+
+  /* Tell the user we couldn't set a dynamic linker breakpoint.  */
+  enable_break_failure_warning ();
+
+  /* Failure return.  */
+  return 0;
+}
+
+static int
+enable_break (void)
+{
+  asection *interp_sect;
+
+  /* Remove all the solib event breakpoints.  Their addresses
+     may have changed since the last time we ran the program.  */
+  remove_solib_event_breakpoints ();
+
+  /* Check for the presence of a .interp section.  If there is no
+     such section, the executable is statically linked.  */
+
+  interp_sect = bfd_get_section_by_name (exec_bfd, ".interp");
+
+  if (interp_sect)
+    {
+      enable_break1_done = 1;
+      create_solib_event_breakpoint (symfile_objfile->ei.entry_point);
+
+      if (solib_bfin_debug)
+	fprintf_unfiltered (gdb_stdlog,
+			    "enable_break: solib event breakpoint placed at entry point: %s\n",
+			    hex_string_custom
+			      (symfile_objfile->ei.entry_point, 8));
+    }
+  else
+    {
+      if (solib_bfin_debug)
+	fprintf_unfiltered (gdb_stdlog,
+	                    "enable_break: No .interp section found.\n");
+    }
+
+  return 1;
+}
+
+/*
+
+   LOCAL FUNCTION
+
+   special_symbol_handling -- additional shared library symbol handling
+
+   SYNOPSIS
+
+   void special_symbol_handling ()
+
+   DESCRIPTION
+
+   Once the symbols from a shared object have been loaded in the usual
+   way, we are called to do any system specific symbol handling that 
+   is needed.
+
+ */
+
+static void
+bfin_special_symbol_handling (void)
+{
+  /* Nothing needed (yet) for FRV. */
+}
+
+static void
+bfin_relocate_main_executable (void)
+{
+  int status;
+  CORE_ADDR exec_addr;
+  struct int_elf32_fdpic_loadmap *ldm;
+  struct cleanup *old_chain;
+  struct section_offsets *new_offsets;
+  int changed;
+  struct obj_section *osect;
+
+  status = bfin_fdpic_loadmap_addresses (current_gdbarch, 0, &exec_addr);
+
+  if (status < 0)
+    {
+      /* Not using FDPIC ABI, so do nothing.  */
+      return;
+    }
+
+  /* Fetch the loadmap located at ``exec_addr''.  */
+  ldm = fetch_loadmap (exec_addr);
+  if (ldm == NULL)
+    error ("Unable to load the executable's loadmap.");
+
+  if (main_executable_lm_info)
+    xfree (main_executable_lm_info);
+  main_executable_lm_info = xcalloc (1, sizeof (struct lm_info));
+  main_executable_lm_info->map = ldm;
+
+  new_offsets = xcalloc (symfile_objfile->num_sections,
+			 sizeof (struct section_offsets));
+  old_chain = make_cleanup (xfree, new_offsets);
+  changed = 0;
+
+  ALL_OBJFILE_OSECTIONS (symfile_objfile, osect)
+    {
+      CORE_ADDR orig_addr, addr, offset;
+      int osect_idx;
+      int seg;
+      
+      osect_idx = osect->the_bfd_section->index;
+
+      /* Current address of section.  */
+      addr = osect->addr;
+      /* Offset from where this section started.  */
+      offset = ANOFFSET (symfile_objfile->section_offsets, osect_idx);
+      /* Original address prior to any past relocations.  */
+      orig_addr = addr - offset;
+
+      for (seg = 0; seg < ldm->nsegs; seg++)
+	{
+	  if (ldm->segs[seg].p_vaddr <= orig_addr
+	      && orig_addr < ldm->segs[seg].p_vaddr + ldm->segs[seg].p_memsz)
+	    {
+	      new_offsets->offsets[osect_idx]
+		= ldm->segs[seg].addr - ldm->segs[seg].p_vaddr;
+
+	      if (new_offsets->offsets[osect_idx] != offset)
+		changed = 1;
+	      break;
+	    }
+	}
+    }
+
+  if (changed)
+    objfile_relocate (symfile_objfile, new_offsets);
+
+  do_cleanups (old_chain);
+
+  /* Now that symfile_objfile has been relocated, we can compute the
+     GOT value and stash it away.  */
+  main_executable_lm_info->got_value = main_got ();
+}
+
+/*
+
+   GLOBAL FUNCTION
+
+   bfin_solib_create_inferior_hook -- shared library startup support
+
+   SYNOPSIS
+
+   void bfin_solib_create_inferior_hook()
+
+   DESCRIPTION
+
+   When gdb starts up the inferior, it nurses it along (through the
+   shell) until it is ready to execute it's first instruction.  At this
+   point, this function gets called via expansion of the macro
+   SOLIB_CREATE_INFERIOR_HOOK.
+
+   For the BFIN shared library ABI (FDPIC), the main executable
+   needs to be relocated.  The shared library breakpoints also need
+   to be enabled.
+ */
+
+static void
+bfin_solib_create_inferior_hook (void)
+{
+  /* Relocate main executable.  */
+  bfin_relocate_main_executable ();
+
+  /* Enable shared library breakpoints.  */
+  if (!enable_break ())
+    {
+      warning ("shared library handler failed to enable breakpoint");
+      return;
+    }
+}
+
+static void
+bfin_clear_solib (void)
+{
+  lm_base_cache = 0;
+  enable_break1_done = 0;
+  enable_break2_done = 0;
+}
+
+static void
+bfin_free_so (struct so_list *so)
+{
+  xfree (so->lm_info->map);
+  xfree (so->lm_info->dyn_syms);
+  xfree (so->lm_info->dyn_relocs);
+  xfree (so->lm_info);
+}
+
+static void
+bfin_relocate_section_addresses (struct so_list *so,
+                                 struct section_table *sec)
+{
+  int seg;
+  struct int_elf32_fdpic_loadmap *map;
+
+  map = so->lm_info->map;
+
+  for (seg = 0; seg < map->nsegs; seg++)
+    {
+      if (map->segs[seg].p_vaddr <= sec->addr
+          && sec->addr < map->segs[seg].p_vaddr + map->segs[seg].p_memsz)
+	{
+	  CORE_ADDR displ = map->segs[seg].addr - map->segs[seg].p_vaddr;
+	  sec->addr += displ;
+	  sec->endaddr += displ;
+	  break;
+	}
+    }
+}
+
+/* Return the GOT address associated with the main executable.  Return
+   0 if it can't be found.  */
+
+static CORE_ADDR
+main_got (void)
+{
+  struct minimal_symbol *got_sym;
+
+  got_sym = lookup_minimal_symbol ("_GLOBAL_OFFSET_TABLE_", NULL, symfile_objfile);
+  if (got_sym == 0)
+    return 0;
+
+  return SYMBOL_VALUE_ADDRESS (got_sym);
+}
+
+/* Find the global pointer for the given function address ADDR.  */
+
+CORE_ADDR
+bfin_fdpic_find_global_pointer (CORE_ADDR addr)
+{
+  struct so_list *so;
+
+  so = master_so_list ();
+  while (so)
+    {
+      int seg;
+      struct int_elf32_fdpic_loadmap *map;
+
+      map = so->lm_info->map;
+
+      for (seg = 0; seg < map->nsegs; seg++)
+	{
+	  if (map->segs[seg].addr <= addr
+	      && addr < map->segs[seg].addr + map->segs[seg].p_memsz)
+	    return so->lm_info->got_value;
+	}
+
+      so = so->next;
+    }
+
+  /* Didn't find it it any of the shared objects.  So assume it's in the
+     main executable.  */
+  return main_got ();
+}
+
+/* Forward declarations for frv_fdpic_find_canonical_descriptor().  */
+static CORE_ADDR find_canonical_descriptor_in_load_object
+  (CORE_ADDR, CORE_ADDR, char *, bfd *, struct lm_info *);
+
+/* Given a function entry point, attempt to find the canonical descriptor
+   associated with that entry point.  Return 0 if no canonical descriptor
+   could be found.  */
+
+CORE_ADDR
+bfin_fdpic_find_canonical_descriptor (CORE_ADDR entry_point)
+{
+  char *name;
+  CORE_ADDR addr;
+  CORE_ADDR got_value;
+  struct int_elf32_fdpic_loadmap *ldm = 0;
+  struct symbol *sym;
+  int status;
+  CORE_ADDR exec_loadmap_addr;
+
+  /* Fetch the corresponding global pointer for the entry point.  */
+  got_value = bfin_fdpic_find_global_pointer (entry_point);
+
+  /* Attempt to find the name of the function.  If the name is available,
+     it'll be used as an aid in finding matching functions in the dynamic
+     symbol table.  */
+  sym = find_pc_function (entry_point);
+  if (sym == 0)
+    name = 0;
+  else
+    name = SYMBOL_LINKAGE_NAME (sym);
+
+  /* Check the main executable.  */
+  addr = find_canonical_descriptor_in_load_object
+           (entry_point, got_value, name, symfile_objfile->obfd,
+	    main_executable_lm_info);
+
+  /* If descriptor not found via main executable, check each load object
+     in list of shared objects.  */
+  if (addr == 0)
+    {
+      struct so_list *so;
+
+      so = master_so_list ();
+      while (so)
+	{
+	  addr = find_canonical_descriptor_in_load_object
+		   (entry_point, got_value, name, so->abfd, so->lm_info);
+
+	  if (addr != 0)
+	    break;
+
+	  so = so->next;
+	}
+    }
+
+  return addr;
+}
+
+static CORE_ADDR
+find_canonical_descriptor_in_load_object
+  (CORE_ADDR entry_point, CORE_ADDR got_value, char *name, bfd *abfd,
+   struct lm_info *lm)
+{
+  arelent *rel;
+  unsigned int i;
+  CORE_ADDR addr = 0;
+
+  /* Nothing to do if no bfd.  */
+  if (abfd == 0)
+    return 0;
+
+  /* We want to scan the dynamic relocs for R_BFIN_FUNCDESC relocations.
+     (More about this later.)  But in order to fetch the relocs, we
+     need to first fetch the dynamic symbols.  These symbols need to
+     be cached due to the way that bfd_canonicalize_dynamic_reloc()
+     works.  (See the comments in the declaration of struct lm_info
+     for more information.)  */
+  if (lm->dyn_syms == NULL)
+    {
+      long storage_needed;
+      unsigned int number_of_symbols;
+
+      /* Determine amount of space needed to hold the dynamic symbol table.  */
+      storage_needed = bfd_get_dynamic_symtab_upper_bound (abfd);
+
+      /* If there are no dynamic symbols, there's nothing to do.  */
+      if (storage_needed <= 0)
+	return 0;
+
+      /* Allocate space for the dynamic symbol table.  */
+      lm->dyn_syms = (asymbol **) xmalloc (storage_needed);
+
+      /* Fetch the dynamic symbol table.  */
+      number_of_symbols = bfd_canonicalize_dynamic_symtab (abfd, lm->dyn_syms);
+
+      if (number_of_symbols == 0)
+	return 0;
+    }
+
+  /* Fetch the dynamic relocations if not already cached.  */
+  if (lm->dyn_relocs == NULL)
+    {
+      long storage_needed;
+
+      /* Determine amount of space needed to hold the dynamic relocs.  */
+      storage_needed = bfd_get_dynamic_reloc_upper_bound (abfd);
+
+      /* Bail out if there are no dynamic relocs.  */
+      if (storage_needed <= 0)
+	return 0;
+
+      /* Allocate space for the relocs.  */
+      lm->dyn_relocs = (arelent **) xmalloc (storage_needed);
+
+      /* Fetch the dynamic relocs.  */
+      lm->dyn_reloc_count 
+	= bfd_canonicalize_dynamic_reloc (abfd, lm->dyn_relocs, lm->dyn_syms);
+    }
+
+  /* Search the dynamic relocs.  */
+  for (i = 0; i < lm->dyn_reloc_count; i++)
+    {
+      rel = lm->dyn_relocs[i];
+
+      /* Relocs of interest are those which meet the following
+         criteria:
+
+	   - the names match (assuming the caller could provide
+	     a name which matches ``entry_point'').
+	   - the relocation type must be R_BFIN_FUNCDESC.  Relocs
+	     of this type are used (by the dynamic linker) to
+	     look up the address of a canonical descriptor (allocating
+	     it if need be) and initializing the GOT entry referred
+	     to by the offset to the address of the descriptor.
+
+	 These relocs of interest may be used to obtain a
+	 candidate descriptor by first adjusting the reloc's
+	 address according to the link map and then dereferencing
+	 this address (which is a GOT entry) to obtain a descriptor
+	 address.  */
+      if ((name == 0 || strcmp (name, (*rel->sym_ptr_ptr)->name) == 0)
+          && rel->howto->type == R_BFIN_FUNCDESC)
+	{
+	  gdb_byte buf[BFIN_PTR_SIZE];
+
+	  /* Compute address of address of candidate descriptor.  */
+	  addr = rel->address + displacement_from_map (lm->map, rel->address);
+
+	  /* Fetch address of candidate descriptor.  */
+	  if (target_read_memory (addr, buf, sizeof buf) != 0)
+	    continue;
+	  addr = extract_unsigned_integer (buf, sizeof buf);
+
+	  /* Check for matching entry point.  */
+	  if (target_read_memory (addr, buf, sizeof buf) != 0)
+	    continue;
+	  if (extract_unsigned_integer (buf, sizeof buf) != entry_point)
+	    continue;
+
+	  /* Check for matching got value.  */
+	  if (target_read_memory (addr + 4, buf, sizeof buf) != 0)
+	    continue;
+	  if (extract_unsigned_integer (buf, sizeof buf) != got_value)
+	    continue;
+
+	  /* Match was successful!  Exit loop.  */
+	  break;
+	}
+    }
+
+  return addr;
+}
+
+static struct target_so_ops bfin_so_ops;
+
+void
+_initialize_bfin_solib (void)
+{
+  bfin_so_ops.relocate_section_addresses = bfin_relocate_section_addresses;
+  bfin_so_ops.free_so = bfin_free_so;
+  bfin_so_ops.clear_solib = bfin_clear_solib;
+  bfin_so_ops.solib_create_inferior_hook = bfin_solib_create_inferior_hook;
+  bfin_so_ops.special_symbol_handling = bfin_special_symbol_handling;
+  bfin_so_ops.current_sos = bfin_current_sos;
+  bfin_so_ops.open_symbol_file_object = open_symbol_file_object;
+  bfin_so_ops.in_dynsym_resolve_code = bfin_in_dynsym_resolve_code;
+
+  /* FIXME: Don't do this here.  *_gdbarch_init() should set so_ops. */
+  current_target_so_ops = &bfin_so_ops;
+
+  /* Debug this file's internals.  */
+  add_setshow_zinteger_cmd ("solib-bfin", class_maintenance,
+			    &solib_bfin_debug, _("\
+Set internal debugging of shared library code for BFIN."), _("\
+Show internal debugging of shared library code for BFIN."), _("\
+When non-zero, BFIN solib specific internal debugging is enabled."),
+			    NULL,
+			    NULL, /* FIXME: i18n: */
+			    &setdebuglist, &showdebuglist);
+}
diff -Naur gdb-6.5.orig/gdb/testsuite/gdb.asm/asm-source.exp gdb-6.5/gdb/testsuite/gdb.asm/asm-source.exp
--- gdb-6.5.orig/gdb/testsuite/gdb.asm/asm-source.exp	2006-05-02 00:21:35.000000000 +0200
+++ gdb-6.5/gdb/testsuite/gdb.asm/asm-source.exp	2009-01-22 08:19:21.000000000 +0100
@@ -51,6 +51,15 @@
     "xscale-*-*" {
         set asm-arch arm
     }
+    "bfin-*-elf" {
+        set asm-arch bfin
+	set debug-flags "-g"
+    }
+    "bfin-*-uclinux" {
+        set asm-arch bfin
+	set debug-flags "-g"
+        append link-flags " -Wl,-elf2flt"
+    }
     "d10v-*-*" {
         set asm-arch d10v
     }
diff -Naur gdb-6.5.orig/gdb/testsuite/gdb.asm/bfin.inc gdb-6.5/gdb/testsuite/gdb.asm/bfin.inc
--- gdb-6.5.orig/gdb/testsuite/gdb.asm/bfin.inc	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/gdb/testsuite/gdb.asm/bfin.inc	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,44 @@
+	comment "subroutine prologue"
+	.macro gdbasm_enter
+	LINK 12;
+	.endm
+
+	comment "subroutine epilogue"
+	.macro gdbasm_leave
+	UNLINK;
+	RTS;
+	.endm
+
+	.macro gdbasm_call subr
+	call \subr;
+	.endm
+
+	.macro gdbasm_several_nops
+	mnop;
+	mnop;
+	mnop;
+	mnop;
+	.endm
+
+	comment "exit (0)"
+	.macro gdbasm_exit0
+	R0 = 0;
+	RAISE 0;
+	.endm
+
+	comment "crt0 startup"
+	.macro gdbasm_startup
+	FP = 0;
+	.endm
+
+	comment "Declare a data variable"
+	.purgem gdbasm_datavar
+	.macro gdbasm_datavar name value
+	.data
+	.align 4
+	.type	\name, @object
+	.size	\name, 4
+\name:
+	.long \value
+	.endm
+
diff -Naur gdb-6.5.orig/include/gdb/sim-bfin.h gdb-6.5/include/gdb/sim-bfin.h
--- gdb-6.5.orig/include/gdb/sim-bfin.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/include/gdb/sim-bfin.h	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,84 @@
+/* This file defines the interface between the Blackfin simulator and GDB.
+
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Analog Devices.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+enum sim_bfin_regnum {
+  SIM_BFIN_R0_REGNUM = 0,
+  SIM_BFIN_R1_REGNUM,
+  SIM_BFIN_R2_REGNUM,
+  SIM_BFIN_R3_REGNUM,
+  SIM_BFIN_R4_REGNUM,
+  SIM_BFIN_R5_REGNUM,
+  SIM_BFIN_R6_REGNUM,
+  SIM_BFIN_R7_REGNUM,
+  SIM_BFIN_P0_REGNUM,
+  SIM_BFIN_P1_REGNUM,
+  SIM_BFIN_P2_REGNUM,
+  SIM_BFIN_P3_REGNUM,
+  SIM_BFIN_P4_REGNUM,
+  SIM_BFIN_P5_REGNUM,
+  SIM_BFIN_SP_REGNUM,
+  SIM_BFIN_FP_REGNUM,
+  SIM_BFIN_I0_REGNUM,
+  SIM_BFIN_I1_REGNUM,
+  SIM_BFIN_I2_REGNUM,
+  SIM_BFIN_I3_REGNUM,
+  SIM_BFIN_M0_REGNUM,
+  SIM_BFIN_M1_REGNUM,
+  SIM_BFIN_M2_REGNUM,
+  SIM_BFIN_M3_REGNUM,
+  SIM_BFIN_B0_REGNUM,
+  SIM_BFIN_B1_REGNUM,
+  SIM_BFIN_B2_REGNUM,
+  SIM_BFIN_B3_REGNUM,
+  SIM_BFIN_L0_REGNUM,
+  SIM_BFIN_L1_REGNUM,
+  SIM_BFIN_L2_REGNUM,
+  SIM_BFIN_L3_REGNUM,
+  SIM_BFIN_A0_DOT_X_REGNUM,
+  SIM_BFIN_AO_DOT_W_REGNUM,
+  SIM_BFIN_A1_DOT_X_REGNUM,
+  SIM_BFIN_A1_DOT_W_REGNUM,
+  SIM_BFIN_ASTAT_REGNUM,
+  SIM_BFIN_RETS_REGNUM,
+  SIM_BFIN_LC0_REGNUM,
+  SIM_BFIN_LT0_REGNUM,
+  SIM_BFIN_LB0_REGNUM,
+  SIM_BFIN_LC1_REGNUM,
+  SIM_BFIN_LT1_REGNUM,
+  SIM_BFIN_LB1_REGNUM,
+  SIM_BFIN_CYCLES_REGNUM,
+  SIM_BFIN_CYCLES2_REGNUM,
+  SIM_BFIN_USP_REGNUM,
+  SIM_BFIN_SEQSTAT_REGNUM,
+  SIM_BFIN_SYSCFG_REGNUM,
+  SIM_BFIN_RETI_REGNUM,
+  SIM_BFIN_RETX_REGNUM,
+  SIM_BFIN_RETN_REGNUM,
+  SIM_BFIN_RETE_REGNUM,
+  SIM_BFIN_PC_REGNUM,
+  SIM_BFIN_CC_REGNUM,
+  SIM_BFIN_EXTRA1,
+  SIM_BFIN_EXTRA2,
+  SIM_BFIN_EXTRA3,
+  SIM_BFIN_IPEND_REGNUM
+};
+
diff -Naur gdb-6.5.orig/sim/bfin/acconfig.h gdb-6.5/sim/bfin/acconfig.h
--- gdb-6.5.orig/sim/bfin/acconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/sim/bfin/acconfig.h	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,15 @@
+
+/* Define to 1 if NLS is requested.  */
+#undef ENABLE_NLS
+
+/* Define as 1 if you have catgets and don't want to use GNU gettext.  */
+#undef HAVE_CATGETS
+
+/* Define as 1 if you have gettext and don't want to use GNU gettext.  */
+#undef HAVE_GETTEXT
+
+/* Define as 1 if you have the stpcpy function.  */
+#undef HAVE_STPCPY
+
+/* Define if your locale.h file contains LC_MESSAGES.  */
+#undef HAVE_LC_MESSAGES
diff -Naur gdb-6.5.orig/sim/bfin/bfin-dis.c gdb-6.5/sim/bfin/bfin-dis.c
--- gdb-6.5.orig/sim/bfin/bfin-dis.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/sim/bfin/bfin-dis.c	2009-01-22 08:21:17.000000000 +0100
@@ -0,0 +1,3095 @@
+/* Simulator for Analog Devices Blackfin processer.
+
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Analog Devices.
+
+   This file is part of simulators.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+
+#include "opcode/bfin.h"
+#include "bfin-sim.h"
+
+/* HACK: Work around mingw32 lacking SIGTRAP */
+#ifdef _WIN32
+#ifndef SIGTRAP
+#define SIGTRAP 5
+#endif
+#endif
+
+#define M_S2RND 1
+#define M_T     2
+#define M_W32   3
+#define M_FU    4
+#define M_TFU   6
+#define M_IS    8
+#define M_ISS2  9
+#define M_IH    11
+#define M_IU    12
+
+#define HOST_LONG_WORD_SIZE (sizeof(long)*8)
+
+#define SIGNEXTEND(v, n) (((bs32)v << (HOST_LONG_WORD_SIZE - (n))) >> (HOST_LONG_WORD_SIZE - (n)))
+
+/* For dealing with parallel instructions, we must avoid changing our register
+   file until all parallel insns have been simulated.  This queue of stores
+   can be used to delay a modification.
+   @@@ Should go and convert all 32 bit insns to use this.  */
+struct store {
+  bu32 *addr;
+  bu32 val;
+};
+
+struct store stores[10];
+int n_stores;
+
+#define STORE(X,Y) do { \
+    stores[n_stores].addr = &(X); \
+    stores[n_stores++].val = (Y); \
+  } while (0)
+
+static __attribute__ ((noreturn)) void
+unhandled_instruction (char *insn)
+{
+  fprintf(stderr, "Unhandled instruction \"%s\" ... aborting\n", insn);
+  raise (SIGILL);
+  abort ();
+}
+
+static __attribute__ ((noreturn)) void
+illegal_instruction ()
+{
+  fprintf(stderr, "Illegal instruction ... aborting\n");
+  raise (SIGILL);
+  abort ();
+}
+
+static void
+setflags_nz (bu32 val)
+{
+  saved_state.az = val == 0;
+  saved_state.an = val >> 31;
+}
+
+static void
+setflags_nz_2x16 (bu32 val)
+{
+  saved_state.an = (bs16)val < 0 || (bs16)(val >> 16) < 0;
+  saved_state.az = (bs16)val == 0 || (bs16)(val >> 16) == 0;
+}
+
+static void
+setflags_logical (bu32 val)
+{
+  setflags_nz (val);
+  saved_state.ac0 = 0;
+  saved_state.v = 0;
+}
+
+static int
+dagadd (int dagno, bs32 modify)
+{
+  bs32 i, l, b, val;
+
+  i = IREG (dagno);
+  l = LREG (dagno);
+  b = BREG (dagno);
+  val = i;
+
+  if (l)
+    {
+      if (i + modify - b - l < 0 && modify > 0
+	  || i + modify - b >= 0 && modify < 0
+	  || modify == 0)
+	val = i + modify;
+      else if (i + modify - b - l >= 0 && modify > 0)
+	val = i + modify - l;
+      else if (i + modify - b < 0 && modify < 0)
+	val = i + modify + l;
+    }
+  else
+    val = i + modify;
+
+  STORE (IREG (dagno), val);
+  return val;
+}
+
+static int
+dagsub (int dagno, bs32 modify)
+{
+  bs32 i, l, b, val;
+
+  i = IREG (dagno);
+  l = LREG (dagno);
+  b = BREG (dagno);
+  val = i;
+
+  if (l)
+    {
+      if (i - modify - b - l < 0 && modify < 0
+	  || i - modify - b >= 0 && modify > 0
+	  || modify == 0)
+	val = i - modify;
+      else if (i - modify - b - l >= 0 && modify < 0)
+	val = i - modify - l;
+      else if (i - modify - b < 0 && modify > 0)
+	val = i - modify + l;
+    }
+  else
+    val = i - modify;
+
+  STORE (IREG (dagno), val);
+  return val;
+}
+
+static bu32
+ashiftrt (bu32 val, int cnt, int size)
+{
+  int real_cnt = cnt > size ? size : cnt;
+  bu32 sgn = ~((val >> (size - 1)) - 1);
+  int sgncnt = size - real_cnt;
+  if (sgncnt > 16)
+    sgn <<= 16, sgncnt -= 16;
+  sgn <<= sgncnt;
+  if (real_cnt > 16)
+    val >>= 16, real_cnt -= 16;
+  val >>= real_cnt;
+  val |= sgn;
+  saved_state.an = val >> (size - 1);
+  saved_state.az = val == 0;
+  /* @@@ */
+  saved_state.v = 0;
+  return val;
+}
+
+static bu32
+lshiftrt (bu32 val, int cnt, int size)
+{
+  int real_cnt = cnt > size ? size : cnt;
+  if (real_cnt > 16)
+    val >>= 16, real_cnt -= 16;
+  val >>= real_cnt;
+  saved_state.an = val >> (size - 1);
+  saved_state.az = val == 0;
+  saved_state.v = 0;
+  return val;
+}
+
+static bu32
+lshift (bu32 val, int cnt, int size, int saturate)
+{
+  int real_cnt = cnt > size ? size : cnt;
+  int mask_cnt = size - real_cnt;
+  bu32 sgn = ~((val >> (size - 1)) - 1);
+  bu32 masked;
+  bu32 mask = ~0;
+  if (mask_cnt > 16)
+    mask <<= 16, sgn <<= 16, mask_cnt -= 16;
+  mask <<= mask_cnt;
+  sgn <<= mask_cnt;
+  masked = val & mask;
+
+  if (real_cnt > 16)
+    val <<= 16, real_cnt -= 16;
+  val <<= real_cnt;
+  if (saturate && sgn != masked)
+    {
+      if (size == 32)
+	val = sgn == 0 ? 0x7fffffff : 0x80000000;
+      else
+	val = sgn == 0 ? 0x7fff : 0x8000;
+    }
+  saved_state.an = val >> (size - 1);
+  saved_state.az = val == 0;
+  saved_state.v = 0;
+  return val;
+}
+
+static bu32
+add32 (bu32 a, bu32 b, int carry, int sat)
+{
+  int flgs = a >> 31;
+  int flgo = b >> 31;
+  bu32 v = a + b;
+  int flgn = v >> 31;
+  int overflow = (flgs ^ flgn) & (flgo ^ flgn);
+  if (sat && overflow)
+    {
+      v = flgn ? 0x7fffffff : 0x80000000;
+      /* Saturating insns are documented as not setting overflow.  */
+      overflow = 0;
+    }
+  saved_state.an = flgn;
+  saved_state.vs |= overflow;
+  saved_state.v = overflow;
+  saved_state.v_internal |= overflow;
+  saved_state.az = v == 0;
+  if (carry)
+    saved_state.ac0 = ~a < b;
+  return v;
+}
+
+static bu32
+sub32 (bu32 a, bu32 b, int carry, int sat)
+{
+  int flgs = a >> 31;
+  int flgo = b >> 31;
+  bu32 v = a - b;
+  int flgn = v >> 31;
+  int overflow = (flgs ^ flgo) & (flgn ^ flgs);
+  if (sat && overflow)
+    {
+      v = flgn ? 0x7fffffff : 0x80000000;
+      /* Saturating insns are documented as not setting overflow.  */
+      overflow = 0;
+    }
+  saved_state.an = flgn;
+  saved_state.vs |= overflow;
+  saved_state.v = overflow;
+  saved_state.v_internal |= overflow;
+  saved_state.az = v == 0;
+  if (carry)
+    saved_state.ac0 = b <= a;
+  return v;
+}
+
+static bu32
+add16 (bu32 a, bu32 b, int *carry, int sat)
+{
+  int flgs = (a >> 15) & 1;
+  int flgo = (b >> 15) & 1;
+  bu32 v = a + b;
+  int flgn = (v >> 15) & 1;
+  int overflow = (flgs ^ flgn) & (flgo ^ flgn);
+  if (sat && overflow)
+    {
+      v = flgn ? 0x7fff : 0x8000;
+      /* Saturating insns are documented as not setting overflow.  */
+      overflow = 0;
+    }
+  saved_state.an = flgn;
+  saved_state.vs |= overflow;
+  saved_state.v = overflow;
+  saved_state.v_internal |= overflow;
+  saved_state.az = v == 0;
+  if (carry)
+    *carry = (bu16)~a < (bu16)b;
+  return v & 0xffff;
+}
+
+static bu32
+sub16 (bu32 a, bu32 b, int *carry, int sat)
+{
+  int flgs = (a >> 15) & 1;
+  int flgo = (b >> 15) & 1;
+  bu32 v = a - b;
+  int flgn = (v >> 15) & 1;
+  int overflow = (flgs ^ flgo) & (flgn ^ flgs);
+  if (sat && overflow)
+    {
+      v = flgn ? 0x7fff : 0x8000;
+      /* Saturating insns are documented as not setting overflow.  */
+      overflow = 0;
+    }
+  saved_state.an = flgn;
+  saved_state.vs |= overflow;
+  saved_state.v = overflow;
+  saved_state.v_internal |= overflow;
+  saved_state.az = v == 0;
+  if (carry)
+    *carry = (bu16)b <= (bu16)a;
+  return v;
+}
+
+static bu32
+addadd16 (bu32 a, bu32 b, int sat, int x)
+{
+  int c0 = 0, c1 = 0;
+  bu32 x0, x1;
+  x0 = add16 ((a >> 16) & 0xffff, (b >> 16) & 0xffff, &c0, sat) & 0xffff;
+  x1 = add16 (a & 0xffff, b & 0xffff, &c1, sat) & 0xffff;
+  if (x == 0)
+    return (x0 << 16) | x1;
+  else
+    return (x1 << 16) | x0;
+}
+
+static bu32
+subsub16 (bu32 a, bu32 b, int sat, int x)
+{
+  int c0 = 0, c1 = 0;
+  bu32 x0, x1;
+  x0 = sub16 ((a >> 16) & 0xffff, (b >> 16) & 0xffff, &c0, sat) & 0xffff;
+  x1 = sub16 (a & 0xffff, b & 0xffff, &c1, sat) & 0xffff;
+  if (x == 0)
+    return (x0 << 16) | x1;
+  else
+    return (x1 << 16) | x0;
+}
+
+static bu32
+min32 (bu32 a, bu32 b)
+{
+  int val = a;
+  if ((bs32)a > (bs32)b)
+    val = b;
+  setflags_nz (val);
+  saved_state.v = 0;
+  return val;
+}
+
+static bu32
+max32 (bu32 a, bu32 b)
+{
+  int val = a;
+  if ((bs32)a < (bs32)b)
+    val = b;
+  setflags_nz (val);
+  saved_state.v = 0;
+  return val;
+}
+
+static bu32
+min2x16 (bu32 a, bu32 b)
+{
+  int val = a;
+  if ((bs16)a > (bs16)b)
+    val = (val & 0xFFFF0000) | (b & 0xFFFF);
+  if ((bs16)(a >> 16) > (bs16)(b >> 16))
+    val = (val & 0xFFFF) | (b & 0xFFFF0000);
+  setflags_nz_2x16 (val);
+  saved_state.v = 0;
+  return val;
+}
+
+static bu32
+max2x16 (bu32 a, bu32 b)
+{
+  int val = a;
+  if ((bs16)a < (bs16)b)
+    val = (val & 0xFFFF0000) | (b & 0xFFFF);
+  if ((bs16)(a >> 16) < (bs16)(b >> 16))
+    val = (val & 0xFFFF) | (b & 0xFFFF0000);
+  setflags_nz_2x16 (val);
+  saved_state.v = 0;
+  return val;
+}
+
+static bu32
+add_and_shift (bu32 a, bu32 b, int shift)
+{
+  int v;
+  saved_state.v_internal = 0;
+  v = add32 (a, b, 0, 0);
+  while (shift-- > 0)
+    {
+      int x = v >> 30;
+      if (x == 1 || x == 2)
+	saved_state.v_internal = 1;
+      v <<= 1;
+    }
+  saved_state.v = saved_state.v_internal;
+  saved_state.vs |= saved_state.v;
+  return v;
+}
+
+typedef enum
+{
+  c_0, c_1, c_4, c_2, c_uimm2, c_uimm3, c_imm3, c_pcrel4,
+  c_imm4, c_uimm4s4, c_uimm4, c_uimm4s2, c_negimm5s4, c_imm5, c_uimm5, c_imm6,
+  c_imm7, c_imm8, c_uimm8, c_pcrel8, c_uimm8s4, c_pcrel8s4, c_lppcrel10,
+    c_pcrel10,
+  c_pcrel12, c_imm16s4, c_luimm16, c_imm16, c_huimm16, c_rimm16, c_imm16s2,
+    c_uimm16s4,
+  c_uimm16, c_pcrel24,
+} const_forms_t;
+
+static struct
+{
+  char *name;
+  int nbits;
+  char reloc;
+  char issigned;
+  char pcrel;
+  char scale;
+  char offset;
+  char negative;
+  char positive;
+} constant_formats[] =
+{
+  { "0", 0, 0, 1, 0, 0, 0, 0, 0},
+  { "1", 0, 0, 1, 0, 0, 0, 0, 0},
+  { "4", 0, 0, 1, 0, 0, 0, 0, 0},
+  { "2", 0, 0, 1, 0, 0, 0, 0, 0},
+  { "uimm2", 2, 0, 0, 0, 0, 0, 0, 0},
+  { "uimm3", 3, 0, 0, 0, 0, 0, 0, 0},
+  { "imm3", 3, 0, 1, 0, 0, 0, 0, 0},
+  { "pcrel4", 4, 1, 0, 1, 1, 0, 0, 0},
+  { "imm4", 4, 0, 1, 0, 0, 0, 0, 0},
+  { "uimm4s4", 4, 0, 0, 0, 2, 0, 0, 1},
+  { "uimm4", 4, 0, 0, 0, 0, 0, 0, 0},
+  { "uimm4s2", 4, 0, 0, 0, 1, 0, 0, 1},
+  { "negimm5s4", 5, 0, 1, 0, 2, 0, 1, 0},
+  { "imm5", 5, 0, 1, 0, 0, 0, 0, 0},
+  { "uimm5", 5, 0, 0, 0, 0, 0, 0, 0},
+  { "imm6", 6, 0, 1, 0, 0, 0, 0, 0},
+  { "imm7", 7, 0, 1, 0, 0, 0, 0, 0},
+  { "imm8", 8, 0, 1, 0, 0, 0, 0, 0},
+  { "uimm8", 8, 0, 0, 0, 0, 0, 0, 0},
+  { "pcrel8", 8, 1, 0, 1, 1, 0, 0, 0},
+  { "uimm8s4", 8, 0, 0, 0, 2, 0, 0, 0},
+  { "pcrel8s4", 8, 1, 1, 1, 2, 0, 0, 0},
+  { "lppcrel10", 10, 1, 0, 1, 1, 0, 0, 0},
+  { "pcrel10", 10, 1, 1, 1, 1, 0, 0, 0},
+  { "pcrel12", 12, 1, 1, 1, 1, 0, 0, 0},
+  { "imm16s4", 16, 0, 1, 0, 2, 0, 0, 0},
+  { "luimm16", 16, 1, 0, 0, 0, 0, 0, 0},
+  { "imm16", 16, 0, 1, 0, 0, 0, 0, 0},
+  { "huimm16", 16, 1, 0, 0, 0, 0, 0, 0},
+  { "rimm16", 16, 1, 1, 0, 0, 0, 0, 0},
+  { "imm16s2", 16, 0, 1, 0, 1, 0, 0, 0},
+  { "uimm16s4", 16, 0, 0, 0, 2, 0, 0, 0},
+  { "uimm16", 16, 0, 0, 0, 0, 0, 0, 0},
+  { "pcrel24", 24, 1, 1, 1, 1, 0, 0, 0},};
+
+static bu32
+fmtconst (const_forms_t cf, bu32 x, bu32 pc)
+{
+  if (0 && constant_formats[cf].reloc)
+    {
+      bu32 ea = (((constant_formats[cf].pcrel
+		   ? SIGNEXTEND (x, constant_formats[cf].nbits)
+		   : x) + constant_formats[cf].offset)
+		 << constant_formats[cf].scale);
+      if (constant_formats[cf].pcrel)
+	ea += pc;
+
+      return ea;
+    }
+
+  /* Negative constants have an implied sign bit.  */
+  if (constant_formats[cf].negative)
+    {
+      int nb = constant_formats[cf].nbits + 1;
+      x = x | (1 << constant_formats[cf].nbits);
+      x = SIGNEXTEND (x, nb);
+    }
+  else if (constant_formats[cf].issigned)
+    x = SIGNEXTEND (x, constant_formats[cf].nbits);
+
+  x += constant_formats[cf].offset;
+  x <<= constant_formats[cf].scale;
+
+  return x;
+}
+
+#define uimm16s4(x) fmtconst(c_uimm16s4, x, 0)
+#define pcrel4(x) fmtconst(c_pcrel4, x, pc)
+#define pcrel8(x) fmtconst(c_pcrel8, x, pc)
+#define pcrel8s4(x) fmtconst(c_pcrel8s4, x, pc)
+#define pcrel10(x) fmtconst(c_pcrel10, x, pc)
+#define pcrel12(x) fmtconst(c_pcrel12, x, pc)
+#define negimm5s4(x) fmtconst(c_negimm5s4, x, 0)
+#define rimm16(x) fmtconst(c_rimm16, x, 0)
+#define huimm16(x) fmtconst(c_huimm16, x, 0)
+#define imm16(x) fmtconst(c_imm16, x, 0)
+#define uimm2(x) fmtconst(c_uimm2, x, 0)
+#define uimm3(x) fmtconst(c_uimm3, x, 0)
+#define luimm16(x) fmtconst(c_luimm16, x, 0)
+#define uimm4(x) fmtconst(c_uimm4, x, 0)
+#define uimm5(x) fmtconst(c_uimm5, x, 0)
+#define imm16s2(x) fmtconst(c_imm16s2, x, 0)
+#define uimm8(x) fmtconst(c_uimm8, x, 0)
+#define imm16s4(x) fmtconst(c_imm16s4, x, 0)
+#define uimm4s2(x) fmtconst(c_uimm4s2, x, 0)
+#define uimm4s4(x) fmtconst(c_uimm4s4, x, 0)
+#define lppcrel10(x) fmtconst(c_lppcrel10, x, pc)
+#define imm3(x) fmtconst(c_imm3, x, 0)
+#define imm4(x) fmtconst(c_imm4, x, 0)
+#define uimm8s4(x) fmtconst(c_uimm8s4, x, 0)
+#define imm5(x) fmtconst(c_imm5, x, 0)
+#define imm6(x) fmtconst(c_imm6, x, 0)
+#define imm7(x) fmtconst(c_imm7, x, 0)
+#define imm8(x) fmtconst(c_imm8, x, 0)
+#define pcrel24(x) fmtconst(c_pcrel24, x, pc)
+#define uimm16(x) fmtconst(c_uimm16, x, 0)
+
+static bu32 *
+get_allreg (int grp, int reg)
+{
+  int fullreg = (grp << 3) | reg;
+  /* REG_R0, REG_R1, REG_R2, REG_R3, REG_R4, REG_R5, REG_R6, REG_R7,
+     REG_P0, REG_P1, REG_P2, REG_P3, REG_P4, REG_P5, REG_SP, REG_FP,
+     REG_I0, REG_I1, REG_I2, REG_I3, REG_M0, REG_M1, REG_M2, REG_M3,
+     REG_B0, REG_B1, REG_B2, REG_B3, REG_L0, REG_L1, REG_L2, REG_L3,
+     REG_A0x, REG_A0w, REG_A1x, REG_A1w, , , REG_ASTAT, REG_RETS,
+     , , , , , , , ,
+     REG_LC0, REG_LT0, REG_LB0, REG_LC1, REG_LT1, REG_LB1, REG_CYCLES,
+     REG_CYCLES2,
+     REG_USP, REG_SEQSTAT, REG_SYSCFG, REG_RETI, REG_RETX, REG_RETN, REG_RETE,
+     REG_LASTREG */
+  switch (fullreg >> 2)
+    {
+    case 0: case 1: return &DREG (reg); break;
+    case 2: case 3: return &PREG (reg); break;
+    case 4: return &IREG (reg & 3); break;
+    case 5: return &MREG (reg & 3); break;
+    case 6: return &BREG (reg & 3); break;
+    case 7: return &LREG (reg & 3); break;
+    default:
+      switch (fullreg)
+	{	
+	case 32: return &saved_state.a0x;
+	case 33: return &saved_state.a0w;
+	case 34: return &saved_state.a1x;
+	case 35: return &saved_state.a1w;
+	case 39: return &saved_state.rets;
+	case 48: return &LC0REG;
+	case 49: return &LT0REG;
+	case 50: return &LB0REG;
+	case 51: return &LC1REG;
+	case 52: return &LT1REG;
+	case 53: return &LB1REG;
+	}
+      return 0;
+    }
+}
+
+/* Perform a multiplication, sign- or zero-extending the result to 64 bit.  */
+static bu64
+decode_multfunc (int h0, int h1, int src0, int src1, int mmod, int MM)
+{
+  bu32 s0 = DREG (src0), s1 = DREG (src1);
+  bu32 sgn0, sgn1;
+  bu32 val;
+  bu64 val1;
+
+  if (h0)
+    s0 >>= 16;
+
+  if (h1)
+    s1 >>= 16;
+
+  s0 &= 0xffff;
+  s1 &= 0xffff;
+
+  sgn0 = -(s0 & 0x8000);
+  sgn1 = -(s1 & 0x8000);
+
+  if (MM)
+    s0 |= sgn0;
+  else switch (mmod)
+    {
+    case 0:
+    case M_S2RND:
+    case M_T:
+    case M_IS:
+    case M_ISS2:
+    case M_IH:
+      s0 |= sgn0;
+      s1 |= sgn1;
+      break;
+    case M_FU:
+    case M_IU:
+    case M_TFU:
+      break;
+    default:
+      abort ();
+    }
+
+  val = s0 * s1;
+  /* Perform shift correction if appropriate for the mode.  */
+  if (mmod == 0 || mmod == M_T || mmod == M_S2RND)
+    {
+      if (val == 0x40000000)
+	val = 0x7fffffff;
+      else
+	val <<= 1;
+    }
+
+  val1 = val;
+  if (mmod == 0 || mmod == M_IS || mmod == M_T || mmod == M_S2RND
+      || mmod == M_ISS2 || mmod == M_IH)
+    val1 |= -(val1 & 0x80000000);
+
+  return val1;
+}
+
+static bu32
+saturate_s32 (bu64 val)
+{
+  if ((bs64)val < -0x80000000ll)
+    return 0x80000000;
+  if ((bs64)val > 0x7fffffff)
+    return 0x7fffffff;
+  return val;
+}
+
+static bu32
+saturate_s16 (bu64 val)
+{
+  if ((bs64)val < -0x8000ll)
+    return 0x8000;
+  if ((bs64)val > 0x7fff)
+    return 0x7fff;
+  return val & 0xffff;
+}
+
+static bu32
+saturate_u32 (bu64 val)
+{
+  if (val > 0xffffffff)
+    return 0xffffffff;
+  return val;
+}
+
+static bu32
+saturate_u16 (bu64 val)
+{
+  if (val > 0xffff)
+    return 0xffff;
+  return val;
+}
+
+static bu64
+rnd16 (bu64 val)
+{
+  bu64 sgnbits;
+
+  /* FIXME: Should honour rounding mode.  */
+  if ((val & 0xffff) > 0x8000
+      || ((val & 0xffff) == 0x8000 && (val & 0x10000)))
+    val += 0x8000;
+
+  sgnbits = val & 0xffff000000000000ull;
+  val >>= 16;
+  return val | sgnbits;
+}
+
+static bu64
+trunc16 (bu64 val)
+{
+  bu64 sgnbits = val & 0xffff000000000000ull;
+  val >>= 16;
+  return val | sgnbits;
+}
+
+static int
+signbits (bu64 val, int size)
+{
+  bu64 mask = (bu64)1 << (size - 1);
+  bu64 bit = val & mask;
+  int count = 0;
+  for (;;)
+    {
+      mask >>= 1;
+      bit >>= 1;
+      if (mask == 0)
+	return count;
+      if ((val & mask) != bit)
+	return count;
+      count++;
+    }
+}
+
+/* Extract a 16 or 32 bit value from a 64 bit multiplication result.
+   These 64 bits must be sign- or zero-extended properly from the source
+   we want to extract, either a 32 bit multiply or a 40 bit accumulator.  */
+
+static bu32
+extract_mult (bu64 res, int mmod, int fullword)
+{
+  if (fullword)
+    switch (mmod)
+      {
+      case 0:
+      case M_IS:
+	return saturate_s32 (res);
+      case M_FU:
+	return saturate_u32 (res);
+      case M_S2RND:
+      case M_ISS2:
+	return saturate_s32 (res << 1);
+      default:
+	abort ();
+      }
+  else
+    switch (mmod)
+      {
+      case 0:
+      case M_IH:
+	return saturate_s16 (rnd16 (res));
+      case M_IS:
+	return saturate_s16 (res);
+      case M_FU:
+	return saturate_u16 (rnd16 (res));
+      case M_IU:
+	return saturate_u16 (res);
+
+      case M_T:
+	return saturate_s16 (trunc16 (res));
+      case M_TFU:
+	return saturate_u16 (trunc16 (res));
+
+      case M_S2RND:
+	return saturate_s16 (rnd16 (res << 1));
+      case M_ISS2:
+	return saturate_s16 (res << 1);
+      default:
+	abort ();
+      }
+}
+
+static bu32
+decode_macfunc (int which, int op, int h0, int h1, int src0, int src1,
+		int mmod, int MM, int fullword)
+{
+  bu32 *ax, *aw;
+  bu64 acc;
+ 
+  ax = which ? &A1XREG : &A0XREG;
+  aw = which ? &A1WREG : &A0WREG;
+  acc = (((bu64)*ax << 32) | ((bu64)*aw)) & 0xFFFFFFFFFFull;
+
+  /* Sign extend accumulator if necessary.  */
+  if (mmod == 0 || mmod == M_T || mmod == M_IS || mmod == M_ISS2
+      || mmod == M_S2RND)
+    acc |= -(acc & 0x80000000);
+
+  if (op != 3)
+    {
+      bu64 res = decode_multfunc (h0, h1, src0, src1, mmod, MM);
+
+      /* Perform accumulation.  */
+      switch (op)
+	{
+	case 0:
+	  acc = res;
+	  break;
+	case 1:
+	  acc = acc + res;
+	  break;
+	case 2:
+	  acc = acc - res;
+	  break;
+	}
+
+      /* Saturate.  */
+      switch (mmod)
+	{
+	case 0:
+	case M_T:
+	case M_IS:
+	case M_ISS2:
+	case M_S2RND:
+	  if ((bs64)acc < -0x8000000000ll)
+	    acc = -0x8000000000ull;
+	  else if ((bs64)acc >= 0x7fffffffffll)
+	    acc = 0x7fffffffffull;
+	  break;
+	case M_TFU:
+	case M_FU:
+	case M_IU:
+	  if (acc > 0xFFFFFFFFFFull)
+	    acc = 0xFFFFFFFFFFull;
+	  break;
+	default:
+	  abort ();
+	}
+    }
+
+  if (which)
+    {
+      STORE (A1XREG, (acc >> 32) & 0xff);
+      STORE (A1WREG, acc & 0xffffffff);
+    }
+  else
+    {
+      STORE (A0XREG, (acc >> 32) & 0xff);
+      STORE (A0WREG, acc & 0xffffffff);
+    }
+
+  return extract_mult (acc, mmod, fullword);
+}
+
+static void
+decode_ProgCtrl_0 (bu16 iw0)
+{
+  /* ProgCtrl
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |.prgfunc.......|.poprnd........|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int poprnd = ((iw0 >> 0) & 0xf);
+  int prgfunc = ((iw0 >> 4) & 0xf);
+
+  if (prgfunc == 0 && poprnd == 0)
+    /* NOP */
+    PCREG += 2;
+  else if (prgfunc == 1 && poprnd == 0)
+    /* RTS */
+    PCREG = saved_state.rets;
+  else if (prgfunc == 1 && poprnd == 1)
+    unhandled_instruction ("RTI");
+  else if (prgfunc == 1 && poprnd == 2)
+    unhandled_instruction ("RTX");
+  else if (prgfunc == 1 && poprnd == 3)
+    unhandled_instruction ("RTN");
+  else if (prgfunc == 1 && poprnd == 4)
+    unhandled_instruction ("RTE");
+  else if (prgfunc == 2 && poprnd == 0)
+    unhandled_instruction ("IDLE");
+  else if (prgfunc == 2 && poprnd == 3)
+    unhandled_instruction ("CSYNC");
+  else if (prgfunc == 2 && poprnd == 4)
+    unhandled_instruction ("SSYNC");
+  else if (prgfunc == 2 && poprnd == 5)
+    unhandled_instruction ("EMUEXCPT");
+  else if (prgfunc == 3)
+    unhandled_instruction ("CLI dregs");
+  else if (prgfunc == 4)
+    unhandled_instruction ("STI dregs");
+  else if (prgfunc == 5)
+    {
+      /* JUMP (pregs) */
+      PCREG = PREG (poprnd);
+      did_jump = 1;
+    }
+  else if (prgfunc == 6)
+    {
+      /* CALL (pregs) */
+      saved_state.rets = PCREG + 2;
+      PCREG = PREG (poprnd);
+      did_jump = 1;
+    }
+  else if (prgfunc == 7)
+    {
+      /* CALL (PC + pregs) */
+      saved_state.rets = PCREG + 2;
+      PCREG = PCREG + PREG (poprnd);
+      did_jump = 1;
+    }
+  else if (prgfunc == 8)
+    {
+      /* JUMP (PC + pregs) */
+      PCREG = PCREG + PREG (poprnd);
+      did_jump = 1;
+    }
+  else if (prgfunc == 9)
+    {
+      /* RAISE uimm4 */
+      bfin_trap ();
+      PCREG += 2;
+    }
+  else if (prgfunc == 10)
+    {
+      /* EXCPT uimm4 */
+      if(uimm4 (poprnd) == 1)
+        raise_exception(SIGTRAP);
+      else
+	unhandled_instruction ("unhandled exception");
+    }
+  else if (prgfunc == 11)
+    unhandled_instruction ("TESTSET");
+  else
+    illegal_instruction ();
+}
+
+static void
+decode_CaCTRL_0 (bu16 iw0)
+{
+  /* CaCTRL
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1 |.a.|.op....|.reg.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int a = ((iw0 >> 5) & 0x1);
+  int reg = ((iw0 >> 0) & 0x7);
+  int op = ((iw0 >> 3) & 0x3);
+
+  if (a == 0 && op == 0)
+    unhandled_instruction ("PREFETCH [pregs]");
+  else if (a == 0 && op == 1)
+    unhandled_instruction ("FLUSHINV [pregs]");
+  else if (a == 0 && op == 2)
+    unhandled_instruction ("FLUSH [pregs]");
+  else if (a == 0 && op == 3)
+    unhandled_instruction ("IFLUSH [pregs]");
+  else if (a == 1 && op == 0)
+    unhandled_instruction ("PREFETCH [pregs++]");
+  else if (a == 1 && op == 1)
+    unhandled_instruction ("FLUSHINV [pregs++]");
+  else if (a == 1 && op == 2)
+    unhandled_instruction ("FLUSH [pregs++]");
+  else if (a == 1 && op == 3)
+    unhandled_instruction ("IFLUSH [pregs++]");
+  else
+    illegal_instruction ();
+
+  PCREG += 2;
+}
+
+static void
+decode_PushPopReg_0 (bu16 iw0)
+{
+  /* PushPopReg
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 |.W.|.grp.......|.reg.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int grp = ((iw0 >> 3) & 0x7);
+  int reg = ((iw0 >> 0) & 0x7);
+  int W = ((iw0 >> 6) & 0x1);
+  bu32 *whichreg = get_allreg (grp, reg);
+
+  if (whichreg == 0)
+    unhandled_instruction ("push/pop");
+
+  if (W == 0)
+    {
+      /* allregs = [SP++] */
+      *whichreg = get_long (saved_state.memory, PREG (6));
+      PREG (6) += 4;
+    }
+  else
+    {
+      /* [--SP] = allregs */
+      PREG (6) -= 4;
+      put_long (saved_state.memory, PREG (6), *whichreg);
+    }
+  PCREG += 2;
+}
+
+static void
+decode_PushPopMultiple_0 (bu16 iw0)
+{
+  /* PushPopMultiple
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 0 | 0 | 0 | 0 | 1 | 0 |.d.|.p.|.W.|.dr........|.pr........|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int p = ((iw0 >> 7) & 0x1);
+  int pr = ((iw0 >> 0) & 0x7);
+  int d = ((iw0 >> 8) & 0x1);
+  int dr = ((iw0 >> 3) & 0x7);
+  int W = ((iw0 >> 6) & 0x1);
+  int i;
+  bu32 sp = PREG (6);
+
+  if ((d == 0 && p == 0)
+      || (p && imm5 (pr) > 5))
+    illegal_instruction ();
+
+  if (W == 1)
+    {
+      if (d)
+	for (i = dr; i < 8; i++)
+	  {
+	    sp -= 4;
+	    put_long (saved_state.memory, sp, DREG (i));
+	  }
+      if (p)
+	for (i = pr; i < 6; i++)
+	  {
+	    sp -= 4;
+	    put_long (saved_state.memory, sp, PREG (i));
+	  }
+    }
+  else
+    {
+      if (p)
+	for (i = 5; i >= pr; i--)
+	  {
+	    PREG (i) = get_long (saved_state.memory, sp);
+	    sp += 4;
+	  }
+      if (d)
+	for (i = 7; i >= dr; i--)
+	  {
+	    DREG (i) = get_long (saved_state.memory, sp);
+	    sp += 4;
+	  }
+    }      
+  PREG (6) = sp;
+  PCREG += 2;
+}
+
+static void
+decode_ccMV_0 (bu16 iw0)
+{
+  /* ccMV
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 0 | 0 | 0 | 0 | 1 | 1 |.T.|.d.|.s.|.dst.......|.src.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int src = ((iw0 >> 0) & 0x7);
+  int dst = ((iw0 >> 3) & 0x7);
+  int s = ((iw0 >> 6) & 0x1);
+  int d = ((iw0 >> 7) & 0x1);
+  int T = ((iw0 >> 8) & 0x1);
+  int cond = T ? CCREG : ! CCREG;
+  if (cond)
+    GREG (dst, d) = GREG (src, s);
+  PCREG += 2;
+}
+
+static void
+decode_CCflag_0 (bu16 iw0)
+{
+  /* CCflag
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 0 | 0 | 0 | 1 |.I.|.opc.......|.G.|.y.........|.x.........|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int x = ((iw0 >> 0) & 0x7);
+  int y = ((iw0 >> 3) & 0x7);
+  int I = ((iw0 >> 10) & 0x1);
+  int opc = ((iw0 >> 7) & 0x7);
+  int G = ((iw0 >> 6) & 0x1);
+
+  if (opc > 4)
+    {
+      if (opc == 5 && I == 0 && G == 0)
+	unhandled_instruction ("CC = A0 == A1");
+      else if (opc == 6 && I == 0 && G == 0)
+	unhandled_instruction ("CC = A0 < A1");
+      else if (opc == 7 && I == 0 && G == 0)
+	unhandled_instruction ("CC = A0 <= A1");
+    }
+  else
+    {
+      int issigned = opc < 3;
+      bu32 srcop = G ? PREG (x) : DREG (x);
+      bu32 dstop = I ? (issigned ? imm3 (y) : uimm3 (y)) : G ? PREG (y) : DREG (y);
+      int flgs = srcop >> 31;
+      int flgo = dstop >> 31;
+
+      bu32 result = srcop - dstop;
+      int flgn = result >> 31;
+      int overflow = (flgs ^ flgo) & (flgn ^ flgs);
+
+      saved_state.az = result == 0;
+      saved_state.an = flgn;
+      saved_state.ac0 = srcop < dstop;
+      switch (opc)
+	{
+	case 0: /* == */
+	  CCREG = saved_state.az;
+	  break;
+	case 1: /* <, signed */
+	  CCREG = (flgn && !overflow) || (!flgn && overflow);
+	  break;
+	case 2: /* <=, signed */
+	  CCREG = (flgn && !overflow) || (!flgn && overflow) || saved_state.az;
+	  break;
+	case 3: /* <, unsigned */
+	  CCREG = saved_state.ac0;
+	  break;
+	case 4: /* <=, unsigned */
+	  CCREG = saved_state.ac0 | saved_state.az;
+	  break;
+	}
+    }
+  PCREG += 2;
+}
+
+static void
+decode_CC2dreg_0 (bu16 iw0)
+{
+  /* CC2dreg
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |.op....|.reg.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int reg = ((iw0 >> 0) & 0x7);
+  int op = ((iw0 >> 3) & 0x3);
+
+  if (op == 0)
+    /* dregs = CC */
+    DREG (reg) = CCREG;
+  else if (op == 1)
+    /* CC = dregs */
+    CCREG = DREG (reg) != 0;
+  else if (op == 3)
+    /* CC = !CC */
+    CCREG = !CCREG;
+  else
+    illegal_instruction ();
+  PCREG += 2;
+}
+
+static void
+decode_CC2stat_0 (bu16 iw0)
+{
+  /* CC2stat
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |.D.|.op....|.cbit..............|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int cbit = ((iw0 >> 0) & 0x1f);
+  int D = ((iw0 >> 7) & 0x1);
+  int op = ((iw0 >> 5) & 0x3);
+  int *pval;
+
+  switch (cbit)
+    {
+    case 0: pval = &saved_state.az; break;
+    case 1: pval = &saved_state.an; break;
+    case 6: pval = &saved_state.aq; break;
+    case 12: pval = &saved_state.ac0; break;
+    case 13: pval = &saved_state.ac1; break;
+    case 16: pval = &saved_state.av0; break;
+    case 17: pval = &saved_state.av0s; break;
+    case 18: pval = &saved_state.av1; break;
+    case 19: pval = &saved_state.av1s; break;
+    case 24: pval = &saved_state.v; break;
+    case 25: pval = &saved_state.vs; break;
+    default:
+      illegal_instruction ();
+    }
+
+  if (D == 0)
+    switch (op)
+      {
+      case 0: CCREG = *pval; break;
+      case 1: CCREG |= *pval; break;
+      case 2: CCREG &= *pval; break;
+      case 3: CCREG ^= *pval; break;
+      }
+  else
+    switch (op)
+      {
+      case 0: *pval = CCREG; break;
+      case 1: *pval |= CCREG; break;
+      case 2: *pval &= CCREG; break;
+      case 3: *pval ^= CCREG; break;
+      }
+  PCREG += 2;
+}
+
+static void
+decode_BRCC_0 (bu16 iw0, bu32 pc)
+{
+  /* BRCC
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 0 | 0 | 1 |.T.|.B.|.offset................................|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int B = ((iw0 >> 10) & 0x1);
+  int T = ((iw0 >> 11) & 0x1);
+  int offset = ((iw0 >> 0) & 0x3ff);
+
+  /* B is just the branch predictor hint - we can ignore it.  */
+
+  /* IF CC JUMP pcrel10 */
+  if (CCREG == T)
+    {
+      PCREG += pcrel10 (offset);
+      did_jump = 1;
+    }
+  else
+    PCREG += 2;
+}
+
+static void
+decode_UJUMP_0 (bu16 iw0, bu32 pc)
+{
+  /* UJUMP
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 0 | 1 | 0 |.offset........................................|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int offset = ((iw0 >> 0) & 0xfff);
+
+  /* JUMP.S pcrel12 */
+  PCREG += pcrel12 (offset);
+  did_jump = 1;
+}
+
+static void
+decode_REGMV_0 (bu16 iw0)
+{
+  /* REGMV
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 0 | 1 | 1 |.gd........|.gs........|.dst.......|.src.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int src = ((iw0 >> 0) & 0x7);
+  int gs = ((iw0 >> 6) & 0x7);
+  int dst = ((iw0 >> 3) & 0x7);
+  int gd = ((iw0 >> 9) & 0x7);
+  bu32 *srcreg = get_allreg (gs, src);
+  bu32 *dstreg = get_allreg (gd, dst);
+  
+  if (srcreg == 0 || dstreg == 0)
+    unhandled_instruction ("reg move");
+
+  *dstreg = *srcreg;
+  PCREG += 2;
+}
+
+static void
+decode_ALU2op_0 (bu16 iw0)
+{
+  /* ALU2op
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 1 | 0 | 0 | 0 | 0 |.opc...........|.src.......|.dst.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int src = ((iw0 >> 3) & 0x7);
+  int opc = ((iw0 >> 6) & 0xf);
+  int dst = ((iw0 >> 0) & 0x7);
+
+  if (opc == 0)
+    /* dregs >>>= dregs */
+    DREG (dst) = ashiftrt (DREG (dst), DREG (src), 32);
+  else if (opc == 1)
+    /* dregs >>= dregs */
+    DREG (dst) = lshiftrt (DREG (dst), DREG (src), 32);
+  else if (opc == 2)
+    /* dregs <<= dregs */
+    DREG (dst) = lshift (DREG (dst), DREG (src), 32, 0);
+  else if (opc == 3)
+    /* dregs *= dregs */
+    DREG (dst) *= DREG (src);
+  else if (opc == 4)
+    /* dregs = (dregs + dregs) << 1 */
+    DREG (dst) = add_and_shift (DREG (dst), DREG (src), 1);
+  else if (opc == 5)
+    /* dregs = (dregs + dregs) << 2 */
+    DREG (dst) = add_and_shift (DREG (dst), DREG (src), 2);
+  else if (opc == 8)
+    unhandled_instruction ("DIVQ (dregs , dregs)");
+  else if (opc == 9)
+    unhandled_instruction ("DIVS (dregs , dregs)");
+  else if (opc == 10)
+    {
+      /* dregs = dregs_lo (X) */
+      DREG (dst) = (bs32) (bs16) DREG (src);
+      setflags_logical (DREG (dst));
+    }
+  else if (opc == 11)
+    {
+      /* dregs = dregs_lo (Z) */
+      DREG (dst) = (bu32) (bu16) DREG (src);
+      setflags_logical (DREG (dst));
+    }
+  else if (opc == 12)
+    {
+      /* dregs = dregs_byte (X) */
+      DREG (dst) = (bs32) (bs8) DREG (src);
+      setflags_logical (DREG (dst));
+    }
+  else if (opc == 13)
+    {
+      /* dregs = dregs_byte (Z) */
+      DREG (dst) = (bu32) (bu8) DREG (src);
+      setflags_logical (DREG (dst));
+    }
+  else if (opc == 14)
+    {
+      /* dregs = - dregs */
+      bu32 val = DREG (src);
+      DREG (dst) = -val;
+      setflags_nz (DREG (dst));
+      if (val == 0x80000000)
+	saved_state.v = saved_state.vs = 1;
+      /* @@@ Documentation isn't entirely clear about av0 and av1.  */
+    }
+  else if (opc == 15)
+    {
+      /* dregs = ~ dregs */
+      DREG (dst) = ~DREG (src);
+      setflags_logical (DREG (dst));
+    }
+  else
+    illegal_instruction ();
+  PCREG += 2;
+}
+
+static void
+decode_PTR2op_0 (bu16 iw0)
+{
+  /* PTR2op
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 1 | 0 | 0 | 0 | 1 | 0 |.opc.......|.src.......|.dst.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int src = ((iw0 >> 3) & 0x7);
+  int opc = ((iw0 >> 6) & 0x7);
+  int dst = ((iw0 >> 0) & 0x7);
+
+  if (opc == 0)
+    PREG (dst) -= PREG (src);
+  else if (opc == 1)
+    PREG (dst) = PREG (src) << 2;
+  else if (opc == 3)
+    PREG (dst) = PREG (src) >> 2;
+  else if (opc == 4)
+    PREG (dst) = PREG (src) >> 1;
+  else if (opc == 5)
+    unhandled_instruction ("pregs += pregs ( BREV )");
+  else if (opc == 6)
+    PREG (dst) = (PREG (dst) + PREG (src)) << 1;
+  else if (opc == 7)
+    PREG (dst) = (PREG (dst) + PREG (src)) << 2;
+  else
+    illegal_instruction ();
+
+  PCREG += 2;
+}
+
+static void
+decode_LOGI2op_0 (bu16 iw0)
+{
+  /* LOGI2op
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 1 | 0 | 0 | 1 |.opc.......|.src...............|.dst.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int src = ((iw0 >> 3) & 0x1f);
+  int opc = ((iw0 >> 8) & 0x7);
+  int dst = ((iw0 >> 0) & 0x7);
+
+  if (opc == 0)
+    /* CC = ! BITTST (dregs, uimm5) */
+    CCREG = (~DREG (dst) >> uimm5 (src)) & 1;
+  else if (opc == 1)
+    /* CC = BITTST (dregs, uimm5) */
+    CCREG = (DREG (dst) >> uimm5 (src)) & 1;
+  else if (opc == 2)
+    {
+      /* BITSET (dregs, uimm5) */
+      DREG (dst) |= 1 << uimm5 (src);
+      setflags_logical (DREG (dst));
+    }
+  else if (opc == 3)
+    {
+      /* BITTGL (dregs, uimm5) */
+      DREG (dst) ^= 1 << uimm5 (src);
+      setflags_logical (DREG (dst));
+    }
+  else if (opc == 4)
+    {
+      /* BITCLR (dregs, uimm5) */
+      DREG (dst) &= ~(1 << uimm5 (src));
+      setflags_logical (DREG (dst));
+    }
+  else if (opc == 5)
+    /* dregs >>>= uimm5 */
+    DREG (dst) = ashiftrt (DREG (dst), uimm5 (src), 32);
+  else if (opc == 6)
+    /* dregs >>= uimm5 */
+    DREG (dst) = lshiftrt (DREG (dst), uimm5 (src), 32);
+  else if (opc == 7)
+    /* dregs <<= uimm5 */
+    DREG (dst) = lshift (DREG (dst), uimm5 (src), 32, 0);
+
+  PCREG += 2;
+}
+
+static void
+decode_COMP3op_0 (bu16 iw0)
+{
+  /* COMP3op
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 1 | 0 | 1 |.opc.......|.dst.......|.src1......|.src0......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int src0 = ((iw0 >> 0) & 0x7);
+  int src1 = ((iw0 >> 3) & 0x7);
+  int opc = ((iw0 >> 9) & 0x7);
+  int dst = ((iw0 >> 6) & 0x7);
+
+  if (opc == 0)
+    /* dregs = dregs + dregs */
+    DREG (dst) = add32 (DREG (src0), DREG (src1), 1, 0);
+  else if (opc == 1)
+    /* dregs = dregs - dregs */
+    DREG (dst) = sub32 (DREG (src0), DREG (src1), 1, 0);
+  else if (opc == 2)
+    {
+      /* dregs = dregs & dregs */
+      DREG (dst) = DREG (src0) & DREG (src1);
+      setflags_logical (DREG (dst));
+    }
+  else if (opc == 3)
+    {
+      /* dregs = dregs | dregs */
+      DREG (dst) = DREG (src0) | DREG (src1);
+      setflags_logical (DREG (dst));
+    }
+  else if (opc == 4)
+    {
+      /* dregs = dregs ^ dregs */
+      DREG (dst) = DREG (src0) ^ DREG (src1);
+      setflags_logical (DREG (dst));
+    }
+  else if (opc == 5)
+    /* If src0 == src1 this is disassembled as a shift by 1, but this
+       distinction doesn't matter for our purposes.  */
+    PREG (dst) = PREG (src0) + PREG (src1);
+  else if (opc == 6)
+    PREG (dst) = PREG (src0) + (PREG (src1) << 1);
+  else if (opc == 7)
+    PREG (dst) = PREG (src0) + (PREG (src1) << 2);
+
+  PCREG += 2;
+}
+
+static void
+decode_COMPI2opD_0 (bu16 iw0)
+{
+  /* COMPI2opD
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 1 | 1 | 0 | 0 |.op|.isrc......................|.dst.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int isrc = ((iw0 >> 3) & 0x7f);
+  int dst = ((iw0 >> 0) & 0x7);
+  int op = ((iw0 >> 10) & 0x1);
+
+  if (op == 0)
+    DREG (dst) = imm7 (isrc);
+  else if (op == 1)
+    DREG (dst) = add32 (DREG (dst), imm7 (isrc), 1, 0);
+  PCREG += 2;
+}
+
+static void
+decode_COMPI2opP_0 (bu16 iw0)
+{
+  /* COMPI2opP
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 0 | 1 | 1 | 0 | 1 |.op|.src.......................|.dst.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int src = ((iw0 >> 3) & 0x7f);
+  int dst = ((iw0 >> 0) & 0x7);
+  int op = ((iw0 >> 10) & 0x1);
+
+  if (op == 0)
+    PREG (dst) = imm7 (src);
+  else if (op == 1)
+    PREG (dst) += imm7 (src);
+  PCREG += 2;
+}
+
+static void
+decode_LDSTpmod_0 (bu16 iw0)
+{
+  /* LDSTpmod
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 0 | 0 | 0 |.W.|.aop...|.reg.......|.idx.......|.ptr.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int aop = ((iw0 >> 9) & 0x3);
+  int idx = ((iw0 >> 3) & 0x7);
+  int ptr = ((iw0 >> 0) & 0x7);
+  int reg = ((iw0 >> 6) & 0x7);
+  int W = ((iw0 >> 11) & 0x1);
+  bu32 addr, val;
+
+  if (aop == 1 && W == 0 && idx == ptr)
+    {
+      /* dregs_lo = W[pregs] */
+      addr = PREG (ptr);
+      val = get_word (saved_state.memory, addr);
+      STORE (DREG (reg), (DREG (reg) & 0xFFFF0000) | val);
+    }
+  else if (aop == 2 && W == 0 && idx == ptr)
+    {
+      /* dregs_hi = W[pregs] */
+      addr = PREG (ptr);
+      val = get_word (saved_state.memory, addr);
+      STORE (DREG (reg), (DREG (reg) & 0xFFFF) | (val << 16));
+    }
+  else if (aop == 1 && W == 1 && idx == ptr)
+    {
+      /* W[pregs] = dregs_lo */
+      addr = PREG (ptr);
+      put_word (saved_state.memory, addr, DREG (reg));
+    }
+  else if (aop == 2 && W == 1 && idx == ptr)
+    {
+      /* W[pregs] = dregs_hi */
+      addr = PREG (ptr);
+      put_word (saved_state.memory, addr, DREG (reg) >> 16);
+    }
+  else if (aop == 0 && W == 0)
+    {
+      /* dregs = [pregs ++ pregs] */
+      addr = PREG (ptr);
+      val = get_long (saved_state.memory, addr);
+      STORE (DREG (reg), val);
+      STORE (PREG (ptr), addr + PREG (idx));
+    }
+  else if (aop == 1 && W == 0)
+    {
+      /* dregs_lo = W[pregs ++ pregs] */
+      addr = PREG (ptr);
+      val = get_word (saved_state.memory, addr);
+      STORE (DREG (reg), (DREG (reg) & 0xFFFF0000) | val);
+      STORE (PREG (ptr), addr + PREG (idx));
+    }
+  else if (aop == 2 && W == 0)
+    {
+      /* dregs_hi = W[pregs ++ pregs] */
+      addr = PREG (ptr);
+      val = get_word (saved_state.memory, addr);
+      STORE (DREG (reg), (DREG (reg) & 0xFFFF) | (val << 16));
+      STORE (PREG (ptr), addr + PREG (idx));
+    }
+  else if (aop == 3 && W == 0)
+    {
+      /* dregs = W[pregs ++ pregs] (Z) */
+      addr = PREG (ptr);
+      val = get_word (saved_state.memory, addr);
+      STORE (DREG (reg), val);
+      STORE (PREG (ptr), addr + PREG (idx));
+    }
+  else if (aop == 3 && W == 1)
+    {
+      /* dregs = W [ pregs ++ pregs ] (X) */
+      addr = PREG (ptr);
+      val = get_word (saved_state.memory, addr);
+      STORE (DREG (reg), (bs32) (bs16) val);
+      STORE (PREG (ptr), addr + PREG (idx));
+    }
+  else if (aop == 0 && W == 1)
+    {
+      /* [pregs ++ pregs] = dregs */
+      addr = PREG (ptr);
+      put_long (saved_state.memory, addr, DREG (reg));
+      STORE (PREG (ptr), addr + PREG (idx));
+    }
+  else if (aop == 1 && W == 1)
+    {
+      /* W[pregs ++ pregs] = dregs_lo */
+      addr = PREG (ptr);
+      put_word (saved_state.memory, addr, DREG (reg));
+      STORE (PREG (ptr), addr + PREG (idx));
+    }
+  else if (aop == 2 && W == 1)
+    {
+      /* W[pregs ++ pregs] = dregs_hi */
+      addr = PREG (ptr);
+      put_word (saved_state.memory, addr, DREG (reg) >> 16);
+      STORE (PREG (ptr), addr + PREG (idx));
+    }
+  else
+    illegal_instruction ();
+
+  PCREG += 2;
+}
+
+static void
+decode_dagMODim_0 (bu16 iw0)
+{
+  /* dagMODim
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |.br| 1 | 1 |.op|.m.....|.i.....|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int i = ((iw0 >> 0) & 0x3);
+  int br = ((iw0 >> 7) & 0x1);
+  int m = ((iw0 >> 2) & 0x3);
+  int op = ((iw0 >> 4) & 0x1);
+
+  if (op == 0 && br == 1)
+    unhandled_instruction ("iregs += mregs (BREV)");
+  else if (op == 0)
+    /* iregs += mregs */
+    dagadd (i, MREG (m));
+  else if (op == 1)
+    /* iregs -= mregs */
+    dagsub (i, MREG (m));
+  else
+    illegal_instruction ();
+  PCREG += 2;
+}
+
+static void
+decode_dagMODik_0 (bu16 iw0)
+{
+  /* dagMODik
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 0 |.op....|.i.....|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int i = ((iw0 >> 0) & 0x3);
+  int op = ((iw0 >> 2) & 0x3);
+
+  if (op == 0)
+    /* iregs += 2 */
+    dagadd (i, 2);
+  else if (op == 1)
+    /* iregs -= 2 */
+    dagsub (i, 2);
+  else if (op == 2)
+    /* iregs += 4 */
+    dagadd (i, 4);
+  else if (op == 3)
+    /* iregs -= 4 */
+    dagsub (i, 4);
+  else
+    illegal_instruction ();
+  PCREG += 2;
+}
+
+static void
+decode_dspLDST_0 (bu16 iw0)
+{
+  /* dspLDST
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 0 | 0 | 1 | 1 | 1 |.W.|.aop...|.m.....|.i.....|.reg.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int aop = ((iw0 >> 7) & 0x3);
+  int i = ((iw0 >> 3) & 0x3);
+  int m = ((iw0 >> 5) & 0x3);
+  int reg = ((iw0 >> 0) & 0x7);
+  int W = ((iw0 >> 9) & 0x1);
+  bu32 addr;
+
+  if (aop == 0 && W == 0 && m == 0)
+    {
+      /* dregs = [iregs++] */
+      addr = IREG (i);
+      dagadd (i, 4);
+      STORE (DREG (reg), get_long (saved_state.memory, addr));
+    }
+  else if (aop == 0 && W == 0 && m == 1)
+    {
+      /* dregs_lo = W[iregs++] */
+      addr = IREG (i);
+      dagadd (i, 2);
+      STORE (DREG (reg), (DREG (reg) & 0xFFFF0000) | get_word (saved_state.memory, addr));
+    }
+  else if (aop == 0 && W == 0 && m == 2)
+    {
+      /* dregs_hi = W[iregs++] */
+      addr = IREG (i);
+      dagadd (i, 2);
+      STORE (DREG (reg), (DREG (reg) & 0xFFFF) | (get_word (saved_state.memory, addr) << 16));
+    }
+  else if (aop == 1 && W == 0 && m == 0)
+    {
+      /* dregs = [iregs--] */
+      addr = IREG (i);
+      dagsub (i, 4);
+      STORE (DREG (reg), get_long (saved_state.memory, addr));
+    }
+  else if (aop == 1 && W == 0 && m == 1)
+    {
+      /* dregs_lo = W[iregs--] */
+      addr = IREG (i);
+      dagsub (i, 2);
+      STORE (DREG (reg), (DREG (reg) & 0xFFFF0000) | get_word (saved_state.memory, addr));
+    }
+  else if (aop == 1 && W == 0 && m == 2)
+    {
+      /* dregs_hi = W[iregs--] */
+      addr = IREG (i);
+      dagsub (i, 2);
+      STORE (DREG (reg), (DREG (reg) & 0xFFFF) | (get_word (saved_state.memory, addr) << 16));
+    }
+  else if (aop == 2 && W == 0 && m == 0)
+    {
+      /* dregs = [iregs] */
+      addr = IREG (i);
+      STORE (DREG (reg), get_long (saved_state.memory, addr));
+    }
+  else if (aop == 2 && W == 0 && m == 1)
+    {
+      /* dregs_lo = W[iregs] */
+      addr = IREG (i);
+      STORE (DREG (reg), (DREG (reg) & 0xFFFF0000) | get_word (saved_state.memory, addr));
+    }
+  else if (aop == 2 && W == 0 && m == 2)
+    {
+      /* dregs_hi = W[iregs] */
+      addr = IREG (i);
+      STORE (DREG (reg), (DREG (reg) & 0xFFFF) | (get_word (saved_state.memory, addr) << 16));
+    }
+  else if (aop == 0 && W == 1 && m == 0)
+    {
+      /* [iregs++] = dregs */
+      addr = IREG (i);
+      dagadd (i, 4);
+      put_long (saved_state.memory, addr, DREG (reg));
+    }
+  else if (aop == 0 && W == 1 && m == 1)
+    {
+      /* W[iregs++] = dregs_lo */
+      addr = IREG (i);
+      dagadd (i, 2);
+      put_word (saved_state.memory, addr, DREG (reg));
+    }
+  else if (aop == 0 && W == 1 && m == 2)
+    {
+      /* W[iregs++] = dregs_hi */
+      addr = IREG (i);
+      dagadd (i, 2);
+      put_word (saved_state.memory, addr, DREG (reg) >> 16);
+    }
+  else if (aop == 1 && W == 1 && m == 0)
+    {
+      /* [iregs--] = dregs */
+      addr = IREG (i);
+      dagsub (i, 4);
+      put_long (saved_state.memory, addr, DREG (reg));
+    }
+  else if (aop == 1 && W == 1 && m == 1)
+    {
+      /* W[iregs--] = dregs_lo */
+      addr = IREG (i);
+      dagsub (i, 2);
+      put_word (saved_state.memory, addr, DREG (reg));
+    }
+  else if (aop == 1 && W == 1 && m == 2)
+    {
+      /* W[iregs--] = dregs_hi */
+      addr = IREG (i);
+      dagsub (i, 2);
+      put_word (saved_state.memory, addr, DREG (reg) >> 16);
+    }
+  else if (aop == 2 && W == 1 && m == 0)
+    {
+      /* [iregs] = dregs */
+      addr = IREG (i);
+      put_long (saved_state.memory, addr, DREG (reg));
+    }
+  else if (aop == 2 && W == 1 && m == 1)
+    {
+      /*  W[iregs] = dregs_lo */
+      addr = IREG (i);
+      put_word (saved_state.memory, addr, DREG (reg));
+    }
+  else if (aop == 2 && W == 1 && m == 2)
+    {
+      /*  W[iregs] = dregs_hi */
+      addr = IREG (i);
+      put_word (saved_state.memory, addr, DREG (reg) >> 16);
+    }
+  else if (aop == 3 && W == 0)
+    {
+      /* dregs = [iregs ++ mregs] */
+      addr = IREG (i);
+      dagadd (i, MREG (m));
+      STORE (DREG (reg), get_long (saved_state.memory, addr));
+    }
+  else if (aop == 3 && W == 1)
+    {
+      /* [iregs ++ mregs] = dregs */
+      addr = IREG (i);
+      dagadd(i, MREG (m));
+      put_long (saved_state.memory, addr, DREG (reg));
+    }
+  else
+    illegal_instruction ();
+
+  PCREG += 2;
+}
+
+static void
+decode_LDST_0 (bu16 iw0)
+{
+  /* LDST
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 0 | 0 | 1 |.sz....|.W.|.aop...|.Z.|.ptr.......|.reg.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int aop = ((iw0 >> 7) & 0x3);
+  int Z = ((iw0 >> 6) & 0x1);
+  int sz = ((iw0 >> 10) & 0x3);
+  int reg = ((iw0 >> 0) & 0x7);
+  int ptr = ((iw0 >> 3) & 0x7);
+  int W = ((iw0 >> 9) & 0x1);
+
+  if (aop == 3)
+    illegal_instruction ();
+
+  if (W == 0)
+    {
+      if (aop != 2 && sz == 0 && Z == 1
+	  && ptr == reg)
+	illegal_instruction ();
+
+      if (sz == 0 && Z == 0)
+	/* dregs = [pregs] */
+	DREG (reg) = get_long (saved_state.memory, PREG (ptr));
+      else if (sz == 0 && Z == 1)
+	/* pregs = [pregs] */
+	PREG (reg) = get_long (saved_state.memory, PREG (ptr));
+      else if (sz == 1 && Z == 0)
+	/* dregs = W[pregs] (z) */
+	DREG (reg) = get_word (saved_state.memory, PREG (ptr));
+      else if (sz == 1 && Z == 1)
+	/* dregs = W[pregs] (X) */
+	DREG (reg) = (bs32) (bs16) get_word (saved_state.memory, PREG (ptr));
+      else if (sz == 2 && Z == 0)
+	/* dregs = B[pregs] (Z) */
+	DREG (reg) = get_byte (saved_state.memory, PREG (ptr));
+      else if (sz == 2 && Z == 1)
+	/* dregs = B[pregs] (X) */
+	DREG (reg) = (bs32) (bs8) get_byte (saved_state.memory, PREG (ptr));
+
+      if (aop == 0)
+	PREG (ptr) += sz == 0 ? 4 : sz == 1 ? 2 : 1;
+      if (aop == 1)
+	PREG (ptr) -= sz == 0 ? 4 : sz == 1 ? 2 : 1;
+    }
+  else
+    {
+      if (sz != 0 && Z == 1)
+	illegal_instruction ();
+
+      if (sz == 0 && Z == 0)
+	/* [pregs] = dregs */
+	put_long (saved_state.memory, PREG (ptr), DREG (reg));
+      else if (sz == 0 && Z == 1)
+	/* [pregs] = pregs */
+	put_long (saved_state.memory, PREG (ptr), PREG (reg));
+      else if (sz == 1 && Z == 0)
+	/* W[pregs] = dregs */
+	put_word (saved_state.memory, PREG (ptr), DREG (reg));
+      else if (sz == 2 && Z == 0)
+	/* B[pregs] = dregs */
+	put_byte (saved_state.memory, PREG (ptr), DREG (reg));
+
+      if (aop == 0)
+	PREG (ptr) += sz == 0 ? 4 : sz == 1 ? 2 : 1;
+      if (aop == 1)
+	PREG (ptr) -= sz == 0 ? 4 : sz == 1 ? 2 : 1;
+    }      
+
+  PCREG += 2;
+}
+
+static void
+decode_LDSTiiFP_0 (bu16 iw0)
+{
+  /* LDSTiiFP
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 0 | 1 | 1 | 1 | 0 |.W.|.offset............|.reg...........|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int reg = ((iw0 >> 0) & 0xf);
+  int offset = ((iw0 >> 4) & 0x1f);
+  int W = ((iw0 >> 9) & 0x1);
+  bu32 ea = PREG (7) + negimm5s4 (offset);
+
+  if (W == 0)
+    DPREG (reg) = get_long (saved_state.memory, ea);
+  else
+    put_long (saved_state.memory, ea, DPREG (reg));
+  PCREG += 2;
+}
+
+static void
+decode_LDSTii_0 (bu16 iw0)
+{
+  /* LDSTii
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 0 | 1 |.W.|.op....|.offset........|.ptr.......|.reg.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int reg = ((iw0 >> 0) & 0x7);
+  int ptr = ((iw0 >> 3) & 0x7);
+  int offset = ((iw0 >> 6) & 0xf);
+  int op = ((iw0 >> 10) & 0x3);
+  int W = ((iw0 >> 12) & 0x1);
+  bu32 ea = PREG (ptr) + (op == 0 || op == 3 ? uimm4s4 (offset) 
+			  : uimm4s2 (offset));
+
+  if (W == 1 && op == 2)
+    illegal_instruction ();
+
+  if (W == 0)
+    { 
+      if (op == 0)
+	/* dregs = [pregs + uimm4s4] */
+	DREG (reg) = get_long (saved_state.memory, ea);
+      else if (op == 1)
+	/* dregs = W[pregs + uimm4s2] (Z) */
+	DREG (reg) = get_word (saved_state.memory, ea);
+      else if (op == 2)
+	/* dregs = W[pregs + uimm4s2] (X) */
+	DREG (reg) = (bs32) (bs16) get_word (saved_state.memory, ea);
+      else if (op == 3)
+	/* pregs = [pregs + uimm4s4] */
+	PREG (reg) = get_long (saved_state.memory, ea);
+    }
+  else
+    {
+      if (op == 0)
+	/* [pregs + uimm4s4] = dregs */
+	put_long (saved_state.memory, ea, DREG (reg));
+      else if (op == 1)
+	/* W[pregs + uimm4s2] = dregs */
+	put_word (saved_state.memory, ea, DREG (reg));
+      else if (op == 3)
+	/* [pregs + uimm4s4] = pregs */
+	put_long (saved_state.memory, ea, PREG (reg));
+    }
+  PCREG += 2;
+}
+
+static void
+decode_LoopSetup_0 (bu16 iw0, bu16 iw1, bu32 pc)
+{
+  /* LoopSetup
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1 |.rop...|.c.|.soffset.......|
+     |.reg...........| - | - |.eoffset...............................|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int rop = ((iw0 >> 5) & 0x3);
+  int soffset = ((iw0 >> 0) & 0xf);
+  int c = ((iw0 >> 4) & 0x1);
+  int eoffset = ((iw1 >> 0) & 0x3ff);
+  int reg = ((iw1 >> 12) & 0xf);
+
+  if (rop == 0)
+    {
+      /* LSETUP (pcrel4, lppcrel10) counters */
+      saved_state.lt[c] = PCREG + pcrel4 (soffset);
+      saved_state.lb[c] = PCREG + lppcrel10 (eoffset);
+    }
+  else if (rop == 1)
+    {
+      /* LSETUP (pcrel4, lppcrel10) counters = pregs */
+      saved_state.lt[c] = PCREG + pcrel4 (soffset);
+      saved_state.lb[c] = PCREG + lppcrel10 (eoffset);
+      saved_state.lc[c] = PREG (reg);
+    }
+  else if (rop == 3)
+    {
+      /* LSETUP (pcrel4, lppcrel10) counters = pregs >> 1 */
+      saved_state.lt[c] = PCREG + pcrel4 (soffset);
+      saved_state.lb[c] = PCREG + lppcrel10 (eoffset);
+      saved_state.lc[c] = PREG (reg) >> 1;
+    }
+  else
+    illegal_instruction ();
+
+  PCREG += 4;
+}
+
+static void
+decode_LDIMMhalf_0 (bu16 iw0, bu16 iw1, bu32 pc)
+{
+  /* LDIMMhalf
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 |.Z.|.H.|.S.|.grp...|.reg.......|
+     |.hword.........................................................|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int H = ((iw0 >> 6) & 0x1);
+  int grp = ((iw0 >> 3) & 0x3);
+  int Z = ((iw0 >> 7) & 0x1);
+  int S = ((iw0 >> 5) & 0x1);
+  int hword = ((iw1 >> 0) & 0xffff);
+  int reg = ((iw0 >> 0) & 0x7);
+
+  if (H == 0 && S == 1 && Z == 0)
+    {
+      bu32 *pval = get_allreg (grp, reg);
+      /* regs = imm16 (x) */
+      *pval = imm16 (hword);
+    }
+  else if (H == 0 && S == 0 && Z == 1)
+    {
+      bu32 *pval = get_allreg (grp, reg);
+      /* regs = luimm16 (Z) */
+      *pval = luimm16 (hword);
+    }
+  else if (H == 0 && S == 0 && Z == 0)
+    {
+      bu32 *pval = get_allreg (grp, reg);
+      /* regs_lo = luimm16 */
+      *pval &= 0xFFFF0000;
+      *pval |= luimm16 (hword);
+    }
+  else if (H == 1 && S == 0 && Z == 0)
+    {
+      bu32 *pval = get_allreg (grp, reg);
+      /* regs_hi = huimm16 */
+      *pval &= 0xFFFF;
+      *pval |= luimm16 (hword) << 16;
+    }
+  else
+    illegal_instruction ();
+  PCREG += 4;
+}
+
+static void
+decode_CALLa_0 (bu16 iw0, bu16 iw1, bu32 pc)
+{
+  /* CALLa
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 1 | 1 | 0 | 0 | 0 | 1 |.S.|.msw...........................|
+     |.lsw...........................................................|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+   */
+  int S = ((iw0 >> 8) & 0x1);
+  int lsw = ((iw1 >> 0) & 0xffff);
+  int msw = ((iw0 >> 0) & 0xff);
+
+  if (S == 1)
+    /* CALL  pcrel24 */
+    saved_state.rets = PCREG + 4;
+  /* JUMP.L  pcrel24 */
+  PCREG += pcrel24 (((msw) << 16) | (lsw));
+}
+
+static void
+decode_LDSTidxI_0 (bu16 iw0, bu16 iw1, bu32 pc)
+{
+  /* LDSTidxI
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 1 | 1 | 0 | 0 | 1 |.W.|.Z.|.sz....|.ptr.......|.reg.......|
+     |.offset........................................................|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int Z = ((iw0 >> 8) & 0x1);
+  int sz = ((iw0 >> 6) & 0x3);
+  int reg = ((iw0 >> 0) & 0x7);
+  int ptr = ((iw0 >> 3) & 0x7);
+  int offset = ((iw1 >> 0) & 0xffff);
+  int W = ((iw0 >> 9) & 0x1);
+
+  if (sz == 3)
+    illegal_instruction ();
+
+  if (W == 0)
+    {
+      if (sz == 0 && Z == 0)
+	/* dregs = [pregs + imm16s4] */
+	DREG (reg) = get_long (saved_state.memory, PREG (ptr) + imm16s4 (offset));
+      else if (sz == 0 && Z == 1)
+	/* pregs = [pregs + imm16s4] */
+	PREG (reg) = get_long (saved_state.memory, PREG (ptr) + imm16s4 (offset));
+      else if (sz == 1 && Z == 0)
+	/* dregs = W[pregs + imm16s2] (Z) */
+	DREG (reg) = get_word (saved_state.memory, PREG (ptr) + imm16s2 (offset));
+      else if (sz == 1 && Z == 1)
+	/* dregs = W[pregs + imm16s2] (X) */
+	DREG (reg) = (bs32) (bs16) get_word (saved_state.memory, PREG (ptr) + imm16s2 (offset));
+      else if (sz == 2 && Z == 0)
+	/* dregs = B[pregs + imm16] (Z) */
+	DREG (reg) = get_byte (saved_state.memory, PREG (ptr) + imm16 (offset));
+      else if (sz == 2 && Z == 1)
+	/* dregs = B[pregs + imm16] (X) */
+	DREG (reg) = (bs32) (bs8) get_byte (saved_state.memory, PREG (ptr) + imm16 (offset));
+    }
+  else
+    {
+      if (sz != 0 && Z != 0)
+	illegal_instruction ();
+
+      if (sz == 0 && Z == 0)
+	/* [pregs + imm16s4] = dregs */
+	put_long (saved_state.memory, PREG (ptr) + imm16s4 (offset), DREG (reg));
+      else if (sz == 0 && Z == 1)
+	/* [pregs + imm16s4] = pregs */
+	put_long (saved_state.memory, PREG (ptr) + imm16s4 (offset), PREG (reg));
+      else if (sz == 1 && Z == 0)
+	/* W[pregs + imm16s2] = dregs */
+	put_word (saved_state.memory, PREG (ptr) + imm16s2 (offset), DREG (reg));
+      else if (sz == 2 && Z == 0)
+	/* B[pregs + imm16] = dregs */
+	put_byte (saved_state.memory, PREG (ptr) + imm16 (offset), DREG (reg));
+    }
+  PCREG += 4;
+}
+
+static void
+decode_linkage_0 (bu16 iw0, bu16 iw1)
+{
+  /* linkage
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 1 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |.R.|
+     |.framesize.....................................................|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int R = ((iw0 >> 0) & 0x1);
+  int framesize = ((iw1 >> 0) & 0xffff);
+
+  if (R == 0)
+    {
+      bu32 sp = PREG (6);
+      /* LINK uimm16s4 */
+      sp -= 4;
+      put_long (saved_state.memory, sp, saved_state.rets);
+      sp -= 4;
+      put_long (saved_state.memory, sp, PREG (7));
+      PREG (7) = sp;
+      sp -= uimm16s4 (framesize);
+      PREG (6) = sp;
+    }
+  else
+    {
+      /* Restore SP from FP.  */
+      bu32 sp = PREG (7);
+      /* UNLINK */
+      PREG (7) = get_long (saved_state.memory, sp);
+      sp += 4;
+      saved_state.rets = get_long (saved_state.memory, sp);
+      sp += 4;
+      PREG (6) = sp;
+    }
+  PCREG += 4;
+}
+
+static void
+decode_dsp32mac_0 (bu16 iw0, bu16 iw1, bu32 pc)
+{
+  /* dsp32mac
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 1 | 0 | 0 |.M.| 0 | 0 |.mmod..........|.MM|.P.|.w1|.op1...|
+     |.h01|.h11|.w0|.op0...|.h00|.h10|.dst.......|.src0......|.src1......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int op1 = ((iw0 >> 0) & 0x3);
+  int w1 = ((iw0 >> 2) & 0x1);
+  int P = ((iw0 >> 3) & 0x1);
+  int MM = ((iw0 >> 4) & 0x1);
+  int mmod = ((iw0 >> 5) & 0xf);
+  int M = ((iw0 >> 11) & 0x1);
+
+  int w0 = ((iw1 >> 13) & 0x1);
+  int src1 = ((iw1 >> 0) & 0x7);
+  int src0 = ((iw1 >> 3) & 0x7);
+  int dst = ((iw1 >> 6) & 0x7);
+  int h10 = ((iw1 >> 9) & 0x1);
+  int h00 = ((iw1 >> 10) & 0x1);
+  int op0 = ((iw1 >> 11) & 0x3);
+  int h11 = ((iw1 >> 14) & 0x1);
+  int h01 = ((iw1 >> 15) & 0x1);
+
+  bu32 res0, res1;
+
+  if (w0 == 0 && w1 == 0 && op1 == 3 && op0 == 3)
+    illegal_instruction ();
+
+  if (op1 == 3 && MM)
+    illegal_instruction ();
+
+  if (((1 << mmod) & (P ? 0x313 : 0x1b57)) == 0)
+    illegal_instruction ();
+
+  if (w1 == 1 || op1 != 3)
+    res1 = decode_macfunc (1, op1, h01, h11, src0, src1, mmod, MM, P);
+
+  if (w0 == 1 || op0 != 3)
+    res0 = decode_macfunc (0, op0, h00, h10, src0, src1, mmod, 0, P);
+
+  if (w0)
+    {
+      if (P)
+	DREG (dst) = res0;
+      else
+	{
+	  if (res0 & 0xffff0000)
+	    abort ();
+	  DREG (dst) = (DREG (dst) & 0xFFFF0000) | res0;
+	}
+    }
+
+  if (w1)
+    {
+      if (P)
+	DREG (dst + 1) = res1;
+      else
+	{
+	  if (res1 & 0xffff0000)
+	    abort ();
+	  DREG (dst) = (DREG (dst) & 0xFFFF) | (res1 << 16);
+	}
+    }
+
+  PCREG += 4;
+}
+
+static void
+decode_dsp32mult_0 (bu16 iw0, bu16 iw1, bu32 pc)
+{
+  /* dsp32mult
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 1 | 0 | 0 |.M.| 0 | 1 |.mmod..........|.MM|.P.|.w1|.op1...|
+     |.h01|.h11|.w0|.op0...|.h00|.h10|.dst.......|.src0......|.src1......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int op1 = ((iw0 >> 0) & 0x3);
+  int w1 = ((iw0 >> 2) & 0x1);
+  int P = ((iw0 >> 3) & 0x1);
+  int MM = ((iw0 >> 4) & 0x1);
+  int mmod = ((iw0 >> 5) & 0xf);
+  int M = ((iw0 >> 11) & 0x1);
+
+  int src1 = ((iw1 >> 0) & 0x7);
+  int src0 = ((iw1 >> 3) & 0x7);
+  int dst = ((iw1 >> 6) & 0x7);
+  int h10 = ((iw1 >> 9) & 0x1);
+  int h00 = ((iw1 >> 10) & 0x1);
+  int op0 = ((iw1 >> 11) & 0x3);
+  int w0 = ((iw1 >> 13) & 0x1);
+  int h01 = ((iw1 >> 15) & 0x1);
+  int h11 = ((iw1 >> 14) & 0x1);
+
+  bu32 res0, res1;
+
+  if (w1 == 0 && w0 == 0)
+    illegal_instruction ();
+  if (((1 << mmod) & (P ? 0x313 : 0x1b57)) == 0)
+    illegal_instruction ();
+
+  if (w1)
+    {
+      bu64 r = decode_multfunc (h01, h11, src0, src1, mmod, MM);
+      res1 = extract_mult (r, mmod, P);
+    }
+
+  if (w0)
+    {
+      bu64 r = decode_multfunc (h00, h10, src0, src1, mmod, 0);
+      res0 = extract_mult (r, mmod, P);
+    }
+
+  if (w0)
+    {
+      if (P)
+	DREG (dst) = res0;
+      else
+	{
+	  if (res0 & 0xFFFF0000)
+	    abort ();
+	  DREG (dst) = (DREG (dst) & 0xFFFF0000) | res0;
+	}
+    }
+
+  if (w1)
+    {
+      if (P)
+	DREG (dst + 1) = res1;
+      else
+	{
+	  if (res1 & 0xFFFF0000)
+	    abort ();
+	  DREG (dst) = (DREG (dst) & 0xFFFF) | (res1 << 16);
+	}
+    }
+
+  PCREG += 4;
+}
+
+static void
+decode_dsp32alu_0 (bu16 iw0, bu16 iw1, bu32 pc)
+{
+  /* dsp32alu
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 1 | 0 | 0 |.M.| 1 | 0 | - | - | - |.HL|.aopcde............|
+     |.aop...|.s.|.x.|.dst0......|.dst1......|.src0......|.src1......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int aop = ((iw1 >> 14) & 0x3);
+  int s = ((iw1 >> 13) & 0x1);
+  int HL = ((iw0 >> 5) & 0x1);
+  int x = ((iw1 >> 12) & 0x1);
+  int src0 = ((iw1 >> 3) & 0x7);
+  int src1 = ((iw1 >> 0) & 0x7);
+  int dst0 = ((iw1 >> 9) & 0x7);
+  int aopcde = ((iw0 >> 0) & 0x1f);
+  int dst1 = ((iw1 >> 6) & 0x7);
+  int M = ((iw0 >> 11) & 0x1);
+
+  if (aop == 0 && aopcde == 9 && HL == 0 && s == 0)
+    unhandled_instruction ("A0.L = dregs_lo");
+  else if (aop == 2 && aopcde == 9 && HL == 1 && s == 0)
+    unhandled_instruction ("A1.H = dregs_hi");
+  else if (aop == 2 && aopcde == 9 && HL == 0 && s == 0)
+    unhandled_instruction ("A1.L = dregs_lo");
+  else if (aop == 0 && aopcde == 9 && HL == 1 && s == 0)
+    unhandled_instruction ("A0.H = dregs_hi");
+  else if (x == 1 && HL == 1 && aop == 3 && aopcde == 5)
+    unhandled_instruction ("dregs_hi = dregs - dregs (RND20)");
+  else if (x == 1 && HL == 1 && aop == 2 && aopcde == 5)
+    unhandled_instruction ("dregs_hi = dregs + dregs (RND20)");
+  else if (x == 0 && HL == 0 && aop == 1 && aopcde == 5)
+    unhandled_instruction ("dregs_lo = dregs - dregs (RND12)");
+  else if (x == 0 && HL == 0 && aop == 0 && aopcde == 5)
+    unhandled_instruction ("dregs_lo = dregs + dregs (RND12)");
+  else if (x == 1 && HL == 0 && aop == 3 && aopcde == 5)
+    unhandled_instruction ("dregs_lo = dregs - dregs (RND20)");
+  else if (x == 0 && HL == 1 && aop == 0 && aopcde == 5)
+    unhandled_instruction ("dregs_hi = dregs + dregs (RND12)");
+  else if (x == 1 && HL == 0 && aop == 2 && aopcde == 5)
+    unhandled_instruction ("dregs_lo = dregs + dregs (RND20)");
+  else if (x == 0 && HL == 1 && aop == 1 && aopcde == 5)
+    unhandled_instruction ("dregs_hi = dregs - dregs (RND12)");
+  else if (aopcde == 2 || aopcde == 3)
+    {
+      bu32 s1 = DREG (src0);
+      bu32 s2 = DREG (src1);
+      bu16 val;
+      if (aop & 1)
+	s2 >>= 16;
+      if (aop & 2)
+	s1 >>= 16;
+      if (aopcde == 2)
+	val = add16 (s1, s2, &saved_state.ac0, s);
+      else
+	val = sub16 (s1, s2, &saved_state.ac0, s);
+      if (HL)
+	DREG (dst0) = (DREG (dst0) & 0xFFFF) | (val << 16);
+      else
+	DREG (dst0) = (DREG (dst0) & 0xFFFF0000) | val;
+    }
+  else if (aop == 0 && aopcde == 9 && s == 1)
+    {
+      saved_state.a0w = DREG (src0);
+      saved_state.a0x = -(saved_state.a1w >> 31);
+    }
+  else if (aop == 1 && aopcde == 9 && s == 0)
+    saved_state.a0x = (bs32)(bs8)DREG (src0);
+  else if (aop == 2 && aopcde == 9 && s == 1)
+    {
+      saved_state.a1w = DREG (src0);
+      saved_state.a1x = -(saved_state.a1w >> 31);
+    }
+  else if (aop == 3 && aopcde == 9 && s == 0)
+    saved_state.a1x = (bs32)(bs8)DREG (src0);
+  else if (aop == 3 && aopcde == 11 && s == 0)
+    unhandled_instruction ("A0 -= A1");
+  else if (aop == 3 && aopcde == 11 && s == 1)
+    unhandled_instruction ("A0 -= A1 (W32)");
+  else if (aop == 3 && aopcde == 22 && HL == 1)
+    unhandled_instruction ("dregs = BYTEOP2M (dregs_pair, dregs_pair) (TH,R)");
+  else if (aop == 3 && aopcde == 22 && HL == 0)
+    unhandled_instruction ("dregs = BYTEOP2M (dregs_pair, dregs_pair) (TL,R)");
+  else if (aop == 2 && aopcde == 22 && HL == 1)
+    unhandled_instruction ("dregs = BYTEOP2M (dregs_pair, dregs_pair) (RNDH,R)");
+  else if (aop == 2 && aopcde == 22 && HL == 0)
+    unhandled_instruction ("dregs = BYTEOP2M (dregs_pair, dregs_pair) (RNDL,R)");
+  else if (aop == 1 && aopcde == 22 && HL == 1)
+    unhandled_instruction ("dregs = BYTEOP2P (dregs_pair, dregs_pair) (TH ,R)");
+  else if (aop == 1 && aopcde == 22 && HL == 0)
+    unhandled_instruction ("dregs = BYTEOP2P (dregs_pair, dregs_pair) (TL ,R)");
+  else if (aop == 0 && aopcde == 22 && HL == 1)
+    unhandled_instruction ("dregs = BYTEOP2P (dregs_pair, dregs_pair) (RNDH,R)");
+  else if (aop == 0 && aopcde == 22 && HL == 0)
+    unhandled_instruction ("dregs = BYTEOP2P (dregs_pair, dregs_pair) (RNDL,aligndir)");
+  else if (aop == 0 && s == 0 && aopcde == 8)
+    {
+      /* A0 = 0 */
+      saved_state.a0x = 0;
+      saved_state.a0w = 0;
+    }
+  else if (aop == 0 && s == 1 && aopcde == 8)
+    saved_state.a0x = -(saved_state.a0w >> 31);
+  else if (aop == 1 && s == 0 && aopcde == 8)
+    {
+      /* A1 = 0 */
+      saved_state.a1x = 0;
+      saved_state.a1w = 0;
+    }
+  else if (aop == 1 && s == 1 && aopcde == 8)
+    saved_state.a1x = -(saved_state.a1w >> 31);
+  else if (aop == 2 && s == 0 && aopcde == 8)
+    {
+      /* A1 = A0 = 0 */
+      saved_state.a1x = saved_state.a0x = 0;
+      saved_state.a1w = saved_state.a0w = 0;
+    }
+  else if (aop == 2 && s == 1 && aopcde == 8)
+    {
+      saved_state.a0x = -(saved_state.a0w >> 31);
+      saved_state.a1x = -(saved_state.a1w >> 31);
+    }
+  else if (aop == 3 && s == 0 && aopcde == 8)
+    {
+      saved_state.a0x = saved_state.a1x;
+      saved_state.a0w = saved_state.a1w;
+    }
+  else if (aop == 3 && s == 1 && aopcde == 8)
+    {
+      saved_state.a1x = saved_state.a0x;
+      saved_state.a1w = saved_state.a0w;
+    }
+  else if (aop == 1 && HL == 0 && aopcde == 11)
+    unhandled_instruction ("dregs_lo = (A0 += A1)");
+  else if (aop == 3 && HL == 0 && aopcde == 16)
+    unhandled_instruction ("A1 = ABS A1, A0 = ABS A0");
+  else if (aop == 0 && aopcde == 23 && HL == 1)
+    unhandled_instruction ("dregs = BYTEOP3P (dregs_pair, dregs_pair) (HI,R)");
+  else if (aop == 1 && HL == 1 && aopcde == 16)
+    unhandled_instruction ("A1 = ABS A1");
+  else if (aop == 0 && HL == 1 && aopcde == 16)
+    unhandled_instruction ("A1 = ABS A0");
+  else if (HL == 0 && aop == 3 && aopcde == 12)
+    unhandled_instruction ("dregs_lo = dregs (RND)");
+  else if (aop == 1 && HL == 0 && aopcde == 16)
+    unhandled_instruction ("A0 = ABS A1");
+  else if (aop == 0 && HL == 0 && aopcde == 16)
+    unhandled_instruction ("A0 = ABS A0");
+  else if (aop == 3 && HL == 0 && aopcde == 15)
+    {
+      /* Vector NEG.  */
+      bu32 hi = (-(bs16)(DREG (src0) >> 16)) << 16;
+      bu32 lo = (-(bs16)(DREG (src0) & 0xFFFF)) & 0xFFFF;
+      DREG (dst0) = hi | lo;
+      setflags_nz_2x16 (DREG (dst0));
+      saved_state.v = 0;
+    }
+  else if (aop == 1 && HL == 1 && aopcde == 11)
+    unhandled_instruction ("dregs_hi = (A0 += A1)");
+  else if (aop == 2 && aopcde == 11 && s == 0)
+    unhandled_instruction ("A0 += A1");
+  else if (aop == 2 && aopcde == 11 && s == 1)
+    unhandled_instruction ("A0 += A1 (W32)");
+  else if (aop == 3 && HL == 0 && aopcde == 14)
+    unhandled_instruction ("A1 = - A1 , A0 = - A0");
+  else if (HL == 1 && aop == 3 && aopcde == 12)
+    unhandled_instruction ("dregs_hi = dregs (RND)");
+  else if (aop == 0 && aopcde == 23 && HL == 0)
+    unhandled_instruction ("dregs = BYTEOP3P (dregs_pair, dregs_pair) (LO,R)");
+  else if (aop == 0 && HL == 0 && aopcde == 14)
+    unhandled_instruction ("A0 = - A0");
+  else if (aop == 1 && HL == 0 && aopcde == 14)
+    unhandled_instruction ("A0 = - A1");
+  else if (aop == 0 && HL == 1 && aopcde == 14)
+    unhandled_instruction ("A1 = - A0");
+  else if (aop == 1 && HL == 1 && aopcde == 14)
+    unhandled_instruction ("A1 = - A1");
+  else if (aop == 0 && aopcde == 12)
+    unhandled_instruction ("dregs_hi=dregs_lo=SIGN(dregs_hi)*dregs_hi + SIGN(dregs_lo)*dregs_lo)");
+  else if (aopcde == 0)
+    {
+      /* dregs = dregs +-|+- dregs amod0 */
+      bu32 s0 = DREG (src0);
+      bu32 s1 = DREG (src1);
+      bu32 s0h = s0 >> 16;
+      bu32 s0l = s0 & 0xFFFF;
+      bu32 s1h = s1 >> 16;
+      bu32 s1l = s1 & 0xFFFF;
+      bu32 t0, t1;
+      if (aop & 2)
+	t0 = sub16 (s0h, s1h, &saved_state.ac1, s);
+      else
+	t0 = add16 (s0h, s1h, &saved_state.ac1, s);
+      if (aop & 1)
+	t1 = sub16 (s0l, s1l, &saved_state.ac0, s);
+      else
+	t1 = add16 (s0l, s1l, &saved_state.ac0, s);
+      t0 &= 0xFFFF;
+      t1 &= 0xFFFF;
+      if (x)
+	DREG (dst0) = (t1 << 16) | t0;
+      else
+	DREG (dst0) = (t0 << 16) | t1;
+    }
+  else if (aop == 1 && aopcde == 12)
+    unhandled_instruction ("dregs = A1.L + A1.H , dregs = A0.L + A0.H");
+  else if (HL == 0 && aopcde == 1)
+    {
+      if (aop == 0)
+	{
+	  /* dregs = dregs +|+ dregs, dregs = dregs -|- dregs (amod0) */
+	  bu32 d0, d1;
+	  d1 = addadd16 (DREG (src0), DREG (src1), s, 0);
+	  d0 = subsub16 (DREG (src0), DREG (src1), s, x);
+	  STORE (DREG (dst0), d0);
+	  STORE (DREG (dst1), d1);
+	}
+      else
+	unhandled_instruction
+	  ("dregs = dregs +|+ dregs, dregs = dregs -|- dregs (amod0, amod2)");
+    }
+  else if (aop == 0 && aopcde == 11)
+    unhandled_instruction ("dregs = (A0 += A1)");
+  else if (aop == 0 && aopcde == 10)
+    {
+      DREG (dst0) &= 0xFFFF0000;
+      DREG (dst0) |= saved_state.a0x & 0xFFFF;
+    }
+  else if (aop == 1 && aopcde == 10)
+    {
+      DREG (dst0) &= 0xFFFF0000;
+      DREG (dst0) |= saved_state.a1x & 0xFFFF;
+    }
+  else if (aop == 0 && aopcde == 4)
+    DREG (dst0) = add32 (DREG (src0), DREG (src1), 1, s);
+  else if (aop == 1 && aopcde == 4)
+    DREG (dst0) = sub32 (DREG (src0), DREG (src1), 1, s);
+  else if (aop == 2 && aopcde == 4)
+    unhandled_instruction ("dregs = dregs + dregs , dregs = dregs - dregs amod1");
+  else if (aop == 0 && aopcde == 17)
+    unhandled_instruction ("dregs = A1 + A0, dregs = A1 - A0 amod1");
+  else if (aop == 1 && aopcde == 17)
+    unhandled_instruction ("dregs = A0 + A1, dregs = A0 - A1 amod1");
+  else if (aop == 0 && aopcde == 18)
+    unhandled_instruction ("SAA (dregs_pair, dregs_pair) aligndir");
+  else if (aop == 3 && aopcde == 18)
+    unhandled_instruction ("DISALGNEXCPT");
+  else if (aop == 0 && aopcde == 20)
+    unhandled_instruction ("dregs = BYTEOP1P (dregs_pair, dregs_pair) aligndir");
+  else if (aop == 1 && aopcde == 20)
+    unhandled_instruction ("dregs = BYTEOP1P (dregs_pair, dregs_pair) (T, R)");
+  else if (aop == 0 && aopcde == 21)
+    unhandled_instruction ("(dregs, dregs) = BYTEOP16P (dregs_pair, dregs_pair) aligndir");
+  else if (aop == 1 && aopcde == 21)
+    unhandled_instruction ("(dregs, dregs) = BYTEOP16M (dregs_pair, dregs_pair) aligndir");
+  else if (aop == 1 && aopcde == 7)
+    /* dregs = MIN (dregs, dregs) */
+    DREG (dst0) = min32 (DREG (src0), DREG (src1));
+  else if (aop == 0 && aopcde == 7)
+    /* dregs = MAX (dregs, dregs) */
+    DREG (dst0) = max32 (DREG (src0), DREG (src1));
+  else if (aop == 2 && aopcde == 7)
+    {
+      bu32 val = DREG (src0);
+      /* dregs = ABS dregs */
+      if (val >> 31)
+	val = -val;
+      /* @@@ The manual is talking about saturation.  Check what the hardware
+	 does when it gets 0x80000000.  */
+      setflags_logical (val);
+      DREG (dst0) = val;
+    }
+  else if (aop == 3 && aopcde == 7)
+    {
+      bu32 val = DREG (src0);
+      /* dregs = - dregs (opt_sat) */
+      saved_state.v = val == 0x8000;
+      if (saved_state.v)
+	saved_state.vs = 1;
+      if (val == 0x80000000)
+	val = 0x7fffffff;
+      else
+	val = -val;
+      setflags_logical (val);
+      DREG (dst0) = val;
+    }
+  else if (aop == 2 && aopcde == 6)
+    {
+      /* Vector ABS.  */
+      bu32 in = DREG (src0);
+      bu32 hi = (in & 0x80000000 ? -(bs16)(in >> 16) : in >> 16) << 16;
+      bu32 lo = (in & 0x8000 ? -(bs16)(in & 0xFFFF) : in) & 0xFFFF;
+      DREG (dst0) = hi | lo;
+      setflags_nz_2x16 (DREG (dst0));
+      saved_state.v = 0;
+    }
+  else if (aop == 1 && aopcde == 6)
+    DREG (dst0) = min2x16 (DREG (src0), DREG (src1));
+  else if (aop == 0 && aopcde == 6)
+    DREG (dst0) = max2x16 (DREG (src0), DREG (src1));
+  else if (HL == 1 && aopcde == 1)
+    unhandled_instruction ("dregs = dregs +|- dregs, dregs = dregs -|+ dregs (amod0, amod2)");
+  else if (aop == 0 && aopcde == 24)
+    unhandled_instruction ("dregs = BYTEPACK (dregs, dregs)");
+  else if (aop == 1 && aopcde == 24)
+    unhandled_instruction ("(dregs, dregs) = BYTEUNPACK dregs_pair aligndir");
+  else if (aopcde == 13)
+    unhandled_instruction ("(dregs, dregs) = SEARCH dregs (searchmod)");
+  else
+    illegal_instruction ();
+  PCREG += 4;
+}
+
+static void
+decode_dsp32shift_0 (bu16 iw0, bu16 iw1, bu32 pc)
+{
+  /* dsp32shift
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 1 | 0 | 0 |.M.| 1 | 1 | 0 | 0 | - | - |.sopcde............|
+     |.sop...|.HLs...|.dst0......| - | - | - |.src0......|.src1......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int src0 = ((iw1 >> 3) & 0x7);
+  int src1 = ((iw1 >> 0) & 0x7);
+  int sop = ((iw1 >> 14) & 0x3);
+  int dst0 = ((iw1 >> 9) & 0x7);
+  int M = ((iw0 >> 11) & 0x1);
+  int sopcde = ((iw0 >> 0) & 0x1f);
+  int HLs = ((iw1 >> 12) & 0x3);
+
+  if (HLs == 0 && sop == 0 && sopcde == 0)
+    unhandled_instruction ("dregs_lo = ASHIFT dregs_lo BY dregs_lo");
+  else if (HLs == 1 && sop == 0 && sopcde == 0)
+    unhandled_instruction ("dregs_lo = ASHIFT dregs_hi BY dregs_lo");
+  else if (HLs == 2 && sop == 0 && sopcde == 0)
+    unhandled_instruction ("dregs_hi = ASHIFT dregs_lo BY dregs_lo");
+  else if (HLs == 3 && sop == 0 && sopcde == 0)
+    unhandled_instruction ("dregs_hi = ASHIFT dregs_hi BY dregs_lo");
+  else if (HLs == 0 && sop == 1 && sopcde == 0)
+    unhandled_instruction ("dregs_lo = ASHIFT dregs_lo BY dregs_lo (S)");
+  else if (HLs == 1 && sop == 1 && sopcde == 0)
+    unhandled_instruction ("dregs_lo = ASHIFT dregs_hi BY dregs_lo (S)");
+  else if (HLs == 2 && sop == 1 && sopcde == 0)
+    unhandled_instruction ("dregs_hi = ASHIFT dregs_lo BY dregs_lo (S)");
+  else if (HLs == 3 && sop == 1 && sopcde == 0)
+    unhandled_instruction ("dregs_hi = ASHIFT dregs_hi BY dregs_lo (S)");
+  else if (HLs == 0 && sop == 2 && sopcde == 0)
+    unhandled_instruction ("dregs_lo = LSHIFT dregs_lo BY dregs_lo");
+  else if (HLs == 1 && sop == 2 && sopcde == 0)
+    unhandled_instruction ("dregs_lo = LSHIFT dregs_hi BY dregs_lo");
+  else if (HLs == 2 && sop == 2 && sopcde == 0)
+    unhandled_instruction ("dregs_hi = LSHIFT dregs_lo BY dregs_lo");
+  else if (HLs == 3 && sop == 2 && sopcde == 0)
+    unhandled_instruction ("dregs_hi = LSHIFT dregs_hi BY dregs_lo");
+  else if (sop == 2 && sopcde == 3 && HLs == 1)
+    unhandled_instruction ("A1 = ROT A1 BY dregs_lo");
+  else if (sop == 0 && sopcde == 3 && HLs == 0)
+    unhandled_instruction ("A0 = ASHIFT A0 BY dregs_lo");
+  else if (sop == 0 && sopcde == 3 && HLs == 1)
+    unhandled_instruction ("A1 = ASHIFT A1 BY dregs_lo");
+  else if (sop == 1 && sopcde == 3 && HLs == 0)
+    unhandled_instruction ("A0 = LSHIFT A0 BY dregs_lo");
+  else if (sop == 1 && sopcde == 3 && HLs == 1)
+    unhandled_instruction ("A1 = LSHIFT A1 BY dregs_lo");
+  else if (sop == 2 && sopcde == 3 && HLs == 0)
+    unhandled_instruction ("A0 = ROT A0 BY dregs_lo");
+  else if (sop == 1 && sopcde == 1)
+    unhandled_instruction ("dregs = ASHIFT dregs BY dregs_lo (V,S)");
+  else if (sop == 0 && sopcde == 1)
+    unhandled_instruction ("dregs = ASHIFT dregs BY dregs_lo (V)");
+  else if ((sop == 0 || sop == 1 || sop == 2) && sopcde == 2)
+    {
+      /* dregs = [LA]SHIFT dregs BY dregs_lo (opt_S) */
+      bu32 v = DREG (src1);
+      bs32 shft = (bs16)DREG (src0);
+      if (shft < 0)
+	{
+	  if (sop == 2)
+	    DREG (dst0) = lshiftrt (v, -shft, 32);
+	  else
+	    DREG (dst0) = ashiftrt (v, -shft, 32);
+	}
+      else
+	{
+	  DREG (dst0) = lshift (v, shft, 32, sop == 1);
+	}
+    }
+  else if (sop == 3 && sopcde == 2)
+    unhandled_instruction ("dregs = ROT dregs BY dregs_lo");
+  else if (sop == 2 && sopcde == 1)
+    unhandled_instruction ("dregs = SHIFT dregs BY dregs_lo (V)");
+  else if (sop == 0 && sopcde == 4)
+    unhandled_instruction ("dregs = PACK (dregs_lo, dregs_lo)");
+  else if (sop == 1 && sopcde == 4)
+    unhandled_instruction ("dregs = PACK (dregs_lo, dregs_hi)");
+  else if (sop == 2 && sopcde == 4)
+    unhandled_instruction ("dregs = PACK (dregs_hi, dregs_lo)");
+  else if (sop == 3 && sopcde == 4)
+    unhandled_instruction ("dregs = PACK (dregs_hi, dregs_hi)");
+  else if (sop == 0 && sopcde == 5)
+    {
+      DREG (dst0) &= 0xFFFF0000;
+      DREG (dst0) |= signbits (DREG (src0), 32);
+    }
+  else if (sop == 1 && sopcde == 5)
+    {
+      DREG (dst0) &= 0xFFFF0000;
+      DREG (dst0) |= signbits (DREG (src0), 16);
+    }
+  else if (sop == 2 && sopcde == 5)
+    {
+      DREG (dst0) &= 0xFFFF0000;
+      DREG (dst0) |= signbits (DREG (src0) >> 16, 16);
+    }
+  else if (sop == 0 && sopcde == 6)
+    {
+      bu64 acc0 = saved_state.a0x;
+      acc0 <<= 32;
+      acc0 |= saved_state.a0w;
+      DREG (dst0) &= 0xFFFF0000;
+      DREG (dst0) |= signbits (acc0, 40);
+    }
+  else if (sop == 1 && sopcde == 6)
+    {
+      bu64 acc1 = saved_state.a1x;
+      acc1 <<= 32;
+      acc1 |= saved_state.a1w;
+      DREG (dst0) &= 0xFFFF0000;
+      DREG (dst0) |= signbits (acc1, 40);
+    }
+  else if (sop == 3 && sopcde == 6)
+    unhandled_instruction ("dregs_lo = ONES dregs");
+  else if (sop == 0 && sopcde == 7)
+    unhandled_instruction ("dregs_lo = EXPADJ (dregs, dregs_lo)");
+  else if (sop == 1 && sopcde == 7)
+    unhandled_instruction ("dregs_lo = EXPADJ (dregs, dregs_lo) (V)");
+  else if (sop == 2 && sopcde == 7)
+    unhandled_instruction ("dregs_lo = EXPADJ (dregs_lo, dregs_lo)");
+  else if (sop == 3 && sopcde == 7)
+    unhandled_instruction ("dregs_lo = EXPADJ (dregs_hi, dregs_lo)");
+  else if (sop == 0 && sopcde == 8)
+    unhandled_instruction ("BITMUX (dregs, dregs, A0) (ASR)");
+  else if (sop == 1 && sopcde == 8)
+    unhandled_instruction ("BITMUX (dregs, dregs, A0) (ASL)");
+  else if (sop == 0 && sopcde == 9)
+    unhandled_instruction ("dregs_lo = VIT_MAX (dregs) (ASL)");
+  else if (sop == 1 && sopcde == 9)
+    unhandled_instruction ("dregs_lo = VIT_MAX (dregs) (ASR)");
+  else if (sop == 2 && sopcde == 9)
+    unhandled_instruction ("dregs = VIT_MAX (dregs, dregs) (ASL)");
+  else if (sop == 3 && sopcde == 9)
+    unhandled_instruction ("dregs = VIT_MAX (dregs, dregs) (ASR)");
+  else if (sop == 0 && sopcde == 10)
+    {
+      /* dregs = EXTRACT (dregs, dregs_lo) (Z) */
+      bu32 v = DREG (src0);
+      bu32 x = DREG (src1);
+      bu32 mask = (1 << (v & 0x1f)) - 1;
+      x >>= ((v >> 8) & 0x1f);
+      DREG (dst0) = x & mask;
+      setflags_logical (DREG (dst0));
+    }
+  else if (sop == 1 && sopcde == 10)
+    {
+      /* dregs = EXTRACT (dregs, dregs_lo) (X) */
+      bu32 v = DREG (src0);
+      bu32 x = DREG (src1);
+      bu32 sgn = (1 << (v & 0x1f)) >> 1;
+      bu32 mask = (1 << (v & 0x1f)) - 1;
+      x >>= ((v >> 8) & 0x1f);
+      x &= mask;
+      if (x & sgn)
+	x |= ~mask;
+      DREG (dst0) = x;
+      setflags_logical (DREG (dst0));
+    }
+  else if (sop == 2 && sopcde == 10)
+    {
+      /* dregs = DEPOSIT (dregs, dregs) */
+      bu32 v = DREG (src0);
+      bu32 x = DREG (src1);
+      bu32 mask = (1 << (v & 0x1f)) - 1;
+      bu32 fgnd = (v >> 16) & mask;
+      int shft = ((v >> 8) & 0x1f);
+      fgnd <<= shft;
+      mask <<= shft;
+      x &= ~mask;
+      DREG (dst0) = x | fgnd;
+      setflags_logical (DREG (dst0));
+    }
+  else if (sop == 3 && sopcde == 10)
+    {
+      /* dregs = DEPOSIT (dregs, dregs) */
+      bu32 v = DREG (src0);
+      bu32 x = DREG (src1);
+      bu32 mask = (1 << (v & 0x1f)) - 1;
+      bu32 fgnd = ((bs32)(bs16)(v >> 16)) & mask;
+      int shft = ((v >> 8) & 0x1f);
+      fgnd <<= shft;
+      mask <<= shft;
+      x &= ~mask;
+      DREG (dst0) = x | fgnd;
+      setflags_logical (DREG (dst0));
+    }
+  else if (sop == 0 && sopcde == 11)
+    unhandled_instruction ("dregs_lo = CC = BXORSHIFT (A0, dregs)");
+  else if (sop == 1 && sopcde == 11)
+    unhandled_instruction ("dregs_lo = CC = BXOR (A0, dregs)");
+  else if (sop == 0 && sopcde == 12)
+    unhandled_instruction ("A0 = BXORSHIFT (A0, A1, CC)");
+  else if (sop == 1 && sopcde == 12)
+    unhandled_instruction ("dregs_lo = CC = BXOR (A0, A1, CC)");
+  else if (sop == 0 && sopcde == 13)
+    /* dregs = ALIGN8 (dregs, dregs) */
+    DREG (dst0) = (DREG (src1) << 24) | (DREG (src0) >> 8);
+  else if (sop == 1 && sopcde == 13)
+    /* dregs = ALIGN16 (dregs, dregs) */
+    DREG (dst0) = (DREG (src1) << 16) | (DREG (src0) >> 16);
+  else if (sop == 2 && sopcde == 13)
+    /* dregs = ALIGN24 (dregs , dregs) */
+    DREG (dst0) = (DREG (src1) << 8) | (DREG (src0) >> 24);
+  else
+    illegal_instruction ();
+  PCREG += 4;
+}
+
+static void
+decode_dsp32shiftimm_0 (bu16 iw0, bu16 iw1, bu32 pc)
+{
+  /* dsp32shiftimm
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 1 | 0 | 0 |.M.| 1 | 1 | 0 | 1 | - | - |.sopcde............|
+     |.sop...|.HLs...|.dst0......|.immag.................|.src1......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int src1 = ((iw1 >> 0) & 0x7);
+  int sop = ((iw1 >> 14) & 0x3);
+  int immag = ((iw1 >> 3) & 0x3f);
+  int newimmag = (-(iw1 >> 3) & 0x3f);
+  int dst0 = ((iw1 >> 9) & 0x7);
+  int M = ((iw0 >> 11) & 0x1);
+  int sopcde = ((iw0 >> 0) & 0x1f);
+  int HLs = ((iw1 >> 12) & 0x3);
+  int bit8 = immag >> 5;
+
+  if (sopcde == 0)
+    {
+      bu16 in = DREG (src1) >> ((HLs & 1) ? 16 : 0);
+      bu16 result;
+      if (sop == 0 && bit8)
+	result = ashiftrt (in, newimmag, 16);
+      else if (sop == 1 && bit8)
+	result = lshift (in, immag, 16, 1);
+      else if (sop == 2 && bit8)
+	result = lshiftrt (in, newimmag, 16);
+      else if (sop == 2)
+	result = lshift (in, immag, 16, 0);
+      else
+	unhandled_instruction ("illegal DSP shift");
+      if (HLs & 2)
+	{
+	  DREG (dst0) &= 0xFFFF;
+	  DREG (dst0) |= result << 16;
+	}
+      else
+	{
+	  DREG (dst0) &= 0xFFFF0000;
+	  DREG (dst0) |= result;
+	}
+    }
+  else if (sop == 2 && sopcde == 3 && HLs == 1)
+    unhandled_instruction ("A1 = ROT A1 BY imm6");
+  else if (sop == 0 && sopcde == 3 && HLs == 0)
+    unhandled_instruction ("A0 = A0 << imm6");
+  else if (sop == 0 && sopcde == 3 && HLs == 1)
+    unhandled_instruction ("A1 = A1 << imm6");
+  else if (sop == 1 && sopcde == 3 && HLs == 0)
+    unhandled_instruction ("A0 = A0 >> imm6");
+  else if (sop == 1 && sopcde == 3 && HLs == 1)
+    unhandled_instruction ("A1 = A1 >> imm6");
+  else if (sop == 2 && sopcde == 3 && HLs == 0)
+    unhandled_instruction ("A0 = ROT A0 BY imm6");
+  else if (sop == 1 && sopcde == 1)
+    unhandled_instruction ("dregs = dregs >>> uimm5 (V,S)");
+  else if (sop == 2 && sopcde == 1)
+    unhandled_instruction ("dregs = dregs >> uimm5 (V)");
+  else if (sop == 0 && sopcde == 1)
+    unhandled_instruction ("dregs = dregs << imm5 (V)");
+  else if (sop == 1 && sopcde == 2)
+    unhandled_instruction ("dregs = dregs << imm6 (S)");
+  else if (sop == 2 && sopcde == 2)
+    {
+      int count = imm6 (newimmag);
+      /* dregs = dregs >> imm6 */
+      if (count < 0)
+	DREG (dst0) = lshift (DREG (src1), -count, 32, 0);
+      else
+	DREG (dst0) = lshiftrt (DREG (src1), count, 32);
+    }
+  else if (sop == 3 && sopcde == 2)
+    {
+      int t = imm6 (immag);
+      /* dregs = ROT dregs BY imm6 */
+
+      /* Reduce everything to rotate left.  */
+      if (t < 0)
+	t += 33;
+
+      if (t > 0)
+	{
+	  int oldcc = CCREG;
+	  bu32 srcval = DREG (src1);
+	  bu32 result;
+	  result = t == 32 ? 0 : srcval << t;
+	  result |= t == 1 ? 0 : srcval >> (33 - t);
+	  result |= oldcc << (t - 1);
+	  DREG (dst0) = result;
+	  CCREG = (srcval >> (32 - t)) & 1;
+	}
+    }
+  else if (sop == 0 && sopcde == 2)
+    {
+      int count = imm6 (newimmag);
+      /* dregs = dregs >>> imm6 */
+      if (count < 0)
+	DREG (dst0) = lshift (DREG (src1), -count, 32, 0);
+      else
+	DREG (dst0) = ashiftrt (DREG (src1), count, 32);
+    }
+  else
+    illegal_instruction ();
+
+  PCREG += 4;
+}
+
+static void
+decode_psedoDEBUG_0 (bu16 iw0)
+{
+  /* psedoDEBUG
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |.fn....|.grp.......|.reg.......|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int grp = ((iw0 >> 3) & 0x7);
+  int fn = ((iw0 >> 6) & 0x3);
+  int reg = ((iw0 >> 0) & 0x7);
+
+  if (reg == 0 && fn == 3)
+    unhandled_instruction ("DBG A0");
+  else if (reg == 1 && fn == 3)
+    unhandled_instruction ("DBG A1");
+  else if (reg == 3 && fn == 3)
+    unhandled_instruction ("ABORT");
+  else if (reg == 4 && fn == 3)
+    unhandled_instruction ("HLT");
+  else if (reg == 5 && fn == 3)
+    unhandled_instruction ("DBGHALT");
+  else if (reg == 6 && fn == 3)
+    unhandled_instruction ("DBGCMPLX (dregs)");
+  else if (reg == 7 && fn == 3)
+    unhandled_instruction ("DBG");
+  else if (grp == 0 && fn == 2)
+    unhandled_instruction ("OUTC dregs");
+  else if (fn == 0)
+    unhandled_instruction ("DBG allregs");
+  else if (fn == 1)
+    unhandled_instruction ("PRNT allregs");
+  else
+    illegal_instruction ();
+
+  PCREG += 2;
+}
+
+static void
+decode_psedoOChar_0 (bu16 iw0)
+{
+  /* psedoOChar
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 1 |.ch............................|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int ch = ((iw0 >> 0) & 0xff);
+
+  unhandled_instruction ("OUTC uimm8");
+  PCREG += 2;
+}
+
+static void
+decode_psedodbg_assert_0 (bu16 iw0, bu16 iw1)
+{
+  /* psedodbg_assert
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
+     | 1 | 1 | 1 | 1 | 0 | - | - | - | - | - |.dbgop.....|.regtest...|
+     |.expected......................................................|
+     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
+  int expected = ((iw1 >> 0) & 0xffff);
+  int dbgop = ((iw0 >> 3) & 0x7);
+  int regtest = ((iw0 >> 0) & 0x7);
+
+  if (dbgop == 0)
+    unhandled_instruction ("DBGA ( dregs_lo , uimm16 )");
+  else if (dbgop == 1)
+    unhandled_instruction ("DBGA ( dregs_hi , uimm16 )");
+  else if (dbgop == 2)
+    unhandled_instruction ("DBGAL ( dregs , uimm16 )");
+  else if (dbgop == 3)
+    unhandled_instruction ("DBGAH ( dregs , uimm16 )");
+  else
+    illegal_instruction ();
+  PCREG += 4;
+}
+
+static void
+_interp_insn_bfin (bu32 pc)
+{
+  bu8 buf[4];
+  bu16 iw0 = get_word (saved_state.memory, pc);
+  bu16 iw1 = get_word (saved_state.memory, pc + 2);
+
+  if ((iw0 & 0xf7ff) == 0xc003 && iw1 == 0x1800)
+    {
+      /* MNOP.  */
+      PCREG += 4;
+      return;
+    }
+  if ((iw0 & 0xFF00) == 0x0000)
+    decode_ProgCtrl_0 (iw0);
+  else if ((iw0 & 0xFFC0) == 0x0240)
+    decode_CaCTRL_0 (iw0);
+  else if ((iw0 & 0xFF80) == 0x0100)
+    decode_PushPopReg_0 (iw0);
+  else if ((iw0 & 0xFE00) == 0x0400)
+    decode_PushPopMultiple_0 (iw0);
+  else if ((iw0 & 0xFE00) == 0x0600)
+    decode_ccMV_0 (iw0);
+  else if ((iw0 & 0xF800) == 0x0800)
+    decode_CCflag_0 (iw0);
+  else if ((iw0 & 0xFFE0) == 0x0200)
+    decode_CC2dreg_0 (iw0);
+  else if ((iw0 & 0xFF00) == 0x0300)
+    decode_CC2stat_0 (iw0);
+  else if ((iw0 & 0xF000) == 0x1000)
+    decode_BRCC_0 (iw0, pc);
+  else if ((iw0 & 0xF000) == 0x2000)
+    decode_UJUMP_0 (iw0, pc);
+  else if ((iw0 & 0xF000) == 0x3000)
+    decode_REGMV_0 (iw0);
+  else if ((iw0 & 0xFC00) == 0x4000)
+    decode_ALU2op_0 (iw0);
+  else if ((iw0 & 0xFE00) == 0x4400)
+    decode_PTR2op_0 (iw0);
+  else if (((iw0 & 0xF800) == 0x4800))
+    decode_LOGI2op_0 (iw0);
+  else if (((iw0 & 0xF000) == 0x5000))
+    decode_COMP3op_0 (iw0);
+  else if (((iw0 & 0xF800) == 0x6000))
+    decode_COMPI2opD_0 (iw0);
+  else if (((iw0 & 0xF800) == 0x6800))
+    decode_COMPI2opP_0 (iw0);
+  else if (((iw0 & 0xF000) == 0x8000))
+    decode_LDSTpmod_0 (iw0);
+  else if (((iw0 & 0xFF60) == 0x9E60))
+    decode_dagMODim_0 (iw0);
+  else if (((iw0 & 0xFFF0) == 0x9F60))
+    decode_dagMODik_0 (iw0);
+  else if (((iw0 & 0xFC00) == 0x9C00))
+    decode_dspLDST_0 (iw0);
+  else if (((iw0 & 0xF000) == 0x9000))
+    decode_LDST_0 (iw0);
+  else if (((iw0 & 0xFC00) == 0xB800))
+    decode_LDSTiiFP_0 (iw0);
+  else if (((iw0 & 0xE000) == 0xA000))
+    decode_LDSTii_0 (iw0);
+  else if (((iw0 & 0xFF80) == 0xE080) && ((iw1 & 0x0C00) == 0x0000))
+    decode_LoopSetup_0 (iw0, iw1, pc);
+  else if (((iw0 & 0xFF00) == 0xE100) && ((iw1 & 0x0000) == 0x0000))
+    decode_LDIMMhalf_0 (iw0, iw1, pc);
+  else if (((iw0 & 0xFE00) == 0xE200) && ((iw1 & 0x0000) == 0x0000))
+    decode_CALLa_0 (iw0, iw1, pc);
+  else if (((iw0 & 0xFC00) == 0xE400) && ((iw1 & 0x0000) == 0x0000))
+    decode_LDSTidxI_0 (iw0, iw1, pc);
+  else if (((iw0 & 0xFFFE) == 0xE800) && ((iw1 & 0x0000) == 0x0000))
+    decode_linkage_0 (iw0, iw1);
+  else if (((iw0 & 0xF600) == 0xC000) && ((iw1 & 0x0000) == 0x0000))
+    decode_dsp32mac_0 (iw0, iw1, pc);
+  else if (((iw0 & 0xF600) == 0xC200) && ((iw1 & 0x0000) == 0x0000))
+    decode_dsp32mult_0 (iw0, iw1, pc);
+  else if (((iw0 & 0xF7C0) == 0xC400) && ((iw1 & 0x0000) == 0x0000))
+    decode_dsp32alu_0 (iw0, iw1, pc);
+  else if (((iw0 & 0xF7E0) == 0xC600) && ((iw1 & 0x01C0) == 0x0000))
+    decode_dsp32shift_0 (iw0, iw1, pc);
+  else if (((iw0 & 0xF7E0) == 0xC680) && ((iw1 & 0x0000) == 0x0000))
+    decode_dsp32shiftimm_0 (iw0, iw1, pc);
+  else if (((iw0 & 0xFF00) == 0xF800))
+    decode_psedoDEBUG_0 (iw0);
+  else if (((iw0 & 0xFF00) == 0xF900))
+    decode_psedoOChar_0 (iw0);
+  else if (((iw0 & 0xFFC0) == 0xF000) && ((iw1 & 0x0000) == 0x0000))
+    decode_psedodbg_assert_0 (iw0, iw1);
+  else
+    illegal_instruction ();
+}
+
+void
+interp_insn_bfin (bu32 pc)
+{
+  int i;
+  bu16 iw0 = get_word (saved_state.memory, pc);
+  
+  int is_multiinsn = ((iw0 & 0xc000) == 0xc000 && (iw0 & BIT_MULTI_INS)
+		      && ((iw0 & 0xe800) != 0xe800 /* not linkage */));
+
+  n_stores = 0;
+
+  _interp_insn_bfin (pc);
+  
+  /* Proper display of multiple issue instructions.  */
+  if (is_multiinsn)
+    {
+      _interp_insn_bfin (pc + 4);
+      _interp_insn_bfin (pc + 6);
+    }
+  for (i = 0; i < n_stores; i++)
+    *stores[i].addr = stores[i].val;
+}
diff -Naur gdb-6.5.orig/sim/bfin/bfin-sim.h gdb-6.5/sim/bfin/bfin-sim.h
--- gdb-6.5.orig/sim/bfin/bfin-sim.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/sim/bfin/bfin-sim.h	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,124 @@
+/* Simulator for Analog Devices Blackfin processer.
+
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Analog Devices.
+
+   This file is part of simulators.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "gdb/callback.h"
+#include "gdb/remote-sim.h"
+#include "sim-config.h"
+#include "sim-types.h"
+
+typedef unsigned8 bu8;
+typedef unsigned16 bu16;
+typedef unsigned32 bu32;
+typedef unsigned64 bu64;
+typedef signed8 bs8;
+typedef signed16 bs16;
+typedef signed32 bs32;
+typedef signed64 bs64;
+
+typedef struct
+{
+  bu32 dpregs[16], iregs[4], mregs[4], bregs[4], lregs[4];
+  bu32 a0x, a0w, a1x, a1w;
+  bu32 lt[2], lc[2], lb[2];
+  int ac0, ac0_copy, ac1, an, aq;
+  int av0, av0s, av1, av1s, az, cc, v, v_copy, vs;
+  int v_internal;
+  bu32 pc, rets;
+
+  int ticks;
+  int insts;
+
+  int exception;
+
+  int end_of_registers;
+
+  int msize;
+  unsigned char *memory;
+  unsigned long bfd_mach;
+} saved_state_type;
+
+extern saved_state_type saved_state;
+
+#define GREG(x,i)	DPREG ((x) | (i << 3))
+#define DPREG(x)	(saved_state.dpregs[x])
+#define DREG(x)		(saved_state.dpregs[x])
+#define PREG(x)		(saved_state.dpregs[x + 8])
+#define SPREG		PREG (6)
+#define FPREG		PREG (7)
+#define IREG(x)		(saved_state.iregs[x])
+#define MREG(x)		(saved_state.mregs[x])
+#define BREG(x)		(saved_state.bregs[x])
+#define LREG(x)		(saved_state.lregs[x])
+#define A0XREG		(saved_state.a0x)
+#define A0WREG		(saved_state.a0w)
+#define A1XREG		(saved_state.a1x)
+#define A1WREG		(saved_state.a1w)
+#define CCREG		(saved_state.cc)
+#define LC0REG		(saved_state.lc[0])
+#define LT0REG		(saved_state.lt[0])
+#define LB0REG		(saved_state.lb[0])
+#define LC1REG		(saved_state.lc[1])
+#define LT1REG		(saved_state.lt[1])
+#define LB1REG		(saved_state.lb[1])
+#define RETSREG		(saved_state.rets)
+#define PCREG		(saved_state.pc)
+
+extern int did_jump;
+
+static inline void put_byte (unsigned char *memory, bu32 addr, bu8 v)
+{
+  memory[addr] = v;
+}
+
+static inline void put_word (unsigned char *memory, bu32 addr, bu16 v)
+{
+  memory[addr] = v;
+  memory[addr + 1] = v >> 8;
+}
+
+static inline void put_long (unsigned char *memory, bu32 addr, bu32 v)
+{
+  memory[addr] = v;
+  memory[addr + 1] = v >> 8;
+  memory[addr + 2] = v >> 16;
+  memory[addr + 3] = v >> 24;
+}
+
+static inline bu8 get_byte (unsigned char *memory, bu32 addr)
+{
+  return memory[addr];
+}
+
+static inline bu16 get_word (unsigned char *memory, bu32 addr)
+{
+  return (memory[addr] | (memory[addr + 1] << 8));
+}
+
+static inline bu32 get_long (unsigned char *memory, bu32 addr)
+{
+  return (memory[addr] | (memory[addr + 1] << 8)
+	  | (memory[addr + 2] << 16) | (memory[addr + 3] << 24));
+}
+
+extern void interp_insn_bfin (bu32);
+
diff -Naur gdb-6.5.orig/sim/bfin/config.in gdb-6.5/sim/bfin/config.in
--- gdb-6.5.orig/sim/bfin/config.in	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/sim/bfin/config.in	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,158 @@
+/* config.in.  Generated automatically from configure.in by autoheader.  */
+
+/* Define if using alloca.c.  */
+#undef C_ALLOCA
+
+/* Define to empty if the keyword does not work.  */
+#undef const
+
+/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.
+   This function is required for alloca.c support on those systems.  */
+#undef CRAY_STACKSEG_END
+
+/* Define if you have alloca, as a function or macro.  */
+#undef HAVE_ALLOCA
+
+/* Define if you have <alloca.h> and it should be used (not on Ultrix).  */
+#undef HAVE_ALLOCA_H
+
+/* Define if you have a working `mmap' system call.  */
+#undef HAVE_MMAP
+
+/* Define as __inline if that's what the C compiler calls it.  */
+#undef inline
+
+/* Define to `long' if <sys/types.h> doesn't define.  */
+#undef off_t
+
+/* Define if you need to in order for stat and other things to work.  */
+#undef _POSIX_SOURCE
+
+/* Define as the return type of signal handlers (int or void).  */
+#undef RETSIGTYPE
+
+/* Define to `unsigned' if <sys/types.h> doesn't define.  */
+#undef size_t
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at run-time.
+ STACK_DIRECTION > 0 => grows toward higher addresses
+ STACK_DIRECTION < 0 => grows toward lower addresses
+ STACK_DIRECTION = 0 => direction of growth unknown
+ */
+#undef STACK_DIRECTION
+
+/* Define if you have the ANSI C header files.  */
+#undef STDC_HEADERS
+
+/* Define to 1 if NLS is requested.  */
+#undef ENABLE_NLS
+
+/* Define as 1 if you have gettext and don't want to use GNU gettext.  */
+#undef HAVE_GETTEXT
+
+/* Define as 1 if you have the stpcpy function.  */
+#undef HAVE_STPCPY
+
+/* Define if your locale.h file contains LC_MESSAGES.  */
+#undef HAVE_LC_MESSAGES
+
+/* Define if you have the __argz_count function.  */
+#undef HAVE___ARGZ_COUNT
+
+/* Define if you have the __argz_next function.  */
+#undef HAVE___ARGZ_NEXT
+
+/* Define if you have the __argz_stringify function.  */
+#undef HAVE___ARGZ_STRINGIFY
+
+/* Define if you have the __setfpucw function.  */
+#undef HAVE___SETFPUCW
+
+/* Define if you have the dcgettext function.  */
+#undef HAVE_DCGETTEXT
+
+/* Define if you have the getcwd function.  */
+#undef HAVE_GETCWD
+
+/* Define if you have the getpagesize function.  */
+#undef HAVE_GETPAGESIZE
+
+/* Define if you have the getrusage function.  */
+#undef HAVE_GETRUSAGE
+
+/* Define if you have the munmap function.  */
+#undef HAVE_MUNMAP
+
+/* Define if you have the putenv function.  */
+#undef HAVE_PUTENV
+
+/* Define if you have the setenv function.  */
+#undef HAVE_SETENV
+
+/* Define if you have the setlocale function.  */
+#undef HAVE_SETLOCALE
+
+/* Define if you have the sigaction function.  */
+#undef HAVE_SIGACTION
+
+/* Define if you have the stpcpy function.  */
+#undef HAVE_STPCPY
+
+/* Define if you have the strcasecmp function.  */
+#undef HAVE_STRCASECMP
+
+/* Define if you have the strchr function.  */
+#undef HAVE_STRCHR
+
+/* Define if you have the time function.  */
+#undef HAVE_TIME
+
+/* Define if you have the <argz.h> header file.  */
+#undef HAVE_ARGZ_H
+
+/* Define if you have the <fcntl.h> header file.  */
+#undef HAVE_FCNTL_H
+
+/* Define if you have the <fpu_control.h> header file.  */
+#undef HAVE_FPU_CONTROL_H
+
+/* Define if you have the <limits.h> header file.  */
+#undef HAVE_LIMITS_H
+
+/* Define if you have the <locale.h> header file.  */
+#undef HAVE_LOCALE_H
+
+/* Define if you have the <malloc.h> header file.  */
+#undef HAVE_MALLOC_H
+
+/* Define if you have the <nl_types.h> header file.  */
+#undef HAVE_NL_TYPES_H
+
+/* Define if you have the <stdlib.h> header file.  */
+#undef HAVE_STDLIB_H
+
+/* Define if you have the <string.h> header file.  */
+#undef HAVE_STRING_H
+
+/* Define if you have the <strings.h> header file.  */
+#undef HAVE_STRINGS_H
+
+/* Define if you have the <sys/param.h> header file.  */
+#undef HAVE_SYS_PARAM_H
+
+/* Define if you have the <sys/resource.h> header file.  */
+#undef HAVE_SYS_RESOURCE_H
+
+/* Define if you have the <sys/time.h> header file.  */
+#undef HAVE_SYS_TIME_H
+
+/* Define if you have the <time.h> header file.  */
+#undef HAVE_TIME_H
+
+/* Define if you have the <unistd.h> header file.  */
+#undef HAVE_UNISTD_H
+
+/* Define if you have the <values.h> header file.  */
+#undef HAVE_VALUES_H
diff -Naur gdb-6.5.orig/sim/bfin/configure gdb-6.5/sim/bfin/configure
--- gdb-6.5.orig/sim/bfin/configure	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/sim/bfin/configure	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,8672 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.59.
+#
+# Copyright (C) 2003 Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+exec 6>&1
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_config_libobj_dir=.
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Maximum number of lines to put in a shell here document.
+# This variable seems obsolete.  It should probably be removed, and
+# only ac_max_sed_lines should be used.
+: ${ac_max_here_lines=38}
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+
+ac_unique_file="Makefile.in"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#if HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# if HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#if HAVE_STRING_H
+# if !STDC_HEADERS && HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#if HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#if HAVE_INTTYPES_H
+# include <inttypes.h>
+#else
+# if HAVE_STDINT_H
+#  include <stdint.h>
+# endif
+#endif
+#if HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS sim_environment sim_alignment sim_assert sim_bitsize sim_endian sim_hostendian sim_float sim_scache sim_default_model sim_hw_cflags sim_hw_objs sim_hw sim_inline sim_packages sim_regparm sim_reserved_bits sim_smp sim_stdcall sim_xor_endian WARN_CFLAGS WERROR_CFLAGS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CC_FOR_BUILD HDEFINES AR RANLIB ac_ct_RANLIB SET_MAKE CPP EGREP ALLOCA USE_NLS MSGFMT GMSGFMT XGETTEXT USE_INCLUDED_LIBINTL CATALOGS CATOBJEXT DATADIRNAME GMOFILES INSTOBJEXT INTLDEPS INTLLIBS INTLOBJS POFILES POSUB INCLUDE_LOCALE_H GT_NO GT_YES MKINSTALLDIRS l MAINT sim_bswap sim_cflags sim_debug sim_stdio sim_trace sim_profile cgen_breaks LIBOBJS LTLIBOBJS'
+ac_subst_files=''
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+ac_prev=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_option in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    eval "enable_$ac_feature=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_$ac_feature='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_$ac_package='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/-/_/g'`
+    eval "with_$ac_package=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
+    eval "$ac_envvar='$ac_optarg'"
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute paths.
+for ac_var in exec_prefix prefix
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# Be sure to have absolute paths.
+for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
+	      localstatedir libdir includedir oldincludedir infodir mandir
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_confdir=`(dirname "$0") 2>/dev/null ||
+$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$0" : 'X\(//\)[^/]' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$0" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or .." >&2
+   { (exit 1); exit 1; }; }
+  else
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+  fi
+fi
+(cd $srcdir && test -r ./$ac_unique_file) 2>/dev/null ||
+  { echo "$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work" >&2
+   { (exit 1); exit 1; }; }
+srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
+ac_env_build_alias_set=${build_alias+set}
+ac_env_build_alias_value=$build_alias
+ac_cv_env_build_alias_set=${build_alias+set}
+ac_cv_env_build_alias_value=$build_alias
+ac_env_host_alias_set=${host_alias+set}
+ac_env_host_alias_value=$host_alias
+ac_cv_env_host_alias_set=${host_alias+set}
+ac_cv_env_host_alias_value=$host_alias
+ac_env_target_alias_set=${target_alias+set}
+ac_env_target_alias_value=$target_alias
+ac_cv_env_target_alias_set=${target_alias+set}
+ac_cv_env_target_alias_value=$target_alias
+ac_env_CC_set=${CC+set}
+ac_env_CC_value=$CC
+ac_cv_env_CC_set=${CC+set}
+ac_cv_env_CC_value=$CC
+ac_env_CFLAGS_set=${CFLAGS+set}
+ac_env_CFLAGS_value=$CFLAGS
+ac_cv_env_CFLAGS_set=${CFLAGS+set}
+ac_cv_env_CFLAGS_value=$CFLAGS
+ac_env_LDFLAGS_set=${LDFLAGS+set}
+ac_env_LDFLAGS_value=$LDFLAGS
+ac_cv_env_LDFLAGS_set=${LDFLAGS+set}
+ac_cv_env_LDFLAGS_value=$LDFLAGS
+ac_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_env_CPPFLAGS_value=$CPPFLAGS
+ac_cv_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_cv_env_CPPFLAGS_value=$CPPFLAGS
+ac_env_CPP_set=${CPP+set}
+ac_env_CPP_value=$CPP
+ac_cv_env_CPP_set=${CPP+set}
+ac_cv_env_CPP_value=$CPP
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+_ACEOF
+
+  cat <<_ACEOF
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+			  [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+			  [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --infodir=DIR          info documentation [PREFIX/info]
+  --mandir=DIR           man documentation [PREFIX/man]
+_ACEOF
+
+  cat <<\_ACEOF
+
+Program names:
+  --program-prefix=PREFIX            prepend PREFIX to installed program names
+  --program-suffix=SUFFIX            append SUFFIX to installed program names
+  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+  --target=TARGET   configure for building compilers for TARGET [HOST]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --disable-nls           do not use Native Language Support
+  --enable-maintainer-mode		Enable developer functionality.
+  --enable-sim-bswap			Use Host specific BSWAP instruction.
+  --enable-sim-cflags=opts		Extra CFLAGS for use in building simulator
+  --enable-sim-debug=opts		Enable debugging flags
+  --enable-sim-stdio			Specify whether to use stdio for console input/output.
+  --enable-sim-trace=opts		Enable tracing flags
+  --enable-sim-profile=opts		Enable profiling flags
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-included-gettext use the GNU gettext library included here
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  CPPFLAGS    C/C++ preprocessor flags, e.g. -I<include dir> if you have
+              headers in a nonstandard directory <include dir>
+  CPP         C preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+_ACEOF
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  ac_popdir=`pwd`
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d $ac_dir || continue
+    ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+    cd $ac_dir
+    # Check for guested configure; otherwise get Cygnus style configure.
+    if test -f $ac_srcdir/configure.gnu; then
+      echo
+      $SHELL $ac_srcdir/configure.gnu  --help=recursive
+    elif test -f $ac_srcdir/configure; then
+      echo
+      $SHELL $ac_srcdir/configure  --help=recursive
+    elif test -f $ac_srcdir/configure.ac ||
+	   test -f $ac_srcdir/configure.in; then
+      echo
+      $ac_configure --help
+    else
+      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi
+    cd $ac_popdir
+  done
+fi
+
+test -n "$ac_init_help" && exit 0
+if $ac_init_version; then
+  cat <<\_ACEOF
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit 0
+fi
+exec 5>config.log
+cat >&5 <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  echo "PATH: $as_dir"
+done
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_sep=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
+      # Get rid of the leading space.
+      ac_sep=" "
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Be sure not to use single quotes in there, as some shells,
+# such as our DU 5.0 friend, will then `close' the trap.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+{
+  (set) 2>&1 |
+    case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      sed -n \
+	"s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
+      ;;
+    *)
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+}
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=$`echo $ac_var`
+      echo "$ac_var='"'"'$ac_val'"'"'"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------- ##
+## Output files. ##
+## ------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=$`echo $ac_var`
+	echo "$ac_var='"'"'$ac_val'"'"'"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      sed "/^$/d" confdefs.h | sort
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      echo "$as_me: caught signal $ac_signal"
+    echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core &&
+  rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+     ' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo >confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
+echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . $cache_file;;
+      *)                      . ./$cache_file;;
+    esac
+  fi
+else
+  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
+echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in `(set) 2>&1 |
+	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val="\$ac_cv_env_${ac_var}_value"
+  eval ac_new_val="\$ac_env_${ac_var}_value"
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+echo "$as_me:   former value:  $ac_old_val" >&2;}
+	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+echo "$as_me:   current value: $ac_new_val" >&2;}
+	ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+          ac_config_headers="$ac_config_headers config.h:config.in"
+
+
+# This file contains common code used by all simulators.
+#
+# SIM_AC_COMMON invokes AC macros used by all simulators and by the common
+# directory.  It is intended to be invoked before any target specific stuff.
+# SIM_AC_OUTPUT is a cover function to AC_OUTPUT to generate the Makefile.
+# It is intended to be invoked last.
+#
+# The simulator's configure.in should look like:
+#
+# dnl Process this file with autoconf to produce a configure script.
+# sinclude(../common/aclocal.m4)
+# AC_PREREQ(2.5)dnl
+# AC_INIT(Makefile.in)
+#
+# SIM_AC_COMMON
+#
+# ... target specific stuff ...
+#
+# SIM_AC_OUTPUT
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+sim_inline="-DDEFAULT_INLINE=0"
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# This file is derived from `gettext.m4'.  The difference is that the
+# included macros assume Cygnus-style source and build trees.
+
+# Macro to add for using GNU gettext.
+# Ulrich Drepper <drepper@cygnus.com>, 1995.
+#
+# This file file be copied and used freely without restrictions.  It can
+# be used in projects which are not available under the GNU Public License
+# but which still want to provide support for the GNU gettext functionality.
+# Please note that the actual code is *not* freely available.
+
+# serial 3
+
+
+
+
+
+# Search path for a program which passes the given test.
+# Ulrich Drepper <drepper@cygnus.com>, 1996.
+#
+# This file file be copied and used freely without restrictions.  It can
+# be used in projects which are not available under the GNU Public License
+# but which still want to provide support for the GNU gettext functionality.
+# Please note that the actual code is *not* freely available.
+
+# serial 1
+
+
+
+# Check whether LC_MESSAGES is available in <locale.h>.
+# Ulrich Drepper <drepper@cygnus.com>, 1995.
+#
+# This file file be copied and used freely without restrictions.  It can
+# be used in projects which are not available under the GNU Public License
+# but which still want to provide support for the GNU gettext functionality.
+# Please note that the actual code is *not* freely available.
+
+# serial 1
+
+
+
+
+
+
+
+# This file contains common code used by all simulators.
+#
+# common.m4 invokes AC macros used by all simulators and by the common
+# directory.  It is intended to be included before any target specific
+# stuff.  SIM_AC_OUTPUT is a cover function to AC_OUTPUT to generate
+# the Makefile.  It is intended to be invoked last.
+#
+# The simulator's configure.in should look like:
+#
+# dnl Process this file with autoconf to produce a configure script.
+# AC_PREREQ(2.5)dnl
+# AC_INIT(Makefile.in)
+# AC_CONFIG_HEADER(config.h:config.in)
+#
+# sinclude(../common/aclocal.m4)
+# sinclude(../common/common.m4)
+#
+# ... target specific stuff ...
+
+ac_aux_dir=
+for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f $ac_dir/shtool; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&5
+echo "$as_me: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"
+ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
+
+# Make sure we can run config.sub.
+$ac_config_sub sun4 >/dev/null 2>&1 ||
+  { { echo "$as_me:$LINENO: error: cannot run $ac_config_sub" >&5
+echo "$as_me: error: cannot run $ac_config_sub" >&2;}
+   { (exit 1); exit 1; }; }
+
+echo "$as_me:$LINENO: checking build system type" >&5
+echo $ECHO_N "checking build system type... $ECHO_C" >&6
+if test "${ac_cv_build+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_build_alias=$build_alias
+test -z "$ac_cv_build_alias" &&
+  ac_cv_build_alias=`$ac_config_guess`
+test -z "$ac_cv_build_alias" &&
+  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_build_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+echo "${ECHO_T}$ac_cv_build" >&6
+build=$ac_cv_build
+build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking host system type" >&5
+echo $ECHO_N "checking host system type... $ECHO_C" >&6
+if test "${ac_cv_host+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_host_alias=$host_alias
+test -z "$ac_cv_host_alias" &&
+  ac_cv_host_alias=$ac_cv_build_alias
+ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_host_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+echo "${ECHO_T}$ac_cv_host" >&6
+host=$ac_cv_host
+host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking target system type" >&5
+echo $ECHO_N "checking target system type... $ECHO_C" >&6
+if test "${ac_cv_target+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_target_alias=$target_alias
+test "x$ac_cv_target_alias" = "x" &&
+  ac_cv_target_alias=$ac_cv_host_alias
+ac_cv_target=`$ac_config_sub $ac_cv_target_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_target_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_target_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_target" >&5
+echo "${ECHO_T}$ac_cv_target" >&6
+target=$ac_cv_target
+target_cpu=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+test "$program_prefix" != NONE &&
+  program_transform_name="s,^,$program_prefix,;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s,\$,$program_suffix,;$program_transform_name"
+# Double any \ or $.  echo might interpret backslashes.
+# By default was `s,x,x', remove it if useless.
+cat <<\_ACEOF >conftest.sed
+s/[\\$]/&&/g;s/;s,x,x,$//
+_ACEOF
+program_transform_name=`echo $program_transform_name | sed -f conftest.sed`
+rm conftest.sed
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$ac_ct_CC" && break
+done
+
+  CC=$ac_ct_CC
+fi
+
+fi
+
+
+test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&5
+echo "$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+
+# Provide some information about the compiler.
+echo "$as_me:$LINENO:" \
+     "checking for C compiler version" >&5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
+  (eval $ac_compiler --version </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -v </dev/null >&5\"") >&5
+  (eval $ac_compiler -v </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -V </dev/null >&5\"") >&5
+  (eval $ac_compiler -V </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
+echo $ECHO_N "checking for C compiler default output file name... $ECHO_C" >&6
+ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+if { (eval echo "$as_me:$LINENO: \"$ac_link_default\"") >&5
+  (eval $ac_link_default) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # Find the output, starting from the most likely.  This scheme is
+# not robust to junk in `.', hence go to wildcards (a.*) only as a last
+# resort.
+
+# Be careful to initialize this variable, since it used to be cached.
+# Otherwise an old cache value of `no' led to `EXEEXT = no' in a Makefile.
+ac_cv_exeext=
+# b.out is created by i960 compilers.
+for ac_file in a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj )
+	;;
+    conftest.$ac_ext )
+	# This is the source file.
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	# FIXME: I believe we export ac_cv_exeext for Libtool,
+	# but it would be cool to find out if it's true.  Does anybody
+	# maintain Libtool? --akim.
+	export ac_cv_exeext
+	break;;
+    * )
+	break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: C compiler cannot create executables
+See \`config.log' for more details." >&5
+echo "$as_me: error: C compiler cannot create executables
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }
+fi
+
+ac_exeext=$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_file" >&5
+echo "${ECHO_T}$ac_file" >&6
+
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo "$as_me:$LINENO: checking whether the C compiler works" >&5
+echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
+# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
+# If not cross compiling, check that we can run a simple program.
+if test "$cross_compiling" != yes; then
+  if { ac_try='./$ac_file'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+  fi
+fi
+echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+rm -f a.out a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
+echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6
+echo "$as_me:$LINENO: result: $cross_compiling" >&5
+echo "${ECHO_T}$cross_compiling" >&6
+
+echo "$as_me:$LINENO: checking for suffix of executables" >&5
+echo $ECHO_N "checking for suffix of executables... $ECHO_C" >&6
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  export ac_cv_exeext
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
+echo "${ECHO_T}$ac_cv_exeext" >&6
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+echo "$as_me:$LINENO: checking for suffix of object files" >&5
+echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6
+if test "${ac_cv_objext+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2>/dev/null`; do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
+echo "${ECHO_T}$ac_cv_objext" >&6
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
+if test "${ac_cv_c_compiler_gnu+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_compiler_gnu=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_compiler_gnu=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
+GCC=`test $ac_compiler_gnu = yes && echo yes`
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+CFLAGS="-g"
+echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_g+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_prog_cc_g=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+echo "$as_me:$LINENO: checking for $CC option to accept ANSI C" >&5
+echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_prog_cc_stdc=no
+ac_save_CC=$CC
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std1 is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std1.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+# Don't try gcc -ansi; that turns off useful extensions and
+# breaks some systems' header files.
+# AIX			-qlanglvl=ansi
+# Ultrix and OSF/1	-std1
+# HP-UX 10.20 and later	-Ae
+# HP-UX older versions	-Aa -D_HPUX_SOURCE
+# SVR4			-Xc -D__EXTENSIONS__
+for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_stdc=$ac_arg
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext
+done
+rm -f conftest.$ac_ext conftest.$ac_objext
+CC=$ac_save_CC
+
+fi
+
+case "x$ac_cv_prog_cc_stdc" in
+  x|xno)
+    echo "$as_me:$LINENO: result: none needed" >&5
+echo "${ECHO_T}none needed" >&6 ;;
+  *)
+    echo "$as_me:$LINENO: result: $ac_cv_prog_cc_stdc" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
+    CC="$CC $ac_cv_prog_cc_stdc" ;;
+esac
+
+# Some people use a C++ compiler to compile C.  Since we use `exit',
+# in C++ we need to declare it.  In case someone uses the same compiler
+# for both compiling C and C++ we need to have the C++ compiler decide
+# the declaration of exit, since it's the most demanding environment.
+cat >conftest.$ac_ext <<_ACEOF
+#ifndef __cplusplus
+  choke me
+#endif
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  for ac_declaration in \
+   '' \
+   'extern "C" void std::exit (int) throw (); using std::exit;' \
+   'extern "C" void std::exit (int); using std::exit;' \
+   'extern "C" void exit (int) throw ();' \
+   'extern "C" void exit (int);' \
+   'void exit (int);'
+do
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+#include <stdlib.h>
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+continue
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+rm -f conftest*
+if test -n "$ac_declaration"; then
+  echo '#ifdef __cplusplus' >>confdefs.h
+  echo $ac_declaration      >>confdefs.h
+  echo '#endif'             >>confdefs.h
+fi
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	    break 3
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+done
+
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL=$ac_install_sh
+  fi
+fi
+echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+
+# Put a plausible default for CC_FOR_BUILD in Makefile.
+if test "x$cross_compiling" = "xno"; then
+  CC_FOR_BUILD='$(CC)'
+else
+  CC_FOR_BUILD=gcc
+fi
+
+
+
+
+AR=${AR-ar}
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  echo "$as_me:$LINENO: result: $RANLIB" >&5
+echo "${ECHO_T}$RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_prog_ac_ct_RANLIB" && ac_cv_prog_ac_ct_RANLIB=":"
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
+echo "${ECHO_T}$ac_ct_RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  RANLIB=$ac_ct_RANLIB
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+
+ALL_LINGUAS=
+echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+echo $ECHO_N "checking whether ${MAKE-make} sets \$(MAKE)... $ECHO_C" >&6
+set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y,:./+-,___p_,'`
+if eval "test \"\${ac_cv_prog_make_${ac_make}_set+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.make <<\_ACEOF
+all:
+	@echo 'ac_maketemp="$(MAKE)"'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+eval `${MAKE-make} -f conftest.make 2>/dev/null | grep temp=`
+if test -n "$ac_maketemp"; then
+  eval ac_cv_prog_make_${ac_make}_set=yes
+else
+  eval ac_cv_prog_make_${ac_make}_set=no
+fi
+rm -f conftest.make
+fi
+if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  SET_MAKE=
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+
+echo "$as_me:$LINENO: checking for library containing strerror" >&5
+echo $ECHO_N "checking for library containing strerror... $ECHO_C" >&6
+if test "${ac_cv_search_strerror+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_strerror=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char strerror ();
+int
+main ()
+{
+strerror ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_strerror="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_strerror" = no; then
+  for ac_lib in cposix; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char strerror ();
+int
+main ()
+{
+strerror ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_strerror="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_strerror" >&5
+echo "${ECHO_T}$ac_cv_search_strerror" >&6
+if test "$ac_cv_search_strerror" != no; then
+  test "$ac_cv_search_strerror" = "none required" || LIBS="$ac_cv_search_strerror $LIBS"
+
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
+echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+echo "$as_me:$LINENO: result: $CPP" >&5
+echo "${ECHO_T}$CPP" >&6
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&5
+echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6
+if test "${ac_cv_prog_egrep+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
+    then ac_cv_prog_egrep='grep -E'
+    else ac_cv_prog_egrep='egrep'
+    fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
+echo "${ECHO_T}$ac_cv_prog_egrep" >&6
+ EGREP=$ac_cv_prog_egrep
+
+
+echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
+if test "${ac_cv_header_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_stdc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_stdc=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      exit(2);
+  exit (0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for an ANSI C-conforming const" >&5
+echo $ECHO_N "checking for an ANSI C-conforming const... $ECHO_C" >&6
+if test "${ac_cv_c_const+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+/* FIXME: Include the comments suggested by Paul. */
+#ifndef __cplusplus
+  /* Ultrix mips cc rejects this.  */
+  typedef int charset[2];
+  const charset x;
+  /* SunOS 4.1.1 cc rejects this.  */
+  char const *const *ccp;
+  char **p;
+  /* NEC SVR4.0.2 mips cc rejects this.  */
+  struct point {int x, y;};
+  static struct point const zero = {0,0};
+  /* AIX XL C 1.02.0.0 rejects this.
+     It does not let you subtract one const X* pointer from another in
+     an arm of an if-expression whose if-part is not a constant
+     expression */
+  const char *g = "string";
+  ccp = &g + (g ? g-g : 0);
+  /* HPUX 7.0 cc rejects these. */
+  ++ccp;
+  p = (char**) ccp;
+  ccp = (char const *const *) p;
+  { /* SCO 3.2v4 cc rejects this.  */
+    char *t;
+    char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+    *t++ = 0;
+  }
+  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+    int x[] = {25, 17};
+    const int *foo = &x[0];
+    ++foo;
+  }
+  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+    typedef const int *iptr;
+    iptr p = 0;
+    ++p;
+  }
+  { /* AIX XL C 1.02.0.0 rejects this saying
+       "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+    struct s { int j; const int *ap[3]; };
+    struct s *b; b->j = 5;
+  }
+  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+    const int foo = 10;
+  }
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_const=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_c_const=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_const" >&5
+echo "${ECHO_T}$ac_cv_c_const" >&6
+if test $ac_cv_c_const = no; then
+
+cat >>confdefs.h <<\_ACEOF
+#define const
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for inline" >&5
+echo $ECHO_N "checking for inline... $ECHO_C" >&6
+if test "${ac_cv_c_inline+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_c_inline=no
+for ac_kw in inline __inline__ __inline; do
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifndef __cplusplus
+typedef int foo_t;
+static $ac_kw foo_t static_foo () {return 0; }
+$ac_kw foo_t foo () {return 0; }
+#endif
+
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_inline=$ac_kw; break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_inline" >&5
+echo "${ECHO_T}$ac_cv_c_inline" >&6
+
+
+case $ac_cv_c_inline in
+  inline | yes) ;;
+  *)
+    case $ac_cv_c_inline in
+      no) ac_val=;;
+      *) ac_val=$ac_cv_c_inline;;
+    esac
+    cat >>confdefs.h <<_ACEOF
+#ifndef __cplusplus
+#define inline $ac_val
+#endif
+_ACEOF
+    ;;
+esac
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+
+
+
+
+
+
+
+
+
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_Header=no"
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+echo "$as_me:$LINENO: checking for off_t" >&5
+echo $ECHO_N "checking for off_t... $ECHO_C" >&6
+if test "${ac_cv_type_off_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((off_t *) 0)
+  return 0;
+if (sizeof (off_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_off_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_off_t=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
+echo "${ECHO_T}$ac_cv_type_off_t" >&6
+if test $ac_cv_type_off_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define off_t long
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for size_t" >&5
+echo $ECHO_N "checking for size_t... $ECHO_C" >&6
+if test "${ac_cv_type_size_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((size_t *) 0)
+  return 0;
+if (sizeof (size_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_size_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_size_t=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
+echo "${ECHO_T}$ac_cv_type_size_t" >&6
+if test $ac_cv_type_size_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define size_t unsigned
+_ACEOF
+
+fi
+
+# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
+# for constant arguments.  Useless!
+echo "$as_me:$LINENO: checking for working alloca.h" >&5
+echo $ECHO_N "checking for working alloca.h... $ECHO_C" >&6
+if test "${ac_cv_working_alloca_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <alloca.h>
+int
+main ()
+{
+char *p = (char *) alloca (2 * sizeof (int));
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_working_alloca_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_working_alloca_h=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_working_alloca_h" >&5
+echo "${ECHO_T}$ac_cv_working_alloca_h" >&6
+if test $ac_cv_working_alloca_h = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA_H 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for alloca" >&5
+echo $ECHO_N "checking for alloca... $ECHO_C" >&6
+if test "${ac_cv_func_alloca_works+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+#else
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# else
+#  if HAVE_ALLOCA_H
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
+ #pragma alloca
+#   else
+#    ifndef alloca /* predefined by HP cc +Olibcalls */
+char *alloca ();
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+
+int
+main ()
+{
+char *p = (char *) alloca (1);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_alloca_works=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_alloca_works=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_alloca_works" >&5
+echo "${ECHO_T}$ac_cv_func_alloca_works" >&6
+
+if test $ac_cv_func_alloca_works = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA 1
+_ACEOF
+
+else
+  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
+# that cause trouble.  Some versions do not even contain alloca or
+# contain a buggy version.  If you still want to use their alloca,
+# use ar to extract alloca.o from them instead of compiling alloca.c.
+
+ALLOCA=alloca.$ac_objext
+
+cat >>confdefs.h <<\_ACEOF
+#define C_ALLOCA 1
+_ACEOF
+
+
+echo "$as_me:$LINENO: checking whether \`alloca.c' needs Cray hooks" >&5
+echo $ECHO_N "checking whether \`alloca.c' needs Cray hooks... $ECHO_C" >&6
+if test "${ac_cv_os_cray+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#if defined(CRAY) && ! defined(CRAY2)
+webecray
+#else
+wenotbecray
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "webecray" >/dev/null 2>&1; then
+  ac_cv_os_cray=yes
+else
+  ac_cv_os_cray=no
+fi
+rm -f conftest*
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_os_cray" >&5
+echo "${ECHO_T}$ac_cv_os_cray" >&6
+if test $ac_cv_os_cray = yes; then
+  for ac_func in _getb67 GETB67 getb67; do
+    as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+
+cat >>confdefs.h <<_ACEOF
+#define CRAY_STACKSEG_END $ac_func
+_ACEOF
+
+    break
+fi
+
+  done
+fi
+
+echo "$as_me:$LINENO: checking stack direction for C alloca" >&5
+echo $ECHO_N "checking stack direction for C alloca... $ECHO_C" >&6
+if test "${ac_cv_c_stack_direction+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_c_stack_direction=0
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+int
+find_stack_direction ()
+{
+  static char *addr = 0;
+  auto char dummy;
+  if (addr == 0)
+    {
+      addr = &dummy;
+      return find_stack_direction ();
+    }
+  else
+    return (&dummy > addr) ? 1 : -1;
+}
+
+int
+main ()
+{
+  exit (find_stack_direction () < 0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_stack_direction=1
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_c_stack_direction=-1
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_stack_direction" >&5
+echo "${ECHO_T}$ac_cv_c_stack_direction" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define STACK_DIRECTION $ac_cv_c_stack_direction
+_ACEOF
+
+
+fi
+
+
+
+for ac_header in stdlib.h unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+for ac_func in getpagesize
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+echo "$as_me:$LINENO: checking for working mmap" >&5
+echo $ECHO_N "checking for working mmap... $ECHO_C" >&6
+if test "${ac_cv_func_mmap_fixed_mapped+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_func_mmap_fixed_mapped=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+/* malloc might have been renamed as rpl_malloc. */
+#undef malloc
+
+/* Thanks to Mike Haertel and Jim Avera for this test.
+   Here is a matrix of mmap possibilities:
+	mmap private not fixed
+	mmap private fixed at somewhere currently unmapped
+	mmap private fixed at somewhere already mapped
+	mmap shared not fixed
+	mmap shared fixed at somewhere currently unmapped
+	mmap shared fixed at somewhere already mapped
+   For private mappings, we should verify that changes cannot be read()
+   back from the file, nor mmap's back from the file at a different
+   address.  (There have been systems where private was not correctly
+   implemented like the infamous i386 svr4.0, and systems where the
+   VM page cache was not coherent with the file system buffer cache
+   like early versions of FreeBSD and possibly contemporary NetBSD.)
+   For shared mappings, we should conversely verify that changes get
+   propagated back to all the places they're supposed to be.
+
+   Grep wants private fixed already mapped.
+   The main things grep needs to know about mmap are:
+   * does it exist and is it safe to write into the mmap'd area
+   * how to use it (BSD variants)  */
+
+#include <fcntl.h>
+#include <sys/mman.h>
+
+#if !STDC_HEADERS && !HAVE_STDLIB_H
+char *malloc ();
+#endif
+
+/* This mess was copied from the GNU getpagesize.h.  */
+#if !HAVE_GETPAGESIZE
+/* Assume that all systems that can run configure have sys/param.h.  */
+# if !HAVE_SYS_PARAM_H
+#  define HAVE_SYS_PARAM_H 1
+# endif
+
+# ifdef _SC_PAGESIZE
+#  define getpagesize() sysconf(_SC_PAGESIZE)
+# else /* no _SC_PAGESIZE */
+#  if HAVE_SYS_PARAM_H
+#   include <sys/param.h>
+#   ifdef EXEC_PAGESIZE
+#    define getpagesize() EXEC_PAGESIZE
+#   else /* no EXEC_PAGESIZE */
+#    ifdef NBPG
+#     define getpagesize() NBPG * CLSIZE
+#     ifndef CLSIZE
+#      define CLSIZE 1
+#     endif /* no CLSIZE */
+#    else /* no NBPG */
+#     ifdef NBPC
+#      define getpagesize() NBPC
+#     else /* no NBPC */
+#      ifdef PAGESIZE
+#       define getpagesize() PAGESIZE
+#      endif /* PAGESIZE */
+#     endif /* no NBPC */
+#    endif /* no NBPG */
+#   endif /* no EXEC_PAGESIZE */
+#  else /* no HAVE_SYS_PARAM_H */
+#   define getpagesize() 8192	/* punt totally */
+#  endif /* no HAVE_SYS_PARAM_H */
+# endif /* no _SC_PAGESIZE */
+
+#endif /* no HAVE_GETPAGESIZE */
+
+int
+main ()
+{
+  char *data, *data2, *data3;
+  int i, pagesize;
+  int fd;
+
+  pagesize = getpagesize ();
+
+  /* First, make a file with some known garbage in it. */
+  data = (char *) malloc (pagesize);
+  if (!data)
+    exit (1);
+  for (i = 0; i < pagesize; ++i)
+    *(data + i) = rand ();
+  umask (0);
+  fd = creat ("conftest.mmap", 0600);
+  if (fd < 0)
+    exit (1);
+  if (write (fd, data, pagesize) != pagesize)
+    exit (1);
+  close (fd);
+
+  /* Next, try to mmap the file at a fixed address which already has
+     something else allocated at it.  If we can, also make sure that
+     we see the same garbage.  */
+  fd = open ("conftest.mmap", O_RDWR);
+  if (fd < 0)
+    exit (1);
+  data2 = (char *) malloc (2 * pagesize);
+  if (!data2)
+    exit (1);
+  data2 += (pagesize - ((long) data2 & (pagesize - 1))) & (pagesize - 1);
+  if (data2 != mmap (data2, pagesize, PROT_READ | PROT_WRITE,
+		     MAP_PRIVATE | MAP_FIXED, fd, 0L))
+    exit (1);
+  for (i = 0; i < pagesize; ++i)
+    if (*(data + i) != *(data2 + i))
+      exit (1);
+
+  /* Finally, make sure that changes to the mapped area do not
+     percolate back to the file as seen by read().  (This is a bug on
+     some variants of i386 svr4.0.)  */
+  for (i = 0; i < pagesize; ++i)
+    *(data2 + i) = *(data2 + i) + 1;
+  data3 = (char *) malloc (pagesize);
+  if (!data3)
+    exit (1);
+  if (read (fd, data3, pagesize) != pagesize)
+    exit (1);
+  for (i = 0; i < pagesize; ++i)
+    if (*(data + i) != *(data3 + i))
+      exit (1);
+  close (fd);
+  exit (0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_mmap_fixed_mapped=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_func_mmap_fixed_mapped=no
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_mmap_fixed_mapped" >&5
+echo "${ECHO_T}$ac_cv_func_mmap_fixed_mapped" >&6
+if test $ac_cv_func_mmap_fixed_mapped = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_MMAP 1
+_ACEOF
+
+fi
+rm -f conftest.mmap
+
+
+
+
+
+
+
+
+
+
+
+for ac_header in argz.h limits.h locale.h nl_types.h malloc.h string.h \
+unistd.h values.h sys/param.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+
+
+
+
+
+
+for ac_func in getcwd munmap putenv setenv setlocale strchr strcasecmp \
+__argz_count __argz_stringify __argz_next
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+   if test "${ac_cv_func_stpcpy+set}" != "set"; then
+
+for ac_func in stpcpy
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+   fi
+   if test "${ac_cv_func_stpcpy}" = "yes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_STPCPY 1
+_ACEOF
+
+   fi
+
+   if test $ac_cv_header_locale_h = yes; then
+    echo "$as_me:$LINENO: checking for LC_MESSAGES" >&5
+echo $ECHO_N "checking for LC_MESSAGES... $ECHO_C" >&6
+if test "${am_cv_val_LC_MESSAGES+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <locale.h>
+int
+main ()
+{
+return LC_MESSAGES
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  am_cv_val_LC_MESSAGES=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+am_cv_val_LC_MESSAGES=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $am_cv_val_LC_MESSAGES" >&5
+echo "${ECHO_T}$am_cv_val_LC_MESSAGES" >&6
+    if test $am_cv_val_LC_MESSAGES = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_LC_MESSAGES 1
+_ACEOF
+
+    fi
+  fi
+   echo "$as_me:$LINENO: checking whether NLS is requested" >&5
+echo $ECHO_N "checking whether NLS is requested... $ECHO_C" >&6
+        # Check whether --enable-nls or --disable-nls was given.
+if test "${enable_nls+set}" = set; then
+  enableval="$enable_nls"
+  USE_NLS=$enableval
+else
+  USE_NLS=yes
+fi;
+    echo "$as_me:$LINENO: result: $USE_NLS" >&5
+echo "${ECHO_T}$USE_NLS" >&6
+
+
+    USE_INCLUDED_LIBINTL=no
+
+        if test "$USE_NLS" = "yes"; then
+      echo "$as_me:$LINENO: checking whether included gettext is requested" >&5
+echo $ECHO_N "checking whether included gettext is requested... $ECHO_C" >&6
+
+# Check whether --with-included-gettext or --without-included-gettext was given.
+if test "${with_included_gettext+set}" = set; then
+  withval="$with_included_gettext"
+  nls_cv_force_use_gnu_gettext=$withval
+else
+  nls_cv_force_use_gnu_gettext=no
+fi;
+      echo "$as_me:$LINENO: result: $nls_cv_force_use_gnu_gettext" >&5
+echo "${ECHO_T}$nls_cv_force_use_gnu_gettext" >&6
+
+      nls_cv_use_gnu_gettext="$nls_cv_force_use_gnu_gettext"
+      if test "$nls_cv_force_use_gnu_gettext" != "yes"; then
+                        		nls_cv_header_intl=
+	nls_cv_header_libgt=
+	CATOBJEXT=
+
+	if test "${ac_cv_header_libintl_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for libintl.h" >&5
+echo $ECHO_N "checking for libintl.h... $ECHO_C" >&6
+if test "${ac_cv_header_libintl_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_libintl_h" >&5
+echo "${ECHO_T}$ac_cv_header_libintl_h" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking libintl.h usability" >&5
+echo $ECHO_N "checking libintl.h usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <libintl.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking libintl.h presence" >&5
+echo $ECHO_N "checking libintl.h presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <libintl.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: libintl.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: libintl.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libintl.h: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: libintl.h: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: libintl.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: libintl.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libintl.h:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: libintl.h:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libintl.h: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: libintl.h: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libintl.h:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: libintl.h:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libintl.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: libintl.h: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libintl.h: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: libintl.h: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for libintl.h" >&5
+echo $ECHO_N "checking for libintl.h... $ECHO_C" >&6
+if test "${ac_cv_header_libintl_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_libintl_h=$ac_header_preproc
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_libintl_h" >&5
+echo "${ECHO_T}$ac_cv_header_libintl_h" >&6
+
+fi
+if test $ac_cv_header_libintl_h = yes; then
+  echo "$as_me:$LINENO: checking for gettext in libc" >&5
+echo $ECHO_N "checking for gettext in libc... $ECHO_C" >&6
+if test "${gt_cv_func_gettext_libc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <libintl.h>
+int
+main ()
+{
+return (int) gettext ("")
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  gt_cv_func_gettext_libc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gt_cv_func_gettext_libc=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $gt_cv_func_gettext_libc" >&5
+echo "${ECHO_T}$gt_cv_func_gettext_libc" >&6
+
+	   if test "$gt_cv_func_gettext_libc" != "yes"; then
+	     echo "$as_me:$LINENO: checking for bindtextdomain in -lintl" >&5
+echo $ECHO_N "checking for bindtextdomain in -lintl... $ECHO_C" >&6
+if test "${ac_cv_lib_intl_bindtextdomain+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lintl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char bindtextdomain ();
+int
+main ()
+{
+bindtextdomain ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_intl_bindtextdomain=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_intl_bindtextdomain=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_intl_bindtextdomain" >&5
+echo "${ECHO_T}$ac_cv_lib_intl_bindtextdomain" >&6
+if test $ac_cv_lib_intl_bindtextdomain = yes; then
+  echo "$as_me:$LINENO: checking for gettext in libintl" >&5
+echo $ECHO_N "checking for gettext in libintl... $ECHO_C" >&6
+if test "${gt_cv_func_gettext_libintl+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+return (int) gettext ("")
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  gt_cv_func_gettext_libintl=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gt_cv_func_gettext_libintl=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $gt_cv_func_gettext_libintl" >&5
+echo "${ECHO_T}$gt_cv_func_gettext_libintl" >&6
+fi
+
+	   fi
+
+	   if test "$gt_cv_func_gettext_libc" = "yes" \
+	      || test "$gt_cv_func_gettext_libintl" = "yes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETTEXT 1
+_ACEOF
+
+	      # Extract the first word of "msgfmt", so it can be a program name with args.
+set dummy msgfmt; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_MSGFMT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case "$MSGFMT" in
+  /*)
+  ac_cv_path_MSGFMT="$MSGFMT" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test -z "`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`"; then
+	ac_cv_path_MSGFMT="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_MSGFMT" && ac_cv_path_MSGFMT="no"
+  ;;
+esac
+fi
+MSGFMT="$ac_cv_path_MSGFMT"
+if test -n "$MSGFMT"; then
+  echo "$as_me:$LINENO: result: $MSGFMT" >&5
+echo "${ECHO_T}$MSGFMT" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+	      if test "$MSGFMT" != "no"; then
+
+for ac_func in dcgettext
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+		# Extract the first word of "gmsgfmt", so it can be a program name with args.
+set dummy gmsgfmt; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_GMSGFMT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $GMSGFMT in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_GMSGFMT="$GMSGFMT" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_GMSGFMT="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_path_GMSGFMT" && ac_cv_path_GMSGFMT="$MSGFMT"
+  ;;
+esac
+fi
+GMSGFMT=$ac_cv_path_GMSGFMT
+
+if test -n "$GMSGFMT"; then
+  echo "$as_me:$LINENO: result: $GMSGFMT" >&5
+echo "${ECHO_T}$GMSGFMT" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+		# Extract the first word of "xgettext", so it can be a program name with args.
+set dummy xgettext; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_XGETTEXT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case "$XGETTEXT" in
+  /*)
+  ac_cv_path_XGETTEXT="$XGETTEXT" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test -z "`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`"; then
+	ac_cv_path_XGETTEXT="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_XGETTEXT" && ac_cv_path_XGETTEXT=":"
+  ;;
+esac
+fi
+XGETTEXT="$ac_cv_path_XGETTEXT"
+if test -n "$XGETTEXT"; then
+  echo "$as_me:$LINENO: result: $XGETTEXT" >&5
+echo "${ECHO_T}$XGETTEXT" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+		cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+extern int _nl_msg_cat_cntr;
+			       return _nl_msg_cat_cntr
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  CATOBJEXT=.gmo
+		   DATADIRNAME=share
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+CATOBJEXT=.mo
+		   DATADIRNAME=lib
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+		INSTOBJEXT=.mo
+	      fi
+	    fi
+
+fi
+
+
+
+
+        if test x"$CATOBJEXT" = x && test -d $srcdir/../intl; then
+	  # Neither gettext nor catgets in included in the C library.
+	  # Fall back on GNU gettext library (assuming it is present).
+	  nls_cv_use_gnu_gettext=yes
+        fi
+      fi
+
+      if test "$nls_cv_use_gnu_gettext" = "yes"; then
+                INTLOBJS="\$(GETTOBJS)"
+        # Extract the first word of "msgfmt", so it can be a program name with args.
+set dummy msgfmt; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_MSGFMT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case "$MSGFMT" in
+  /*)
+  ac_cv_path_MSGFMT="$MSGFMT" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test -z "`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`"; then
+	ac_cv_path_MSGFMT="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_MSGFMT" && ac_cv_path_MSGFMT="msgfmt"
+  ;;
+esac
+fi
+MSGFMT="$ac_cv_path_MSGFMT"
+if test -n "$MSGFMT"; then
+  echo "$as_me:$LINENO: result: $MSGFMT" >&5
+echo "${ECHO_T}$MSGFMT" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+        # Extract the first word of "gmsgfmt", so it can be a program name with args.
+set dummy gmsgfmt; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_GMSGFMT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $GMSGFMT in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_GMSGFMT="$GMSGFMT" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_GMSGFMT="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_path_GMSGFMT" && ac_cv_path_GMSGFMT="$MSGFMT"
+  ;;
+esac
+fi
+GMSGFMT=$ac_cv_path_GMSGFMT
+
+if test -n "$GMSGFMT"; then
+  echo "$as_me:$LINENO: result: $GMSGFMT" >&5
+echo "${ECHO_T}$GMSGFMT" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+        # Extract the first word of "xgettext", so it can be a program name with args.
+set dummy xgettext; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_XGETTEXT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case "$XGETTEXT" in
+  /*)
+  ac_cv_path_XGETTEXT="$XGETTEXT" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test -z "`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`"; then
+	ac_cv_path_XGETTEXT="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_XGETTEXT" && ac_cv_path_XGETTEXT=":"
+  ;;
+esac
+fi
+XGETTEXT="$ac_cv_path_XGETTEXT"
+if test -n "$XGETTEXT"; then
+  echo "$as_me:$LINENO: result: $XGETTEXT" >&5
+echo "${ECHO_T}$XGETTEXT" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+	USE_INCLUDED_LIBINTL=yes
+        CATOBJEXT=.gmo
+        INSTOBJEXT=.mo
+        DATADIRNAME=share
+	INTLDEPS='$(top_builddir)/../intl/libintl.a'
+	INTLLIBS=$INTLDEPS
+	LIBS=`echo $LIBS | sed -e 's/-lintl//'`
+        nls_cv_header_intl=libintl.h
+        nls_cv_header_libgt=libgettext.h
+      fi
+
+            if test "$XGETTEXT" != ":"; then
+			if $XGETTEXT --omit-header /dev/null 2> /dev/null; then
+	  : ;
+	else
+	  echo "$as_me:$LINENO: result: found xgettext programs is not GNU xgettext; ignore it" >&5
+echo "${ECHO_T}found xgettext programs is not GNU xgettext; ignore it" >&6
+	  XGETTEXT=":"
+	fi
+      fi
+
+      # We need to process the po/ directory.
+      POSUB=po
+    else
+      DATADIRNAME=share
+      nls_cv_header_intl=libintl.h
+      nls_cv_header_libgt=libgettext.h
+    fi
+
+    # If this is used in GNU gettext we have to set USE_NLS to `yes'
+    # because some of the sources are only built for this goal.
+    if test "$PACKAGE" = gettext; then
+      USE_NLS=yes
+      USE_INCLUDED_LIBINTL=yes
+    fi
+
+                for lang in $ALL_LINGUAS; do
+      GMOFILES="$GMOFILES $lang.gmo"
+      POFILES="$POFILES $lang.po"
+    done
+
+
+
+
+
+
+
+
+
+
+
+
+    if test "x$CATOBJEXT" != "x"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define ENABLE_NLS 1
+_ACEOF
+
+    fi
+
+
+   if test "x$CATOBJEXT" != "x"; then
+     if test "x$ALL_LINGUAS" = "x"; then
+       LINGUAS=
+     else
+       echo "$as_me:$LINENO: checking for catalogs to be installed" >&5
+echo $ECHO_N "checking for catalogs to be installed... $ECHO_C" >&6
+       NEW_LINGUAS=
+       for lang in ${LINGUAS=$ALL_LINGUAS}; do
+         case "$ALL_LINGUAS" in
+          *$lang*) NEW_LINGUAS="$NEW_LINGUAS $lang" ;;
+         esac
+       done
+       LINGUAS=$NEW_LINGUAS
+       echo "$as_me:$LINENO: result: $LINGUAS" >&5
+echo "${ECHO_T}$LINGUAS" >&6
+     fi
+
+          if test -n "$LINGUAS"; then
+       for lang in $LINGUAS; do CATALOGS="$CATALOGS $lang$CATOBJEXT"; done
+     fi
+   fi
+
+            if test $ac_cv_header_locale_h = yes; then
+     INCLUDE_LOCALE_H="#include <locale.h>"
+   else
+     INCLUDE_LOCALE_H="\
+/* The system does not provide the header <locale.h>.  Take care yourself.  */"
+   fi
+
+
+            if test -f $srcdir/po2tbl.sed.in; then
+      if test "$CATOBJEXT" = ".cat"; then
+	 if test "${ac_cv_header_linux_version_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for linux/version.h" >&5
+echo $ECHO_N "checking for linux/version.h... $ECHO_C" >&6
+if test "${ac_cv_header_linux_version_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_linux_version_h" >&5
+echo "${ECHO_T}$ac_cv_header_linux_version_h" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking linux/version.h usability" >&5
+echo $ECHO_N "checking linux/version.h usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <linux/version.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking linux/version.h presence" >&5
+echo $ECHO_N "checking linux/version.h presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <linux/version.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: linux/version.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: linux/version.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: linux/version.h: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: linux/version.h: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: linux/version.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: linux/version.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: linux/version.h:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: linux/version.h:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: linux/version.h: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: linux/version.h: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: linux/version.h:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: linux/version.h:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: linux/version.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: linux/version.h: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: linux/version.h: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: linux/version.h: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for linux/version.h" >&5
+echo $ECHO_N "checking for linux/version.h... $ECHO_C" >&6
+if test "${ac_cv_header_linux_version_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_linux_version_h=$ac_header_preproc
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_linux_version_h" >&5
+echo "${ECHO_T}$ac_cv_header_linux_version_h" >&6
+
+fi
+if test $ac_cv_header_linux_version_h = yes; then
+  msgformat=linux
+else
+  msgformat=xopen
+fi
+
+
+
+	          	 sed -e '/^#/d' $srcdir/$msgformat-msg.sed > po2msg.sed
+      fi
+            sed -e '/^#.*[^\\]$/d' -e '/^#$/d' \
+	 $srcdir/po2tbl.sed.in > po2tbl.sed
+   fi
+
+            if test "$PACKAGE" = "gettext"; then
+     GT_NO="#NO#"
+     GT_YES=
+   else
+     GT_NO=
+     GT_YES="#YES#"
+   fi
+
+
+
+   MKINSTALLDIRS="\$(srcdir)/../../mkinstalldirs"
+
+
+      l=
+
+
+            if test -f $srcdir/po/POTFILES.in; then
+      test -d po || mkdir po
+      if test "x$srcdir" != "x."; then
+	 if test "x`echo $srcdir | sed 's@/.*@@'`" = "x"; then
+	    posrcprefix="$srcdir/"
+	 else
+	    posrcprefix="../$srcdir/"
+	 fi
+      else
+	 posrcprefix="../"
+      fi
+      rm -f po/POTFILES
+      sed -e "/^#/d" -e "/^\$/d" -e "s,.*,	$posrcprefix& \\\\," -e "\$s/\(.*\) \\\\/\1/" \
+	 < $srcdir/po/POTFILES.in > po/POTFILES
+   fi
+
+
+# Check for common headers.
+# FIXME: Seems to me this can cause problems for i386-windows hosts.
+# At one point there were hardcoded AC_DEFINE's if ${host} = i386-*-windows*.
+
+
+
+
+
+for ac_header in stdlib.h string.h strings.h unistd.h time.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in sys/time.h sys/resource.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in fcntl.h fpu_control.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+for ac_header in dlfcn.h errno.h sys/stat.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+for ac_func in getrusage time sigaction __setfpucw
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+# Check for socket libraries
+
+echo "$as_me:$LINENO: checking for bind in -lsocket" >&5
+echo $ECHO_N "checking for bind in -lsocket... $ECHO_C" >&6
+if test "${ac_cv_lib_socket_bind+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsocket  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char bind ();
+int
+main ()
+{
+bind ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_socket_bind=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_socket_bind=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_socket_bind" >&5
+echo "${ECHO_T}$ac_cv_lib_socket_bind" >&6
+if test $ac_cv_lib_socket_bind = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBSOCKET 1
+_ACEOF
+
+  LIBS="-lsocket $LIBS"
+
+fi
+
+
+echo "$as_me:$LINENO: checking for gethostbyname in -lnsl" >&5
+echo $ECHO_N "checking for gethostbyname in -lnsl... $ECHO_C" >&6
+if test "${ac_cv_lib_nsl_gethostbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnsl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+int
+main ()
+{
+gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_nsl_gethostbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_nsl_gethostbyname=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
+echo "${ECHO_T}$ac_cv_lib_nsl_gethostbyname" >&6
+if test $ac_cv_lib_nsl_gethostbyname = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBNSL 1
+_ACEOF
+
+  LIBS="-lnsl $LIBS"
+
+fi
+
+
+. ${srcdir}/../../bfd/configure.host
+
+
+
+USE_MAINTAINER_MODE=no
+# Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.
+if test "${enable_maintainer_mode+set}" = set; then
+  enableval="$enable_maintainer_mode"
+  case "${enableval}" in
+  yes)	MAINT="" USE_MAINTAINER_MODE=yes ;;
+  no)	MAINT="#" ;;
+  *)	{ { echo "$as_me:$LINENO: error: \"--enable-maintainer-mode does not take a value\"" >&5
+echo "$as_me: error: \"--enable-maintainer-mode does not take a value\"" >&2;}
+   { (exit 1); exit 1; }; }; MAINT="#" ;;
+esac
+if test x"$silent" != x"yes" && test x"$MAINT" = x""; then
+  echo "Setting maintainer mode" 6>&1
+fi
+else
+  MAINT="#"
+fi;
+
+
+# Check whether --enable-sim-bswap or --disable-sim-bswap was given.
+if test "${enable_sim_bswap+set}" = set; then
+  enableval="$enable_sim_bswap"
+  case "${enableval}" in
+  yes)	sim_bswap="-DWITH_BSWAP=1 -DUSE_BSWAP=1";;
+  no)	sim_bswap="-DWITH_BSWAP=0";;
+  *)	{ { echo "$as_me:$LINENO: error: \"--enable-sim-bswap does not take a value\"" >&5
+echo "$as_me: error: \"--enable-sim-bswap does not take a value\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_bswap="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_bswap" != x""; then
+  echo "Setting bswap flags = $sim_bswap" 6>&1
+fi
+else
+  sim_bswap=""
+fi;
+
+
+# Check whether --enable-sim-cflags or --disable-sim-cflags was given.
+if test "${enable_sim_cflags+set}" = set; then
+  enableval="$enable_sim_cflags"
+  case "${enableval}" in
+  yes)	 sim_cflags="-O2 -fomit-frame-pointer";;
+  trace) { { echo "$as_me:$LINENO: error: \"Please use --enable-sim-debug instead.\"" >&5
+echo "$as_me: error: \"Please use --enable-sim-debug instead.\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_cflags="";;
+  no)	 sim_cflags="";;
+  *)	 sim_cflags=`echo "${enableval}" | sed -e "s/,/ /g"`;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_cflags" != x""; then
+  echo "Setting sim cflags = $sim_cflags" 6>&1
+fi
+else
+  sim_cflags=""
+fi;
+
+
+# Check whether --enable-sim-debug or --disable-sim-debug was given.
+if test "${enable_sim_debug+set}" = set; then
+  enableval="$enable_sim_debug"
+  case "${enableval}" in
+  yes) sim_debug="-DDEBUG=7 -DWITH_DEBUG=7";;
+  no)  sim_debug="-DDEBUG=0 -DWITH_DEBUG=0";;
+  *)   sim_debug="-DDEBUG='(${enableval})' -DWITH_DEBUG='(${enableval})'";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_debug" != x""; then
+  echo "Setting sim debug = $sim_debug" 6>&1
+fi
+else
+  sim_debug=""
+fi;
+
+
+# Check whether --enable-sim-stdio or --disable-sim-stdio was given.
+if test "${enable_sim_stdio+set}" = set; then
+  enableval="$enable_sim_stdio"
+  case "${enableval}" in
+  yes)	sim_stdio="-DWITH_STDIO=DO_USE_STDIO";;
+  no)	sim_stdio="-DWITH_STDIO=DONT_USE_STDIO";;
+  *)	{ { echo "$as_me:$LINENO: error: \"Unknown value $enableval passed to --enable-sim-stdio\"" >&5
+echo "$as_me: error: \"Unknown value $enableval passed to --enable-sim-stdio\"" >&2;}
+   { (exit 1); exit 1; }; }; sim_stdio="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_stdio" != x""; then
+  echo "Setting stdio flags = $sim_stdio" 6>&1
+fi
+else
+  sim_stdio=""
+fi;
+
+
+# Check whether --enable-sim-trace or --disable-sim-trace was given.
+if test "${enable_sim_trace+set}" = set; then
+  enableval="$enable_sim_trace"
+  case "${enableval}" in
+  yes)	sim_trace="-DTRACE=1 -DWITH_TRACE=-1";;
+  no)	sim_trace="-DTRACE=0 -DWITH_TRACE=0";;
+  [-0-9]*)
+	sim_trace="-DTRACE='(${enableval})' -DWITH_TRACE='(${enableval})'";;
+  [a-z]*)
+	sim_trace=""
+	for x in `echo "$enableval" | sed -e "s/,/ /g"`; do
+	  if test x"$sim_trace" = x; then
+	    sim_trace="-DWITH_TRACE='(TRACE_$x"
+	  else
+	    sim_trace="${sim_trace}|TRACE_$x"
+	  fi
+	done
+	sim_trace="$sim_trace)'" ;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_trace" != x""; then
+  echo "Setting sim trace = $sim_trace" 6>&1
+fi
+else
+  sim_trace=""
+fi;
+
+
+# Check whether --enable-sim-profile or --disable-sim-profile was given.
+if test "${enable_sim_profile+set}" = set; then
+  enableval="$enable_sim_profile"
+  case "${enableval}" in
+  yes)	sim_profile="-DPROFILE=1 -DWITH_PROFILE=-1";;
+  no)	sim_profile="-DPROFILE=0 -DWITH_PROFILE=0";;
+  [-0-9]*)
+	sim_profile="-DPROFILE='(${enableval})' -DWITH_PROFILE='(${enableval})'";;
+  [a-z]*)
+	sim_profile=""
+	for x in `echo "$enableval" | sed -e "s/,/ /g"`; do
+	  if test x"$sim_profile" = x; then
+	    sim_profile="-DWITH_PROFILE='(PROFILE_$x"
+	  else
+	    sim_profile="${sim_profile}|PROFILE_$x"
+	  fi
+	done
+	sim_profile="$sim_profile)'" ;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_profile" != x""; then
+  echo "Setting sim profile = $sim_profile" 6>&1
+fi
+else
+  sim_profile="-DPROFILE=1 -DWITH_PROFILE=-1"
+fi;
+
+
+echo "$as_me:$LINENO: checking return type of signal handlers" >&5
+echo $ECHO_N "checking return type of signal handlers... $ECHO_C" >&6
+if test "${ac_cv_type_signal+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <signal.h>
+#ifdef signal
+# undef signal
+#endif
+#ifdef __cplusplus
+extern "C" void (*signal (int, void (*)(int)))(int);
+#else
+void (*signal ()) ();
+#endif
+
+int
+main ()
+{
+int i;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_signal=void
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_signal=int
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_signal" >&5
+echo "${ECHO_T}$ac_cv_type_signal" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define RETSIGTYPE $ac_cv_type_signal
+_ACEOF
+
+
+
+
+
+sim_link_files=
+sim_link_links=
+
+sim_link_links=tconfig.h
+if test -f ${srcdir}/tconfig.in
+then
+  sim_link_files=tconfig.in
+else
+  sim_link_files=../common/tconfig.in
+fi
+
+# targ-vals.def points to the libc macro description file.
+case "${target}" in
+*-*-*) TARG_VALS_DEF=../common/nltvals.def ;;
+esac
+sim_link_files="${sim_link_files} ${TARG_VALS_DEF}"
+sim_link_links="${sim_link_links} targ-vals.def"
+
+
+
+for ac_header in unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+ac_sources="$sim_link_files"
+ac_dests="$sim_link_links"
+while test -n "$ac_sources"; do
+  set $ac_dests; ac_dest=$1; shift; ac_dests=$*
+  set $ac_sources; ac_source=$1; shift; ac_sources=$*
+  ac_config_links_1="$ac_config_links_1 $ac_dest:$ac_source"
+done
+          ac_config_links="$ac_config_links $ac_config_links_1"
+
+cgen_breaks=""
+if grep CGEN_MAINT $srcdir/Makefile.in >/dev/null; then
+cgen_breaks="break cgen_rtx_error";
+fi
+
+          ac_config_files="$ac_config_files Makefile.sim:Makefile.in"
+
+          ac_config_files="$ac_config_files Make-common.sim:../common/Make-common.in"
+
+          ac_config_files="$ac_config_files .gdbinit:../common/gdbinit.in"
+
+          ac_config_commands="$ac_config_commands Makefile"
+
+          ac_config_commands="$ac_config_commands stamp-h"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+{
+  (set) 2>&1 |
+    case `(ac_space=' '; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;;
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+} |
+  sed '
+     t clear
+     : clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     : end' >>confcache
+if diff $cache_file confcache >/dev/null 2>&1; then :; else
+  if test -w $cache_file; then
+    test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
+    cat confcache >$cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[	 ]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[	 ]*$//;
+}'
+fi
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo "$ac_i" |
+	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Add them.
+  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6>&1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
+_ACEOF
+
+# Files that config.status was made for.
+if test -n "$ac_config_files"; then
+  echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_headers"; then
+  echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_links"; then
+  echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_commands"; then
+  echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+  --header=FILE[:TEMPLATE]
+		   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Configuration links:
+$config_links
+
+Configuration commands:
+$config_commands
+
+Report bugs to <bug-autoconf@gnu.org>."
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+ac_cs_version="\\
+config.status
+configured by $0, generated by GNU Autoconf 2.59,
+  with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+srcdir=$srcdir
+INSTALL="$INSTALL"
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1" ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+if \$ac_cs_recheck; then
+  echo "running $SHELL $0 " $ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+
+
+
+
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_config_target in $ac_config_targets
+do
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile.sim" ) CONFIG_FILES="$CONFIG_FILES Makefile.sim:Makefile.in" ;;
+  "Make-common.sim" ) CONFIG_FILES="$CONFIG_FILES Make-common.sim:../common/Make-common.in" ;;
+  ".gdbinit" ) CONFIG_FILES="$CONFIG_FILES .gdbinit:../common/gdbinit.in" ;;
+  "$ac_config_links_1" ) CONFIG_LINKS="$CONFIG_LINKS $ac_config_links_1" ;;
+  "Makefile" ) CONFIG_COMMANDS="$CONFIG_COMMANDS Makefile" ;;
+  "stamp-h" ) CONFIG_COMMANDS="$CONFIG_COMMANDS stamp-h" ;;
+  "config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS config.h:config.in" ;;
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_LINKS+set}" = set || CONFIG_LINKS=$config_links
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "\$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
+s,@SHELL@,$SHELL,;t t
+s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
+s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
+s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
+s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
+s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
+s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
+s,@exec_prefix@,$exec_prefix,;t t
+s,@prefix@,$prefix,;t t
+s,@program_transform_name@,$program_transform_name,;t t
+s,@bindir@,$bindir,;t t
+s,@sbindir@,$sbindir,;t t
+s,@libexecdir@,$libexecdir,;t t
+s,@datadir@,$datadir,;t t
+s,@sysconfdir@,$sysconfdir,;t t
+s,@sharedstatedir@,$sharedstatedir,;t t
+s,@localstatedir@,$localstatedir,;t t
+s,@libdir@,$libdir,;t t
+s,@includedir@,$includedir,;t t
+s,@oldincludedir@,$oldincludedir,;t t
+s,@infodir@,$infodir,;t t
+s,@mandir@,$mandir,;t t
+s,@build_alias@,$build_alias,;t t
+s,@host_alias@,$host_alias,;t t
+s,@target_alias@,$target_alias,;t t
+s,@DEFS@,$DEFS,;t t
+s,@ECHO_C@,$ECHO_C,;t t
+s,@ECHO_N@,$ECHO_N,;t t
+s,@ECHO_T@,$ECHO_T,;t t
+s,@LIBS@,$LIBS,;t t
+s,@sim_environment@,$sim_environment,;t t
+s,@sim_alignment@,$sim_alignment,;t t
+s,@sim_assert@,$sim_assert,;t t
+s,@sim_bitsize@,$sim_bitsize,;t t
+s,@sim_endian@,$sim_endian,;t t
+s,@sim_hostendian@,$sim_hostendian,;t t
+s,@sim_float@,$sim_float,;t t
+s,@sim_scache@,$sim_scache,;t t
+s,@sim_default_model@,$sim_default_model,;t t
+s,@sim_hw_cflags@,$sim_hw_cflags,;t t
+s,@sim_hw_objs@,$sim_hw_objs,;t t
+s,@sim_hw@,$sim_hw,;t t
+s,@sim_inline@,$sim_inline,;t t
+s,@sim_packages@,$sim_packages,;t t
+s,@sim_regparm@,$sim_regparm,;t t
+s,@sim_reserved_bits@,$sim_reserved_bits,;t t
+s,@sim_smp@,$sim_smp,;t t
+s,@sim_stdcall@,$sim_stdcall,;t t
+s,@sim_xor_endian@,$sim_xor_endian,;t t
+s,@WARN_CFLAGS@,$WARN_CFLAGS,;t t
+s,@WERROR_CFLAGS@,$WERROR_CFLAGS,;t t
+s,@build@,$build,;t t
+s,@build_cpu@,$build_cpu,;t t
+s,@build_vendor@,$build_vendor,;t t
+s,@build_os@,$build_os,;t t
+s,@host@,$host,;t t
+s,@host_cpu@,$host_cpu,;t t
+s,@host_vendor@,$host_vendor,;t t
+s,@host_os@,$host_os,;t t
+s,@target@,$target,;t t
+s,@target_cpu@,$target_cpu,;t t
+s,@target_vendor@,$target_vendor,;t t
+s,@target_os@,$target_os,;t t
+s,@CC@,$CC,;t t
+s,@CFLAGS@,$CFLAGS,;t t
+s,@LDFLAGS@,$LDFLAGS,;t t
+s,@CPPFLAGS@,$CPPFLAGS,;t t
+s,@ac_ct_CC@,$ac_ct_CC,;t t
+s,@EXEEXT@,$EXEEXT,;t t
+s,@OBJEXT@,$OBJEXT,;t t
+s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
+s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
+s,@INSTALL_DATA@,$INSTALL_DATA,;t t
+s,@CC_FOR_BUILD@,$CC_FOR_BUILD,;t t
+s,@HDEFINES@,$HDEFINES,;t t
+s,@AR@,$AR,;t t
+s,@RANLIB@,$RANLIB,;t t
+s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
+s,@SET_MAKE@,$SET_MAKE,;t t
+s,@CPP@,$CPP,;t t
+s,@EGREP@,$EGREP,;t t
+s,@ALLOCA@,$ALLOCA,;t t
+s,@USE_NLS@,$USE_NLS,;t t
+s,@MSGFMT@,$MSGFMT,;t t
+s,@GMSGFMT@,$GMSGFMT,;t t
+s,@XGETTEXT@,$XGETTEXT,;t t
+s,@USE_INCLUDED_LIBINTL@,$USE_INCLUDED_LIBINTL,;t t
+s,@CATALOGS@,$CATALOGS,;t t
+s,@CATOBJEXT@,$CATOBJEXT,;t t
+s,@DATADIRNAME@,$DATADIRNAME,;t t
+s,@GMOFILES@,$GMOFILES,;t t
+s,@INSTOBJEXT@,$INSTOBJEXT,;t t
+s,@INTLDEPS@,$INTLDEPS,;t t
+s,@INTLLIBS@,$INTLLIBS,;t t
+s,@INTLOBJS@,$INTLOBJS,;t t
+s,@POFILES@,$POFILES,;t t
+s,@POSUB@,$POSUB,;t t
+s,@INCLUDE_LOCALE_H@,$INCLUDE_LOCALE_H,;t t
+s,@GT_NO@,$GT_NO,;t t
+s,@GT_YES@,$GT_YES,;t t
+s,@MKINSTALLDIRS@,$MKINSTALLDIRS,;t t
+s,@l@,$l,;t t
+s,@MAINT@,$MAINT,;t t
+s,@sim_bswap@,$sim_bswap,;t t
+s,@sim_cflags@,$sim_cflags,;t t
+s,@sim_debug@,$sim_debug,;t t
+s,@sim_stdio@,$sim_stdio,;t t
+s,@sim_trace@,$sim_trace,;t t
+s,@sim_profile@,$sim_profile,;t t
+s,@cgen_breaks@,$cgen_breaks,;t t
+s,@LIBOBJS@,$LIBOBJS,;t t
+s,@LTLIBOBJS@,$LTLIBOBJS,;t t
+CEOF
+
+_ACEOF
+
+  cat >>$CONFIG_STATUS <<\_ACEOF
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n "$CONFIG_FILES"
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
+  esac
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+				     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+  sed "$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+s,@INSTALL@,$ac_INSTALL,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_HEADER section.
+#
+
+# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+# NAME is the cpp macro being defined and VALUE is the value it is being given.
+#
+# ac_d sets the value in "#define NAME VALUE" lines.
+ac_dA='s,^\([	 ]*\)#\([	 ]*define[	 ][	 ]*\)'
+ac_dB='[	 ].*$,\1#\2'
+ac_dC=' '
+ac_dD=',;t'
+# ac_u turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ac_uA='s,^\([	 ]*\)#\([	 ]*\)undef\([	 ][	 ]*\)'
+ac_uB='$,\1#\2define\3'
+ac_uC=' '
+ac_uD=',;t'
+
+for ac_file in : $CONFIG_HEADERS; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  test x"$ac_file" != x- && { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 # Do quote $f, to prevent DOS paths from being IFS'd.
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+  # Remove the trailing spaces.
+  sed 's/[	 ]*$//' $ac_file_inputs >$tmp/in
+
+_ACEOF
+
+# Transform confdefs.h into two sed scripts, `conftest.defines' and
+# `conftest.undefs', that substitutes the proper values into
+# config.h.in to produce config.h.  The first handles `#define'
+# templates, and the second `#undef' templates.
+# And first: Protect against being on the right side of a sed subst in
+# config.status.  Protect against being in an unquoted here document
+# in config.status.
+rm -f conftest.defines conftest.undefs
+# Using a here document instead of a string reduces the quoting nightmare.
+# Putting comments in sed scripts is not portable.
+#
+# `end' is used to avoid that the second main sed command (meant for
+# 0-ary CPP macros) applies to n-ary macro definitions.
+# See the Autoconf documentation for `clear'.
+cat >confdef2sed.sed <<\_ACEOF
+s/[\\&,]/\\&/g
+s,[\\$`],\\&,g
+t clear
+: clear
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*\)\(([^)]*)\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1\2${ac_dC}\3${ac_dD},gp
+t end
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
+: end
+_ACEOF
+# If some macros were called several times there might be several times
+# the same #defines, which is useless.  Nevertheless, we may not want to
+# sort them, since we want the *last* AC-DEFINE to be honored.
+uniq confdefs.h | sed -n -f confdef2sed.sed >conftest.defines
+sed 's/ac_d/ac_u/g' conftest.defines >conftest.undefs
+rm -f confdef2sed.sed
+
+# This sed command replaces #undef with comments.  This is necessary, for
+# example, in the case of _POSIX_SOURCE, which is predefined and required
+# on some systems where configure will not decide to define it.
+cat >>conftest.undefs <<\_ACEOF
+s,^[	 ]*#[	 ]*undef[	 ][	 ]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
+_ACEOF
+
+# Break up conftest.defines because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS
+echo '  if grep "^[	 ]*#[	 ]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
+echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS
+echo '  :' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.defines >/dev/null
+do
+  # Write a limited-size here document to $tmp/defines.sed.
+  echo '  cat >$tmp/defines.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#define' lines.
+  echo '/^[	 ]*#[	 ]*define/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.defines >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/defines.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.defines >conftest.tail
+  rm -f conftest.defines
+  mv conftest.tail conftest.defines
+done
+rm -f conftest.defines
+echo '  fi # grep' >>$CONFIG_STATUS
+echo >>$CONFIG_STATUS
+
+# Break up conftest.undefs because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #undef templates' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.undefs >/dev/null
+do
+  # Write a limited-size here document to $tmp/undefs.sed.
+  echo '  cat >$tmp/undefs.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#undef'
+  echo '/^[	 ]*#[	 ]*undef/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.undefs >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/undefs.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.undefs >conftest.tail
+  rm -f conftest.undefs
+  mv conftest.tail conftest.undefs
+done
+rm -f conftest.undefs
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    echo "/* Generated by configure.  */" >$tmp/config.h
+  else
+    echo "/* $ac_file.  Generated by configure.  */" >$tmp/config.h
+  fi
+  cat $tmp/in >>$tmp/config.h
+  rm -f $tmp/in
+  if test x"$ac_file" != x-; then
+    if diff $ac_file $tmp/config.h >/dev/null 2>&1; then
+      { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+      { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+      rm -f $ac_file
+      mv $tmp/config.h $ac_file
+    fi
+  else
+    cat $tmp/config.h
+    rm -f $tmp/config.h
+  fi
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_LINKS section.
+#
+
+for ac_file in : $CONFIG_LINKS; do test "x$ac_file" = x: && continue
+  ac_dest=`echo "$ac_file" | sed 's,:.*,,'`
+  ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
+
+  { echo "$as_me:$LINENO: linking $srcdir/$ac_source to $ac_dest" >&5
+echo "$as_me: linking $srcdir/$ac_source to $ac_dest" >&6;}
+
+  if test ! -r $srcdir/$ac_source; then
+    { { echo "$as_me:$LINENO: error: $srcdir/$ac_source: file not found" >&5
+echo "$as_me: error: $srcdir/$ac_source: file not found" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  rm -f $ac_dest
+
+  # Make relative symlinks.
+  ac_dest_dir=`(dirname "$ac_dest") 2>/dev/null ||
+$as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_dest" : 'X\(//\)[^/]' \| \
+	 X"$ac_dest" : 'X\(//\)$' \| \
+	 X"$ac_dest" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_dest" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dest_dir"
+  else
+    as_dir="$ac_dest_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dest_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dest_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dest_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dest_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dest_dir";;
+*)
+  case "$ac_dest_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dest_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dest_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  case $srcdir in
+  [\\/$]* | ?:[\\/]* ) ac_rel_source=$srcdir/$ac_source ;;
+      *) ac_rel_source=$ac_top_builddir$srcdir/$ac_source ;;
+  esac
+
+  # Try a symlink, then a hard link, then a copy.
+  ln -s $ac_rel_source $ac_dest 2>/dev/null ||
+    ln $srcdir/$ac_source $ac_dest 2>/dev/null ||
+    cp -p $srcdir/$ac_source $ac_dest ||
+    { { echo "$as_me:$LINENO: error: cannot link or copy $srcdir/$ac_source to $ac_dest" >&5
+echo "$as_me: error: cannot link or copy $srcdir/$ac_source to $ac_dest" >&2;}
+   { (exit 1); exit 1; }; }
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_COMMANDS section.
+#
+for ac_file in : $CONFIG_COMMANDS; do test "x$ac_file" = x: && continue
+  ac_dest=`echo "$ac_file" | sed 's,:.*,,'`
+  ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
+  ac_dir=`(dirname "$ac_dest") 2>/dev/null ||
+$as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_dest" : 'X\(//\)[^/]' \| \
+	 X"$ac_dest" : 'X\(//\)$' \| \
+	 X"$ac_dest" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_dest" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  { echo "$as_me:$LINENO: executing $ac_dest commands" >&5
+echo "$as_me: executing $ac_dest commands" >&6;}
+  case $ac_dest in
+    Makefile ) echo "Merging Makefile.sim+Make-common.sim into Makefile ..."
+ rm -f Makesim1.tmp Makesim2.tmp Makefile
+ sed -n -e '/^## COMMON_PRE_/,/^## End COMMON_PRE_/ p' <Make-common.sim >Makesim1.tmp
+ sed -n -e '/^## COMMON_POST_/,/^## End COMMON_POST_/ p' <Make-common.sim >Makesim2.tmp
+ sed -e '/^## COMMON_PRE_/ r Makesim1.tmp' \
+	-e '/^## COMMON_POST_/ r Makesim2.tmp' \
+	<Makefile.sim >Makefile
+ rm -f Makefile.sim Make-common.sim Makesim1.tmp Makesim2.tmp
+ ;;
+    stamp-h ) echo > stamp-h ;;
+  esac
+done
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
+
diff -Naur gdb-6.5.orig/sim/bfin/configure.ac gdb-6.5/sim/bfin/configure.ac
--- gdb-6.5.orig/sim/bfin/configure.ac	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/sim/bfin/configure.ac	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,12 @@
+dnl Process this file with autoconf to produce a configure script.
+AC_PREREQ(2.59)dnl
+AC_INIT(Makefile.in)
+AC_CONFIG_HEADER(config.h:config.in)
+
+sinclude(../common/aclocal.m4)
+
+sinclude(../common/common.m4)
+
+AC_CHECK_HEADERS(unistd.h)
+
+SIM_AC_OUTPUT
diff -Naur gdb-6.5.orig/sim/bfin/interp.c gdb-6.5/sim/bfin/interp.c
--- gdb-6.5.orig/sim/bfin/interp.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/sim/bfin/interp.c	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,651 @@
+/* Simulator for Analog Devices Blackfin processer.
+
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Analog Devices.
+
+   This file is part of simulators.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include "config.h"
+
+#include <signal.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "gdb/callback.h"
+#include "bfin-sim.h"
+#include "gdb/sim-bfin.h"
+
+/* This file is local - if newlib changes, then so should this.  */
+#include "syscall.h"
+
+#include <math.h>
+
+#ifdef _WIN32
+#include <float.h>		/* Needed for _isnan().  */
+#define isnan _isnan
+#endif
+
+#ifndef SIGBUS
+#define SIGBUS SIGSEGV
+#endif
+
+#ifndef SIGQUIT
+#define SIGQUIT SIGTERM
+#endif
+
+#ifndef SIGTRAP
+#define SIGTRAP 5
+#endif
+
+/* Define the rate at which the simulator should poll the host
+   for a quit. */
+#define POLL_QUIT_INTERVAL 0x60000
+
+saved_state_type saved_state;
+
+static char **prog_argv;
+static SIM_OPEN_KIND sim_kind;
+static char *myname;
+static int tracing = 0;
+static host_callback *callback;
+
+#if defined(__GO32__) || defined(_WIN32)
+int sim_memory_size = 19;
+#else
+int sim_memory_size = 24;
+#endif
+
+
+/* Count the number of arguments in an argv.  */
+static int
+count_argc (char **argv)
+{
+  int i;
+
+  if (! argv)
+    return -1;
+
+  for (i = 0; argv[i] != NULL; ++i)
+    continue;
+  return i;
+}
+
+/* This function exists mainly for the purpose of setting a breakpoint to
+   catch simulated bus errors when running the simulator under GDB.  */
+
+void
+raise_exception (int x)
+{
+  saved_state.exception = x;
+}
+
+void
+raise_buserror ()
+{
+  raise_exception (SIGBUS);
+}
+
+static int
+get_now ()
+{
+  return time ((long *) 0);
+}
+
+static int
+now_persec ()
+{
+  return 1;
+}
+
+/* Simulate a monitor trap, put the result into r0 and errno into r1
+   return offset by which to adjust pc.  */
+
+void
+bfin_trap ()
+{
+  int reason = DREG (2);
+  int sys = DREG (0);
+  bu32 args = DREG (1);
+
+  switch (sys)
+    {
+    case SYS_exit:
+      saved_state.exception = SIGQUIT;
+      DREG (0) = get_long (saved_state.memory, args);
+      return;
+    case SYS_open:
+      {
+	char *arg0 = (char *)(saved_state.memory + get_long (saved_state.memory, args));
+	bu32 arg1 = get_long (saved_state.memory, args + 4);
+	bu32 arg2 = get_long (saved_state.memory, args + 8);
+	if (strcmp (arg0, ":tt") == 0)
+	  DREG (0) = arg2 == 4 ? 0 : 1;
+	else
+	  DREG (0) = callback->open (callback, arg0, arg1);
+      }
+      return;
+
+    case SYS_write:
+      {
+	bu32 arg0 = get_long (saved_state.memory, args);
+	char *arg1 = (char *)(saved_state.memory + get_long (saved_state.memory, args + 4));
+	bu32 arg2 = get_long (saved_state.memory, args + 8);
+	DREG (0) = callback->write (callback, arg0, arg1, arg2);
+      }
+      return;
+
+    case SYS_read:
+      {
+	bu32 arg0 = get_long (saved_state.memory, args);
+	char *arg1 = (char *)(saved_state.memory + get_long (saved_state.memory, args + 4));
+	bu32 arg2 = get_long (saved_state.memory, args + 8);
+	DREG (0) = callback->read (callback, arg0, arg1, arg2);
+      }
+      return;
+      
+    case SYS_kill:
+      printf ("Killing with signal %d\n", get_long (saved_state.memory, args + 4));
+      raise (SIGABRT);
+
+    case SYS_close:
+      DREG (0) = callback->close (callback, get_long (saved_state.memory, args));
+      return;
+    case SYS_argc:
+      DREG (0) = count_argc (prog_argv);
+      break;
+    case SYS_argnlen:
+      {
+	bu32 arg0 = get_long (saved_state.memory, args);
+	if (arg0 < count_argc (prog_argv))
+	  DREG (0) = strlen (prog_argv[arg0]);
+	else
+	  DREG (0) = -1;
+      }
+      return;
+    case SYS_argn:
+      {
+	bu32 arg0 = get_long (saved_state.memory, args);
+	char *arg1 = (char *)(saved_state.memory + get_long (saved_state.memory, args + 4));
+	if (arg0 < count_argc (prog_argv))
+	  {
+	    /* Include the termination byte.  */
+	    int i = strlen (prog_argv[arg0]) + 1;
+	    DREG (0) = get_long (saved_state.memory, args + 4);
+	    memcpy (arg1, prog_argv[arg0], i);
+	  }
+	else
+	  DREG (0) = -1;
+      }
+      return;
+    case SYS_time:
+      DREG (0) = get_now ();
+      return;
+    default:
+      abort ();
+    }
+}
+
+void
+control_c (int sig)
+{
+  raise_exception (SIGINT);
+}
+
+/* Set the memory size to the power of two provided. */
+
+void
+sim_size (int power)
+{
+  saved_state.msize = 1 << power;
+
+  sim_memory_size = power;
+
+  if (saved_state.memory)
+    free (saved_state.memory);
+
+  saved_state.memory =
+    (unsigned char *) calloc (64, saved_state.msize / 64);
+
+  if (!saved_state.memory)
+    {
+      fprintf (stderr,
+	       "Not enough VM for simulation of %d bytes of RAM\n",
+	       saved_state.msize);
+
+      saved_state.msize = 1;
+      saved_state.memory = (unsigned char *) calloc (1, 1);
+    }
+}
+
+static void
+init_pointers ()
+{
+  if (saved_state.msize != 1 << sim_memory_size)
+    sim_size (sim_memory_size);
+}
+
+#define MMASKB ((saved_state.msize -1) & ~0)
+
+int
+sim_stop (SIM_DESC sd)
+{
+  raise_exception (SIGINT);
+  return 1;
+}
+
+/* Set by an instruction emulation function if we performed a jump.  */
+int did_jump;
+
+/* Execute a single instruction.  */
+
+static void
+step_once (SIM_DESC sd)
+{
+  bu32 oldpc = PCREG;
+
+  if (tracing)
+    fprintf (stderr, "PC: %08x, insn: %04x\n", PCREG,
+	     get_word (saved_state.memory, PCREG));
+
+  did_jump = 0;
+  interp_insn_bfin (PCREG);
+
+  /* @@@ Not sure how the hardware really behaves when the last insn
+     of a loop is a jump.  */
+  if (!did_jump)
+    {
+      if (LC1REG && oldpc == LB1REG && --LC1REG)
+	PCREG = LT1REG;
+      else if (LC0REG && oldpc == LB0REG && --LC0REG)
+	PCREG = LT0REG;
+    }
+}
+
+void
+sim_resume (SIM_DESC sd, int step, int siggnal)
+{
+  register int insts = 0;
+
+  int tick_start = get_now ();
+  void (*prev) () = signal (SIGINT, control_c);
+  void (*prev_fpe) () = signal (SIGFPE, SIG_IGN);
+
+  init_pointers ();
+
+  /* clear exceptions else it will stop */
+  saved_state.exception = 0;
+
+  if(step)
+    {
+      while(step && saved_state.exception == 0)
+	{
+	  /* not clear if this will be > 1. Potential problem area */
+	  step_once(sd);
+	  step--;
+	}
+      /* Emulate a hardware single step ... raise an exception */
+      saved_state.exception = SIGTRAP;
+    }
+  else
+    while (saved_state.exception == 0)
+      step_once(sd);
+
+  saved_state.ticks += get_now () - tick_start;
+  saved_state.insts += insts;
+
+  signal (SIGFPE, prev_fpe);
+  signal (SIGINT, prev);
+}
+
+int
+sim_write (SIM_DESC sd, SIM_ADDR addr, unsigned char *buffer, int size)
+{
+  int i;
+
+  init_pointers ();
+
+  for (i = 0; i < size; i++)
+    saved_state.memory[(MMASKB & (addr + i))] = buffer[i];
+
+  return size;
+}
+
+int
+sim_read (SIM_DESC sd, SIM_ADDR addr, unsigned char *buffer, int size)
+{
+  int i;
+
+  init_pointers ();
+
+  for (i = 0; i < size; i++)
+    buffer[i] = saved_state.memory[(MMASKB & (addr + i))];
+
+  return size;
+}
+
+int
+sim_trace (SIM_DESC sd)
+{
+  tracing = 1;
+  sim_resume (sd, 0, 0);
+  tracing = 0;
+  return 1;
+}
+
+void
+sim_stop_reason (SIM_DESC sd, enum sim_stop *reason, int *sigrc)
+{
+  if (saved_state.exception == SIGQUIT)
+    {
+      *reason = sim_exited;
+      *sigrc = DREG (0);
+    }
+  else
+    {
+      *reason = sim_stopped;
+      *sigrc = saved_state.exception;
+    }
+}
+
+void
+sim_info (SIM_DESC sd, int verbose)
+{
+  double timetaken = 
+    (double) saved_state.ticks / (double) now_persec ();
+
+  callback->printf_filtered (callback, "\n\n# instructions executed  %10d\n", 
+			     saved_state.insts);
+  callback->printf_filtered (callback, "# real time taken        %10.4f\n",
+			     timetaken);
+}
+
+static void
+parse_and_set_memory_size (char *str)
+{
+  int n;
+
+  n = strtol (str, NULL, 10);
+  if (n > 0 && n <= 24)
+    sim_memory_size = n;
+  else
+    callback->printf_filtered (callback,
+			"Bad memory size %d; must be 1 to 24, inclusive\n", n);
+}
+
+SIM_DESC
+sim_open (SIM_OPEN_KIND kind, host_callback *cb,
+	  struct bfd *abfd, char **argv)
+{
+  char **p;
+
+  sim_kind = kind;
+  myname = argv[0];
+  callback = cb;
+
+  for (p = argv + 1; *p != NULL; ++p)
+    if (isdigit (**p))
+      parse_and_set_memory_size (*p);
+
+  /* fudge our descriptor for now */
+  return (SIM_DESC) 1;
+}
+
+void
+sim_close (SIM_DESC sd, int quitting)
+{
+  /* Nothing to do.  */
+}
+
+SIM_RC
+sim_load (SIM_DESC sd, char *prog, bfd *abfd, int from_tty)
+{
+  extern bfd *sim_load_file (); /* ??? Don't know where this should live.  */
+  bfd *prog_bfd;
+
+  prog_bfd = sim_load_file (sd, myname, callback, prog, abfd,
+			    sim_kind == SIM_OPEN_DEBUG,
+			    0, sim_write);
+
+  /* Set the bfd machine type.  */
+  if (prog_bfd)
+    saved_state.bfd_mach = bfd_get_mach (prog_bfd);
+  else if (abfd)
+    saved_state.bfd_mach = bfd_get_mach (abfd);
+  else
+    saved_state.bfd_mach = 0;
+
+  if (prog_bfd == NULL)
+    return SIM_RC_FAIL;
+  if (abfd == NULL)
+    bfd_close (prog_bfd);
+  return SIM_RC_OK;
+}
+
+SIM_RC
+sim_create_inferior (SIM_DESC sd, struct bfd *prog_bfd,
+		     char **argv, char **env)
+{
+  /* Clear the registers.  */
+  memset (&saved_state, 0,
+	  (char*) &saved_state.end_of_registers - (char*) &saved_state);
+
+  /* Set the PC.  */
+  if (prog_bfd != NULL)
+    saved_state.pc = bfd_get_start_address (prog_bfd);
+
+  SPREG = saved_state.msize;
+  /* Set the bfd machine type.  */
+  if (prog_bfd != NULL)
+    saved_state.bfd_mach = bfd_get_mach (prog_bfd);
+
+  /* Record the program's arguments.  */
+  prog_argv = argv;
+
+  return SIM_RC_OK;
+}
+
+void
+sim_do_command (SIM_DESC sd, char *cmd)
+{
+  char *sms_cmd = "set-memory-size";
+  int cmdsize;
+
+  if (cmd == NULL || *cmd == '\0')
+    cmd = "help";
+
+  cmdsize = strlen (sms_cmd);
+  if (strncmp (cmd, sms_cmd, cmdsize) == 0 
+      && strchr (" \t", cmd[cmdsize]) != NULL)
+    parse_and_set_memory_size (cmd + cmdsize + 1);
+  else if (strcmp (cmd, "help") == 0)
+    {
+      (callback->printf_filtered) (callback, 
+				   "List of Blackfin simulator commands:\n\n");
+      (callback->printf_filtered) (callback, "help <n> -- Display this information\n");
+      (callback->printf_filtered) (callback, "set-memory-size <n> -- Set the number of address bits to use\n");
+      (callback->printf_filtered) (callback, "\n");
+    }
+  else
+    (callback->printf_filtered) (callback, "Error: \"%s\" is not a valid Blackfin simulator command.\n", cmd);
+}
+
+void
+sim_set_callbacks (host_callback *p)
+{
+  callback = p;
+}
+
+static bu32
+bfin_extract_unsigned_integer (unsigned char *addr, int len)
+{
+  bu32 retval;
+  unsigned char * p;
+  unsigned char * startaddr = (unsigned char *)addr;
+  unsigned char * endaddr = startaddr + len;
+ 
+  retval = 0;
+
+  for (p = endaddr; p > startaddr;)
+    retval = (retval << 8) | *--p;
+ 
+  return retval;
+}
+
+static void
+bfin_store_unsigned_integer (unsigned char *addr, int len, bu32 val)
+{
+  unsigned char *p;
+  unsigned char *startaddr = addr;
+  unsigned char *endaddr = startaddr + len;
+
+  for (p = startaddr; p < endaddr;)
+    {
+      *p++ = val & 0xff;
+      val >>= 8;
+    }
+}
+
+int
+sim_fetch_register (SIM_DESC sd, int rn, unsigned char *memory, int length)
+{
+  bu32 value;
+
+  init_pointers ();
+  switch (rn)
+    {
+    case SIM_BFIN_R0_REGNUM : value = DREG(0); break;
+    case SIM_BFIN_R1_REGNUM : value = DREG(1); break;
+    case SIM_BFIN_R2_REGNUM : value = DREG(2); break;
+    case SIM_BFIN_R3_REGNUM : value = DREG(3); break;
+    case SIM_BFIN_R4_REGNUM : value = DREG(4); break;
+    case SIM_BFIN_R5_REGNUM : value = DREG(5); break;
+    case SIM_BFIN_R6_REGNUM : value = DREG(6); break;
+    case SIM_BFIN_R7_REGNUM : value = DREG(7); break;
+    case SIM_BFIN_P0_REGNUM : value = PREG(0); break;
+    case SIM_BFIN_P1_REGNUM : value = PREG(1); break;
+    case SIM_BFIN_P2_REGNUM : value = PREG(2); break;
+    case SIM_BFIN_P3_REGNUM : value = PREG(3); break;
+    case SIM_BFIN_P4_REGNUM : value = PREG(4); break;
+    case SIM_BFIN_P5_REGNUM : value = PREG(5); break;
+    case SIM_BFIN_SP_REGNUM : value = SPREG; break;
+    case SIM_BFIN_FP_REGNUM : value = FPREG; break;
+    case SIM_BFIN_I0_REGNUM : value = IREG(0); break;
+    case SIM_BFIN_I1_REGNUM : value = IREG(1); break;
+    case SIM_BFIN_I2_REGNUM : value = IREG(2); break;
+    case SIM_BFIN_I3_REGNUM : value = IREG(3); break;
+    case SIM_BFIN_M0_REGNUM : value = MREG(0); break;
+    case SIM_BFIN_M1_REGNUM : value = MREG(1); break;
+    case SIM_BFIN_M2_REGNUM : value = MREG(2); break;
+    case SIM_BFIN_M3_REGNUM : value = MREG(3); break;
+    case SIM_BFIN_B0_REGNUM : value = BREG(0); break;
+    case SIM_BFIN_B1_REGNUM : value = BREG(1); break;
+    case SIM_BFIN_B2_REGNUM : value = BREG(2); break;
+    case SIM_BFIN_B3_REGNUM : value = BREG(3); break;
+    case SIM_BFIN_L0_REGNUM : value = LREG(0); break;
+    case SIM_BFIN_L1_REGNUM : value = LREG(1); break;
+    case SIM_BFIN_L2_REGNUM : value = LREG(2); break;
+    case SIM_BFIN_L3_REGNUM : value = LREG(3); break;
+    case SIM_BFIN_RETS_REGNUM : value = RETSREG; break;
+    case SIM_BFIN_A0_DOT_X_REGNUM : value = A0XREG; break;
+    case SIM_BFIN_AO_DOT_W_REGNUM : value = A0WREG; break;
+    case SIM_BFIN_A1_DOT_X_REGNUM : value = A1XREG; break;
+    case SIM_BFIN_A1_DOT_W_REGNUM : value = A1WREG; break;
+    case SIM_BFIN_LC0_REGNUM : value = LC0REG; break;
+    case SIM_BFIN_LT0_REGNUM : value = LT0REG; break;
+    case SIM_BFIN_LB0_REGNUM : value = LB0REG; break;
+    case SIM_BFIN_LC1_REGNUM : value = LC1REG; break;
+    case SIM_BFIN_LT1_REGNUM : value = LT1REG; break;
+    case SIM_BFIN_LB1_REGNUM : value = LB1REG; break;
+    case SIM_BFIN_PC_REGNUM : value = PCREG; break;
+    case SIM_BFIN_CC_REGNUM : value = CCREG; break;
+    default :
+      return 0; // will be an error in gdb
+      break;
+  }
+
+  bfin_store_unsigned_integer (memory, 4, value);
+
+  return -1; // disables size checking in gdb
+}
+
+int
+sim_store_register (SIM_DESC sd, int rn, unsigned char *memory, int length)
+{
+  bu32 value;
+
+  value = bfin_extract_unsigned_integer (memory, 4);
+
+  init_pointers ();
+  switch (rn)
+    {
+    case SIM_BFIN_R0_REGNUM : DREG(0) = value; break;
+    case SIM_BFIN_R1_REGNUM : DREG(1) = value; break;
+    case SIM_BFIN_R2_REGNUM : DREG(2) = value; break;
+    case SIM_BFIN_R3_REGNUM : DREG(3) = value; break;
+    case SIM_BFIN_R4_REGNUM : DREG(4) = value; break;
+    case SIM_BFIN_R5_REGNUM : DREG(5) = value; break;
+    case SIM_BFIN_R6_REGNUM : DREG(6) = value; break;
+    case SIM_BFIN_R7_REGNUM : DREG(7) = value; break;
+    case SIM_BFIN_P0_REGNUM : PREG(0) = value; break;
+    case SIM_BFIN_P1_REGNUM : PREG(1) = value; break;
+    case SIM_BFIN_P2_REGNUM : PREG(2) = value; break;
+    case SIM_BFIN_P3_REGNUM : PREG(3) = value; break;
+    case SIM_BFIN_P4_REGNUM : PREG(4) = value; break;
+    case SIM_BFIN_P5_REGNUM : PREG(5) = value; break;
+    case SIM_BFIN_SP_REGNUM : SPREG = value; break;
+    case SIM_BFIN_FP_REGNUM : FPREG = value; break;
+    case SIM_BFIN_I0_REGNUM : IREG(0) = value; break;
+    case SIM_BFIN_I1_REGNUM : IREG(1) = value; break;
+    case SIM_BFIN_I2_REGNUM : IREG(2) = value; break;
+    case SIM_BFIN_I3_REGNUM : IREG(3) = value; break;
+    case SIM_BFIN_M0_REGNUM : MREG(0) = value; break;
+    case SIM_BFIN_M1_REGNUM : MREG(1) = value; break;
+    case SIM_BFIN_M2_REGNUM : MREG(2) = value; break;
+    case SIM_BFIN_M3_REGNUM : MREG(3) = value; break;
+    case SIM_BFIN_B0_REGNUM : BREG(0) = value; break;
+    case SIM_BFIN_B1_REGNUM : BREG(1) = value; break;
+    case SIM_BFIN_B2_REGNUM : BREG(2) = value; break;
+    case SIM_BFIN_B3_REGNUM : BREG(3) = value; break;
+    case SIM_BFIN_L0_REGNUM : LREG(0) = value; break;
+    case SIM_BFIN_L1_REGNUM : LREG(1) = value; break;
+    case SIM_BFIN_L2_REGNUM : LREG(2) = value; break;
+    case SIM_BFIN_L3_REGNUM : LREG(3) = value; break;
+    case SIM_BFIN_RETS_REGNUM : RETSREG = value; break;
+    case SIM_BFIN_A0_DOT_X_REGNUM : A0XREG = value; break;
+    case SIM_BFIN_AO_DOT_W_REGNUM : A0WREG = value; break;
+    case SIM_BFIN_A1_DOT_X_REGNUM : A1XREG = value; break;
+    case SIM_BFIN_A1_DOT_W_REGNUM : A1WREG = value; break;
+    case SIM_BFIN_LC0_REGNUM : LC0REG = value; break;
+    case SIM_BFIN_LT0_REGNUM : LT0REG = value; break;
+    case SIM_BFIN_LB0_REGNUM : LB0REG = value; break;
+    case SIM_BFIN_LC1_REGNUM : LC1REG = value; break;
+    case SIM_BFIN_LT1_REGNUM : LT1REG = value; break;
+    case SIM_BFIN_LB1_REGNUM : LB1REG = value; break;
+    case SIM_BFIN_PC_REGNUM : PCREG = value; break;
+    case SIM_BFIN_CC_REGNUM : CCREG = value; break;
+    default :
+      return 0; // will be an error in gdb
+      break;
+  }
+
+  return -1; // disables size checking in gdb
+}
+
diff -Naur gdb-6.5.orig/sim/bfin/Makefile.in gdb-6.5/sim/bfin/Makefile.in
--- gdb-6.5.orig/sim/bfin/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/sim/bfin/Makefile.in	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,29 @@
+#    Makefile template for Configure for the Blackfin simulator.
+#    Copyright (C) 2005 Free Software Foundation, Inc.
+#    Written by Analog Devices, Inc.
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor,
+# Boston, MA 02110-1301, USA.
+
+## COMMON_PRE_CONFIG_FRAG
+
+SIM_OBJS = interp.o bfin-dis.o sim-load.o
+
+INCLUDE = bfin-sim.h
+
+## COMMON_POST_CONFIG_FRAG
+
+interp.o: interp.c $(INCLUDE)
+bfin-dis.o: bfin-dis.c $(INCLUDE)
diff -Naur gdb-6.5.orig/sim/bfin/syscall.h gdb-6.5/sim/bfin/syscall.h
--- gdb-6.5.orig/sim/bfin/syscall.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/sim/bfin/syscall.h	2009-01-22 08:19:21.000000000 +0100
@@ -0,0 +1,41 @@
+/* This file is copied from newlib.  Do not edit this alone.  */
+
+#define SYS_exit	1
+#define SYS_fork	2
+#define SYS_read	3
+#define SYS_write	4
+#define SYS_open	5
+#define SYS_close	6
+#define SYS_wait4	7
+#define SYS_creat	8
+#define SYS_link	9
+#define SYS_unlink	10
+#define SYS_execv	11
+#define SYS_chdir	12
+
+#define SYS_mknod	14
+#define SYS_chmod	15
+#define SYS_chown	16
+
+#define SYS_lseek	19
+#define SYS_getpid	20
+#define SYS_isatty	21
+#define SYS_fstat	22
+#define SYS_time	23
+#define SYS_kill	24
+
+#define SYS_stat	38
+
+#define SYS_pipe	42
+
+#define SYS_execve	59
+
+#define SYS_truncate	129
+#define SYS_ftruncate	130
+
+#define SYS_argc	172
+#define SYS_argnlen	173
+#define SYS_argn	174
+
+#define SYS_utime	201
+#define SYS_wait	202
diff -Naur gdb-6.5.orig/sim/configure gdb-6.5/sim/configure
--- gdb-6.5.orig/sim/configure	2006-05-05 19:11:19.000000000 +0200
+++ gdb-6.5/sim/configure	2009-01-22 08:19:21.000000000 +0100
@@ -273,6 +273,7 @@
 
 ac_unique_file="Makefile.in"
 ac_subdirs_all="$ac_subdirs_all arm"
+ac_subdirs_all="$ac_subdirs_all bfin"
 ac_subdirs_all="$ac_subdirs_all cris"
 ac_subdirs_all="$ac_subdirs_all d10v"
 ac_subdirs_all="$ac_subdirs_all frv"
@@ -3423,6 +3424,13 @@
 	   testsuite=yes
 	   common=yes
 	   ;;
+       bfin-*-*)
+
+
+subdirs="$subdirs bfin"
+
+	   common=yes
+	   ;;
        cris-*-* | crisv32-*-*)
 
 
diff -Naur gdb-6.5.orig/sim/configure.ac gdb-6.5/sim/configure.ac
--- gdb-6.5.orig/sim/configure.ac	2006-05-05 19:11:19.000000000 +0200
+++ gdb-6.5/sim/configure.ac	2009-01-22 08:19:21.000000000 +0100
@@ -52,6 +52,10 @@
 	   testsuite=yes
 	   common=yes
 	   ;;
+	bfin-*-*)
+           AC_CONFIG_SUBDIRS(bfin)
+	   common=yes
+	   ;;
        cris-*-* | crisv32-*-*)
 	   AC_CONFIG_SUBDIRS(cris)
 	   testsuite=yes
